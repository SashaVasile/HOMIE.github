/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ ! function(e, t) {
  "use strict";
  "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
      if (!e.document) throw new Error("jQuery requires a window with a document");
      return t(e)
  } : t(e)
}("undefined" != typeof window ? window : this, function(C, e) {
  "use strict";
  var t = [],
      r = Object.getPrototypeOf,
      s = t.slice,
      g = t.flat ? function(e) {
          return t.flat.call(e)
      } : function(e) {
          return t.concat.apply([], e)
      },
      u = t.push,
      i = t.indexOf,
      n = {},
      o = n.toString,
      v = n.hasOwnProperty,
      a = v.toString,
      l = a.call(Object),
      y = {},
      m = function(e) {
          return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
      },
      x = function(e) {
          return null != e && e === e.window
      },
      E = C.document,
      c = {
          type: !0,
          src: !0,
          nonce: !0,
          noModule: !0
      };

  function b(e, t, n) {
      var r, i, o = (n = n || E).createElement("script");
      if (o.text = e, t)
          for (r in c)(i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
      n.head.appendChild(o).parentNode.removeChild(o)
  }

  function w(e) {
      return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e
  }
  var f = "3.6.0",
      S = function(e, t) {
          return new S.fn.init(e, t)
      };

  function p(e) {
      var t = !!e && "length" in e && e.length,
          n = w(e);
      return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
  }
  S.fn = S.prototype = {
      jquery: f,
      constructor: S,
      length: 0,
      toArray: function() {
          return s.call(this)
      },
      get: function(e) {
          return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]
      },
      pushStack: function(e) {
          var t = S.merge(this.constructor(), e);
          return t.prevObject = this, t
      },
      each: function(e) {
          return S.each(this, e)
      },
      map: function(n) {
          return this.pushStack(S.map(this, function(e, t) {
              return n.call(e, t, e)
          }))
      },
      slice: function() {
          return this.pushStack(s.apply(this, arguments))
      },
      first: function() {
          return this.eq(0)
      },
      last: function() {
          return this.eq(-1)
      },
      even: function() {
          return this.pushStack(S.grep(this, function(e, t) {
              return (t + 1) % 2
          }))
      },
      odd: function() {
          return this.pushStack(S.grep(this, function(e, t) {
              return t % 2
          }))
      },
      eq: function(e) {
          var t = this.length,
              n = +e + (e < 0 ? t : 0);
          return this.pushStack(0 <= n && n < t ? [this[n]] : [])
      },
      end: function() {
          return this.prevObject || this.constructor()
      },
      push: u,
      sort: t.sort,
      splice: t.splice
  }, S.extend = S.fn.extend = function() {
      var e, t, n, r, i, o, a = arguments[0] || {},
          s = 1,
          u = arguments.length,
          l = !1;
      for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)
          if (null != (e = arguments[s]))
              for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r));
      return a
  }, S.extend({
      expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
      isReady: !0,
      error: function(e) {
          throw new Error(e)
      },
      noop: function() {},
      isPlainObject: function(e) {
          var t, n;
          return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof(n = v.call(t, "constructor") && t.constructor) && a.call(n) === l)
      },
      isEmptyObject: function(e) {
          var t;
          for (t in e) return !1;
          return !0
      },
      globalEval: function(e, t, n) {
          b(e, {
              nonce: t && t.nonce
          }, n)
      },
      each: function(e, t) {
          var n, r = 0;
          if (p(e)) {
              for (n = e.length; r < n; r++)
                  if (!1 === t.call(e[r], r, e[r])) break
          } else
              for (r in e)
                  if (!1 === t.call(e[r], r, e[r])) break;
          return e
      },
      makeArray: function(e, t) {
          var n = t || [];
          return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n
      },
      inArray: function(e, t, n) {
          return null == t ? -1 : i.call(t, e, n)
      },
      merge: function(e, t) {
          for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];
          return e.length = i, e
      },
      grep: function(e, t, n) {
          for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]);
          return r
      },
      map: function(e, t, n) {
          var r, i, o = 0,
              a = [];
          if (p(e))
              for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && a.push(i);
          else
              for (o in e) null != (i = t(e[o], o, n)) && a.push(i);
          return g(a)
      },
      guid: 1,
      support: y
  }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
      n["[object " + t + "]"] = t.toLowerCase()
  });
  var d = function(n) {
      var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "sizzle" + 1 * new Date,
          p = n.document,
          k = 0,
          r = 0,
          m = ue(),
          x = ue(),
          A = ue(),
          N = ue(),
          j = function(e, t) {
              return e === t && (l = !0), 0
          },
          D = {}.hasOwnProperty,
          t = [],
          q = t.pop,
          L = t.push,
          H = t.push,
          O = t.slice,
          P = function(e, t) {
              for (var n = 0, r = e.length; n < r; n++)
                  if (e[n] === t) return n;
              return -1
          },
          R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
          M = "[\\x20\\t\\r\\n\\f]",
          I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
          W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]",
          F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)",
          B = new RegExp(M + "+", "g"),
          $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
          _ = new RegExp("^" + M + "*," + M + "*"),
          z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
          U = new RegExp(M + "|>"),
          X = new RegExp(F),
          V = new RegExp("^" + I + "$"),
          G = {
              ID: new RegExp("^#(" + I + ")"),
              CLASS: new RegExp("^\\.(" + I + ")"),
              TAG: new RegExp("^(" + I + "|[*])"),
              ATTR: new RegExp("^" + W),
              PSEUDO: new RegExp("^" + F),
              CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
              bool: new RegExp("^(?:" + R + ")$", "i"),
              needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
          },
          Y = /HTML$/i,
          Q = /^(?:input|select|textarea|button)$/i,
          J = /^h\d$/i,
          K = /^[^{]+\{\s*\[native \w/,
          Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
          ee = /[+~]/,
          te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"),
          ne = function(e, t) {
              var n = "0x" + e.slice(1) - 65536;
              return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
          },
          re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
          ie = function(e, t) {
              return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
          },
          oe = function() {
              T()
          },
          ae = be(function(e) {
              return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase()
          }, {
              dir: "parentNode",
              next: "legend"
          });
      try {
          H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType
      } catch (e) {
          H = {
              apply: t.length ? function(e, t) {
                  L.apply(e, O.call(t))
              } : function(e, t) {
                  var n = e.length,
                      r = 0;
                  while (e[n++] = t[r++]);
                  e.length = n - 1
              }
          }
      }

      function se(t, e, n, r) {
          var i, o, a, s, u, l, c, f = e && e.ownerDocument,
              p = e ? e.nodeType : 9;
          if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n;
          if (!r && (T(e), e = e || C, E)) {
              if (11 !== p && (u = Z.exec(t)))
                  if (i = u[1]) {
                      if (9 === p) {
                          if (!(a = e.getElementById(i))) return n;
                          if (a.id === i) return n.push(a), n
                      } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n
                  } else {
                      if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n;
                      if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n
                  } if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) {
                  if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) {
                      (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length;
                      while (o--) l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]);
                      c = l.join(",")
                  }
                  try {
                      return H.apply(n, f.querySelectorAll(c)), n
                  } catch (e) {
                      N(t, !0)
                  } finally {
                      s === S && e.removeAttribute("id")
                  }
              }
          }
          return g(t.replace($, "$1"), e, n, r)
      }

      function ue() {
          var r = [];
          return function e(t, n) {
              return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n
          }
      }

      function le(e) {
          return e[S] = !0, e
      }

      function ce(e) {
          var t = C.createElement("fieldset");
          try {
              return !!e(t)
          } catch (e) {
              return !1
          } finally {
              t.parentNode && t.parentNode.removeChild(t), t = null
          }
      }

      function fe(e, t) {
          var n = e.split("|"),
              r = n.length;
          while (r--) b.attrHandle[n[r]] = t
      }

      function pe(e, t) {
          var n = t && e,
              r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
          if (r) return r;
          if (n)
              while (n = n.nextSibling)
                  if (n === t) return -1;
          return e ? 1 : -1
      }

      function de(t) {
          return function(e) {
              return "input" === e.nodeName.toLowerCase() && e.type === t
          }
      }

      function he(n) {
          return function(e) {
              var t = e.nodeName.toLowerCase();
              return ("input" === t || "button" === t) && e.type === n
          }
      }

      function ge(t) {
          return function(e) {
              return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t
          }
      }

      function ve(a) {
          return le(function(o) {
              return o = +o, le(function(e, t) {
                  var n, r = a([], e.length, o),
                      i = r.length;
                  while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n]))
              })
          })
      }

      function ye(e) {
          return e && "undefined" != typeof e.getElementsByTagName && e
      }
      for (e in d = se.support = {}, i = se.isXML = function(e) {
              var t = e && e.namespaceURI,
                  n = e && (e.ownerDocument || e).documentElement;
              return !Y.test(t || n && n.nodeName || "HTML")
          }, T = se.setDocument = function(e) {
              var t, n, r = e ? e.ownerDocument || e : p;
              return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function(e) {
                  return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length
              }), d.attributes = ce(function(e) {
                  return e.className = "i", !e.getAttribute("className")
              }), d.getElementsByTagName = ce(function(e) {
                  return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length
              }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function(e) {
                  return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length
              }), d.getById ? (b.filter.ID = function(e) {
                  var t = e.replace(te, ne);
                  return function(e) {
                      return e.getAttribute("id") === t
                  }
              }, b.find.ID = function(e, t) {
                  if ("undefined" != typeof t.getElementById && E) {
                      var n = t.getElementById(e);
                      return n ? [n] : []
                  }
              }) : (b.filter.ID = function(e) {
                  var n = e.replace(te, ne);
                  return function(e) {
                      var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
                      return t && t.value === n
                  }
              }, b.find.ID = function(e, t) {
                  if ("undefined" != typeof t.getElementById && E) {
                      var n, r, i, o = t.getElementById(e);
                      if (o) {
                          if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                          i = t.getElementsByName(e), r = 0;
                          while (o = i[r++])
                              if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
                      }
                      return []
                  }
              }), b.find.TAG = d.getElementsByTagName ? function(e, t) {
                  return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0
              } : function(e, t) {
                  var n, r = [],
                      i = 0,
                      o = t.getElementsByTagName(e);
                  if ("*" === e) {
                      while (n = o[i++]) 1 === n.nodeType && r.push(n);
                      return r
                  }
                  return o
              }, b.find.CLASS = d.getElementsByClassName && function(e, t) {
                  if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e)
              }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function(e) {
                  var t;
                  a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]")
              }), ce(function(e) {
                  e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                  var t = C.createElement("input");
                  t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:")
              })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function(e) {
                  d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F)
              }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function(e, t) {
                  var n = 9 === e.nodeType ? e.documentElement : e,
                      r = t && t.parentNode;
                  return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
              } : function(e, t) {
                  if (t)
                      while (t = t.parentNode)
                          if (t === e) return !0;
                  return !1
              }, j = t ? function(e, t) {
                  if (e === t) return l = !0, 0;
                  var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                  return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1)
              } : function(e, t) {
                  if (e === t) return l = !0, 0;
                  var n, r = 0,
                      i = e.parentNode,
                      o = t.parentNode,
                      a = [e],
                      s = [t];
                  if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0;
                  if (i === o) return pe(e, t);
                  n = e;
                  while (n = n.parentNode) a.unshift(n);
                  n = t;
                  while (n = n.parentNode) s.unshift(n);
                  while (a[r] === s[r]) r++;
                  return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0
              }), C
          }, se.matches = function(e, t) {
              return se(e, null, null, t)
          }, se.matchesSelector = function(e, t) {
              if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try {
                  var n = c.call(e, t);
                  if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n
              } catch (e) {
                  N(t, !0)
              }
              return 0 < se(t, C, null, [e]).length
          }, se.contains = function(e, t) {
              return (e.ownerDocument || e) != C && T(e), y(e, t)
          }, se.attr = function(e, t) {
              (e.ownerDocument || e) != C && T(e);
              var n = b.attrHandle[t.toLowerCase()],
                  r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0;
              return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
          }, se.escape = function(e) {
              return (e + "").replace(re, ie)
          }, se.error = function(e) {
              throw new Error("Syntax error, unrecognized expression: " + e)
          }, se.uniqueSort = function(e) {
              var t, n = [],
                  r = 0,
                  i = 0;
              if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) {
                  while (t = e[i++]) t === e[i] && (r = n.push(i));
                  while (r--) e.splice(n[r], 1)
              }
              return u = null, e
          }, o = se.getText = function(e) {
              var t, n = "",
                  r = 0,
                  i = e.nodeType;
              if (i) {
                  if (1 === i || 9 === i || 11 === i) {
                      if ("string" == typeof e.textContent) return e.textContent;
                      for (e = e.firstChild; e; e = e.nextSibling) n += o(e)
                  } else if (3 === i || 4 === i) return e.nodeValue
              } else
                  while (t = e[r++]) n += o(t);
              return n
          }, (b = se.selectors = {
              cacheLength: 50,
              createPseudo: le,
              match: G,
              attrHandle: {},
              find: {},
              relative: {
                  ">": {
                      dir: "parentNode",
                      first: !0
                  },
                  " ": {
                      dir: "parentNode"
                  },
                  "+": {
                      dir: "previousSibling",
                      first: !0
                  },
                  "~": {
                      dir: "previousSibling"
                  }
              },
              preFilter: {
                  ATTR: function(e) {
                      return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                  },
                  CHILD: function(e) {
                      return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e
                  },
                  PSEUDO: function(e) {
                      var t, n = !e[6] && e[2];
                      return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                  }
              },
              filter: {
                  TAG: function(e) {
                      var t = e.replace(te, ne).toLowerCase();
                      return "*" === e ? function() {
                          return !0
                      } : function(e) {
                          return e.nodeName && e.nodeName.toLowerCase() === t
                      }
                  },
                  CLASS: function(e) {
                      var t = m[e + " "];
                      return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function(e) {
                          return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "")
                      })
                  },
                  ATTR: function(n, r, i) {
                      return function(e) {
                          var t = se.attr(e, n);
                          return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"))
                      }
                  },
                  CHILD: function(h, e, t, g, v) {
                      var y = "nth" !== h.slice(0, 3),
                          m = "last" !== h.slice(-4),
                          x = "of-type" === e;
                      return 1 === g && 0 === v ? function(e) {
                          return !!e.parentNode
                      } : function(e, t, n) {
                          var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling",
                              c = e.parentNode,
                              f = x && e.nodeName.toLowerCase(),
                              p = !n && !x,
                              d = !1;
                          if (c) {
                              if (y) {
                                  while (l) {
                                      a = e;
                                      while (a = a[l])
                                          if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1;
                                      u = l = "only" === h && !u && "nextSibling"
                                  }
                                  return !0
                              }
                              if (u = [m ? c.firstChild : c.lastChild], m && p) {
                                  d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s];
                                  while (a = ++s && a && a[l] || (d = s = 0) || u.pop())
                                      if (1 === a.nodeType && ++d && a === e) {
                                          i[h] = [k, s, d];
                                          break
                                      }
                              } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d)
                                  while (a = ++s && a && a[l] || (d = s = 0) || u.pop())
                                      if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break;
                              return (d -= v) === g || d % g == 0 && 0 <= d / g
                          }
                      }
                  },
                  PSEUDO: function(e, o) {
                      var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
                      return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function(e, t) {
                          var n, r = a(e, o),
                              i = r.length;
                          while (i--) e[n = P(e, r[i])] = !(t[n] = r[i])
                      }) : function(e) {
                          return a(e, 0, t)
                      }) : a
                  }
              },
              pseudos: {
                  not: le(function(e) {
                      var r = [],
                          i = [],
                          s = f(e.replace($, "$1"));
                      return s[S] ? le(function(e, t, n, r) {
                          var i, o = s(e, null, r, []),
                              a = e.length;
                          while (a--)(i = o[a]) && (e[a] = !(t[a] = i))
                      }) : function(e, t, n) {
                          return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop()
                      }
                  }),
                  has: le(function(t) {
                      return function(e) {
                          return 0 < se(t, e).length
                      }
                  }),
                  contains: le(function(t) {
                      return t = t.replace(te, ne),
                          function(e) {
                              return -1 < (e.textContent || o(e)).indexOf(t)
                          }
                  }),
                  lang: le(function(n) {
                      return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(),
                          function(e) {
                              var t;
                              do {
                                  if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-")
                              } while ((e = e.parentNode) && 1 === e.nodeType);
                              return !1
                          }
                  }),
                  target: function(e) {
                      var t = n.location && n.location.hash;
                      return t && t.slice(1) === e.id
                  },
                  root: function(e) {
                      return e === a
                  },
                  focus: function(e) {
                      return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                  },
                  enabled: ge(!1),
                  disabled: ge(!0),
                  checked: function(e) {
                      var t = e.nodeName.toLowerCase();
                      return "input" === t && !!e.checked || "option" === t && !!e.selected
                  },
                  selected: function(e) {
                      return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
                  },
                  empty: function(e) {
                      for (e = e.firstChild; e; e = e.nextSibling)
                          if (e.nodeType < 6) return !1;
                      return !0
                  },
                  parent: function(e) {
                      return !b.pseudos.empty(e)
                  },
                  header: function(e) {
                      return J.test(e.nodeName)
                  },
                  input: function(e) {
                      return Q.test(e.nodeName)
                  },
                  button: function(e) {
                      var t = e.nodeName.toLowerCase();
                      return "input" === t && "button" === e.type || "button" === t
                  },
                  text: function(e) {
                      var t;
                      return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                  },
                  first: ve(function() {
                      return [0]
                  }),
                  last: ve(function(e, t) {
                      return [t - 1]
                  }),
                  eq: ve(function(e, t, n) {
                      return [n < 0 ? n + t : n]
                  }),
                  even: ve(function(e, t) {
                      for (var n = 0; n < t; n += 2) e.push(n);
                      return e
                  }),
                  odd: ve(function(e, t) {
                      for (var n = 1; n < t; n += 2) e.push(n);
                      return e
                  }),
                  lt: ve(function(e, t, n) {
                      for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;) e.push(r);
                      return e
                  }),
                  gt: ve(function(e, t, n) {
                      for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);
                      return e
                  })
              }
          }).pseudos.nth = b.pseudos.eq, {
              radio: !0,
              checkbox: !0,
              file: !0,
              password: !0,
              image: !0
          }) b.pseudos[e] = de(e);
      for (e in {
              submit: !0,
              reset: !0
          }) b.pseudos[e] = he(e);

      function me() {}

      function xe(e) {
          for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
          return r
      }

      function be(s, e, t) {
          var u = e.dir,
              l = e.next,
              c = l || u,
              f = t && "parentNode" === c,
              p = r++;
          return e.first ? function(e, t, n) {
              while (e = e[u])
                  if (1 === e.nodeType || f) return s(e, t, n);
              return !1
          } : function(e, t, n) {
              var r, i, o, a = [k, p];
              if (n) {
                  while (e = e[u])
                      if ((1 === e.nodeType || f) && s(e, t, n)) return !0
              } else
                  while (e = e[u])
                      if (1 === e.nodeType || f)
                          if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e;
                          else {
                              if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2];
                              if ((i[c] = a)[2] = s(e, t, n)) return !0
                          } return !1
          }
      }

      function we(i) {
          return 1 < i.length ? function(e, t, n) {
              var r = i.length;
              while (r--)
                  if (!i[r](e, t, n)) return !1;
              return !0
          } : i[0]
      }

      function Te(e, t, n, r, i) {
          for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
          return a
      }

      function Ce(d, h, g, v, y, e) {
          return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function(e, t, n, r) {
              var i, o, a, s = [],
                  u = [],
                  l = t.length,
                  c = e || function(e, t, n) {
                      for (var r = 0, i = t.length; r < i; r++) se(e, t[r], n);
                      return n
                  }(h || "*", n.nodeType ? [n] : n, []),
                  f = !d || !e && h ? c : Te(c, s, d, n, r),
                  p = g ? y || (e ? d : l || v) ? [] : t : f;
              if (g && g(f, p, n, r), v) {
                  i = Te(p, u), v(i, [], n, r), o = i.length;
                  while (o--)(a = i[o]) && (p[u[o]] = !(f[u[o]] = a))
              }
              if (e) {
                  if (y || d) {
                      if (y) {
                          i = [], o = p.length;
                          while (o--)(a = p[o]) && i.push(f[o] = a);
                          y(null, p = [], i, r)
                      }
                      o = p.length;
                      while (o--)(a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a))
                  }
              } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p)
          })
      }

      function Ee(e) {
          for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function(e) {
                  return e === i
              }, a, !0), l = be(function(e) {
                  return -1 < P(i, e)
              }, a, !0), c = [function(e, t, n) {
                  var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n));
                  return i = null, r
              }]; s < r; s++)
              if (t = b.relative[e[s].type]) c = [be(we(c), t)];
              else {
                  if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) {
                      for (n = ++s; n < r; n++)
                          if (b.relative[e[n].type]) break;
                      return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({
                          value: " " === e[s - 2].type ? "*" : ""
                      })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e))
                  }
                  c.push(t)
              } return we(c)
      }
      return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function(e, t) {
          var n, r, i, o, a, s, u, l = x[e + " "];
          if (l) return t ? 0 : l.slice(0);
          a = e, s = [], u = b.preFilter;
          while (a) {
              for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({
                      value: n,
                      type: r[0].replace($, " ")
                  }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({
                  value: n,
                  type: o,
                  matches: r
              }), a = a.slice(n.length));
              if (!n) break
          }
          return t ? a.length : a ? se.error(e) : x(e, s).slice(0)
      }, f = se.compile = function(e, t) {
          var n, v, y, m, x, r, i = [],
              o = [],
              a = A[e + " "];
          if (!a) {
              t || (t = h(e)), n = t.length;
              while (n--)(a = Ee(t[n]))[S] ? i.push(a) : o.push(a);
              (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function(e, t, n, r, i) {
                  var o, a, s, u = 0,
                      l = "0",
                      c = e && [],
                      f = [],
                      p = w,
                      d = e || x && b.find.TAG("*", i),
                      h = k += null == p ? 1 : Math.random() || .1,
                      g = d.length;
                  for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) {
                      if (x && o) {
                          a = 0, t || o.ownerDocument == C || (T(o), n = !E);
                          while (s = v[a++])
                              if (s(o, t || C, n)) {
                                  r.push(o);
                                  break
                              } i && (k = h)
                      }
                      m && ((o = !s && o) && u--, e && c.push(o))
                  }
                  if (u += l, m && l !== u) {
                      a = 0;
                      while (s = y[a++]) s(c, f, t, n);
                      if (e) {
                          if (0 < u)
                              while (l--) c[l] || f[l] || (f[l] = q.call(r));
                          f = Te(f)
                      }
                      H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r)
                  }
                  return i && (k = h, w = p), c
              }, m ? le(r) : r))).selector = e
          }
          return a
      }, g = se.select = function(e, t, n, r) {
          var i, o, a, s, u, l = "function" == typeof e && e,
              c = !r && h(e = l.selector || e);
          if (n = n || [], 1 === c.length) {
              if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) {
                  if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n;
                  l && (t = t.parentNode), e = e.slice(o.shift().value.length)
              }
              i = G.needsContext.test(e) ? 0 : o.length;
              while (i--) {
                  if (a = o[i], b.relative[s = a.type]) break;
                  if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) {
                      if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n;
                      break
                  }
              }
          }
          return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n
      }, d.sortStable = S.split("").sort(j).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function(e) {
          return 1 & e.compareDocumentPosition(C.createElement("fieldset"))
      }), ce(function(e) {
          return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
      }) || fe("type|href|height|width", function(e, t, n) {
          if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
      }), d.attributes && ce(function(e) {
          return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
      }) || fe("value", function(e, t, n) {
          if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue
      }), ce(function(e) {
          return null == e.getAttribute("disabled")
      }) || fe(R, function(e, t, n) {
          var r;
          if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
      }), se
  }(C);
  S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape;
  var h = function(e, t, n) {
          var r = [],
              i = void 0 !== n;
          while ((e = e[t]) && 9 !== e.nodeType)
              if (1 === e.nodeType) {
                  if (i && S(e).is(n)) break;
                  r.push(e)
              } return r
      },
      T = function(e, t) {
          for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
          return n
      },
      k = S.expr.match.needsContext;

  function A(e, t) {
      return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
  }
  var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

  function j(e, n, r) {
      return m(n) ? S.grep(e, function(e, t) {
          return !!n.call(e, t, e) !== r
      }) : n.nodeType ? S.grep(e, function(e) {
          return e === n !== r
      }) : "string" != typeof n ? S.grep(e, function(e) {
          return -1 < i.call(n, e) !== r
      }) : S.filter(n, e, r)
  }
  S.filter = function(e, t, n) {
      var r = t[0];
      return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function(e) {
          return 1 === e.nodeType
      }))
  }, S.fn.extend({
      find: function(e) {
          var t, n, r = this.length,
              i = this;
          if ("string" != typeof e) return this.pushStack(S(e).filter(function() {
              for (t = 0; t < r; t++)
                  if (S.contains(i[t], this)) return !0
          }));
          for (n = this.pushStack([]), t = 0; t < r; t++) S.find(e, i[t], n);
          return 1 < r ? S.uniqueSort(n) : n
      },
      filter: function(e) {
          return this.pushStack(j(this, e || [], !1))
      },
      not: function(e) {
          return this.pushStack(j(this, e || [], !0))
      },
      is: function(e) {
          return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length
      }
  });
  var D, q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
  (S.fn.init = function(e, t, n) {
      var r, i;
      if (!e) return this;
      if (n = n || D, "string" == typeof e) {
          if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
          if (r[1]) {
              if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t))
                  for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
              return this
          }
          return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this
      }
      return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this)
  }).prototype = S.fn, D = S(E);
  var L = /^(?:parents|prev(?:Until|All))/,
      H = {
          children: !0,
          contents: !0,
          next: !0,
          prev: !0
      };

  function O(e, t) {
      while ((e = e[t]) && 1 !== e.nodeType);
      return e
  }
  S.fn.extend({
      has: function(e) {
          var t = S(e, this),
              n = t.length;
          return this.filter(function() {
              for (var e = 0; e < n; e++)
                  if (S.contains(this, t[e])) return !0
          })
      },
      closest: function(e, t) {
          var n, r = 0,
              i = this.length,
              o = [],
              a = "string" != typeof e && S(e);
          if (!k.test(e))
              for (; r < i; r++)
                  for (n = this[r]; n && n !== t; n = n.parentNode)
                      if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) {
                          o.push(n);
                          break
                      } return this.pushStack(1 < o.length ? S.uniqueSort(o) : o)
      },
      index: function(e) {
          return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
      },
      add: function(e, t) {
          return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t))))
      },
      addBack: function(e) {
          return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
      }
  }), S.each({
      parent: function(e) {
          var t = e.parentNode;
          return t && 11 !== t.nodeType ? t : null
      },
      parents: function(e) {
          return h(e, "parentNode")
      },
      parentsUntil: function(e, t, n) {
          return h(e, "parentNode", n)
      },
      next: function(e) {
          return O(e, "nextSibling")
      },
      prev: function(e) {
          return O(e, "previousSibling")
      },
      nextAll: function(e) {
          return h(e, "nextSibling")
      },
      prevAll: function(e) {
          return h(e, "previousSibling")
      },
      nextUntil: function(e, t, n) {
          return h(e, "nextSibling", n)
      },
      prevUntil: function(e, t, n) {
          return h(e, "previousSibling", n)
      },
      siblings: function(e) {
          return T((e.parentNode || {}).firstChild, e)
      },
      children: function(e) {
          return T(e.firstChild)
      },
      contents: function(e) {
          return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes))
      }
  }, function(r, i) {
      S.fn[r] = function(e, t) {
          var n = S.map(this, i, e);
          return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n)
      }
  });
  var P = /[^\x20\t\r\n\f]+/g;

  function R(e) {
      return e
  }

  function M(e) {
      throw e
  }

  function I(e, t, n, r) {
      var i;
      try {
          e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r))
      } catch (e) {
          n.apply(void 0, [e])
      }
  }
  S.Callbacks = function(r) {
      var e, n;
      r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function(e, t) {
          n[t] = !0
      }), n) : S.extend({}, r);
      var i, t, o, a, s = [],
          u = [],
          l = -1,
          c = function() {
              for (a = a || r.once, o = i = !0; u.length; l = -1) {
                  t = u.shift();
                  while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1)
              }
              r.memory || (t = !1), i = !1, a && (s = t ? [] : "")
          },
          f = {
              add: function() {
                  return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) {
                      S.each(e, function(e, t) {
                          m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t)
                      })
                  }(arguments), t && !i && c()), this
              },
              remove: function() {
                  return S.each(arguments, function(e, t) {
                      var n;
                      while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l--
                  }), this
              },
              has: function(e) {
                  return e ? -1 < S.inArray(e, s) : 0 < s.length
              },
              empty: function() {
                  return s && (s = []), this
              },
              disable: function() {
                  return a = u = [], s = t = "", this
              },
              disabled: function() {
                  return !s
              },
              lock: function() {
                  return a = u = [], t || i || (s = t = ""), this
              },
              locked: function() {
                  return !!a
              },
              fireWith: function(e, t) {
                  return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this
              },
              fire: function() {
                  return f.fireWith(this, arguments), this
              },
              fired: function() {
                  return !!o
              }
          };
      return f
  }, S.extend({
      Deferred: function(e) {
          var o = [
                  ["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2],
                  ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"],
                  ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]
              ],
              i = "pending",
              a = {
                  state: function() {
                      return i
                  },
                  always: function() {
                      return s.done(arguments).fail(arguments), this
                  },
                  "catch": function(e) {
                      return a.then(null, e)
                  },
                  pipe: function() {
                      var i = arguments;
                      return S.Deferred(function(r) {
                          S.each(o, function(e, t) {
                              var n = m(i[t[4]]) && i[t[4]];
                              s[t[1]](function() {
                                  var e = n && n.apply(this, arguments);
                                  e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments)
                              })
                          }), i = null
                      }).promise()
                  },
                  then: function(t, n, r) {
                      var u = 0;

                      function l(i, o, a, s) {
                          return function() {
                              var n = this,
                                  r = arguments,
                                  e = function() {
                                      var e, t;
                                      if (!(i < u)) {
                                          if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
                                          t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r))
                                      }
                                  },
                                  t = s ? e : function() {
                                      try {
                                          e()
                                      } catch (e) {
                                          S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r))
                                      }
                                  };
                              i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t))
                          }
                      }
                      return S.Deferred(function(e) {
                          o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M))
                      }).promise()
                  },
                  promise: function(e) {
                      return null != e ? S.extend(e, a) : a
                  }
              },
              s = {};
          return S.each(o, function(e, t) {
              var n = t[2],
                  r = t[5];
              a[t[1]] = n.add, r && n.add(function() {
                  i = r
              }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function() {
                  return s[t[0] + "With"](this === s ? void 0 : this, arguments), this
              }, s[t[0] + "With"] = n.fireWith
          }), a.promise(s), e && e.call(s, s), s
      },
      when: function(e) {
          var n = arguments.length,
              t = n,
              r = Array(t),
              i = s.call(arguments),
              o = S.Deferred(),
              a = function(t) {
                  return function(e) {
                      r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i)
                  }
              };
          if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then();
          while (t--) I(i[t], a(t), o.reject);
          return o.promise()
      }
  });
  var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  S.Deferred.exceptionHook = function(e, t) {
      C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
  }, S.readyException = function(e) {
      C.setTimeout(function() {
          throw e
      })
  };
  var F = S.Deferred();

  function B() {
      E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready()
  }
  S.fn.ready = function(e) {
      return F.then(e)["catch"](function(e) {
          S.readyException(e)
      }), this
  }, S.extend({
      isReady: !1,
      readyWait: 1,
      ready: function(e) {
          (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S])
      }
  }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));
  var $ = function(e, t, n, r, i, o, a) {
          var s = 0,
              u = e.length,
              l = null == n;
          if ("object" === w(n))
              for (s in i = !0, n) $(e, t, s, n[s], !0, o, a);
          else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) {
                  return l.call(S(e), n)
              })), t))
              for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
          return i ? e : l ? t.call(e) : u ? t(e[0], n) : o
      },
      _ = /^-ms-/,
      z = /-([a-z])/g;

  function U(e, t) {
      return t.toUpperCase()
  }

  function X(e) {
      return e.replace(_, "ms-").replace(z, U)
  }
  var V = function(e) {
      return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
  };

  function G() {
      this.expando = S.expando + G.uid++
  }
  G.uid = 1, G.prototype = {
      cache: function(e) {
          var t = e[this.expando];
          return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
              value: t,
              configurable: !0
          }))), t
      },
      set: function(e, t, n) {
          var r, i = this.cache(e);
          if ("string" == typeof t) i[X(t)] = n;
          else
              for (r in t) i[X(r)] = t[r];
          return i
      },
      get: function(e, t) {
          return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)]
      },
      access: function(e, t, n) {
          return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
      },
      remove: function(e, t) {
          var n, r = e[this.expando];
          if (void 0 !== r) {
              if (void 0 !== t) {
                  n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length;
                  while (n--) delete r[t[n]]
              }(void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
          }
      },
      hasData: function(e) {
          var t = e[this.expando];
          return void 0 !== t && !S.isEmptyObject(t)
      }
  };
  var Y = new G,
      Q = new G,
      J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      K = /[A-Z]/g;

  function Z(e, t, n) {
      var r, i;
      if (void 0 === n && 1 === e.nodeType)
          if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof(n = e.getAttribute(r))) {
              try {
                  n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i)
              } catch (e) {}
              Q.set(e, t, n)
          } else n = void 0;
      return n
  }
  S.extend({
      hasData: function(e) {
          return Q.hasData(e) || Y.hasData(e)
      },
      data: function(e, t, n) {
          return Q.access(e, t, n)
      },
      removeData: function(e, t) {
          Q.remove(e, t)
      },
      _data: function(e, t, n) {
          return Y.access(e, t, n)
      },
      _removeData: function(e, t) {
          Y.remove(e, t)
      }
  }), S.fn.extend({
      data: function(n, e) {
          var t, r, i, o = this[0],
              a = o && o.attributes;
          if (void 0 === n) {
              if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
                  t = a.length;
                  while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r]));
                  Y.set(o, "hasDataAttrs", !0)
              }
              return i
          }
          return "object" == typeof n ? this.each(function() {
              Q.set(this, n)
          }) : $(this, function(e) {
              var t;
              if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0;
              this.each(function() {
                  Q.set(this, n, e)
              })
          }, null, e, 1 < arguments.length, null, !0)
      },
      removeData: function(e) {
          return this.each(function() {
              Q.remove(this, e)
          })
      }
  }), S.extend({
      queue: function(e, t, n) {
          var r;
          if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || []
      },
      dequeue: function(e, t) {
          t = t || "fx";
          var n = S.queue(e, t),
              r = n.length,
              i = n.shift(),
              o = S._queueHooks(e, t);
          "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function() {
              S.dequeue(e, t)
          }, o)), !r && o && o.empty.fire()
      },
      _queueHooks: function(e, t) {
          var n = t + "queueHooks";
          return Y.get(e, n) || Y.access(e, n, {
              empty: S.Callbacks("once memory").add(function() {
                  Y.remove(e, [t + "queue", n])
              })
          })
      }
  }), S.fn.extend({
      queue: function(t, n) {
          var e = 2;
          return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function() {
              var e = S.queue(this, t, n);
              S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t)
          })
      },
      dequeue: function(e) {
          return this.each(function() {
              S.dequeue(this, e)
          })
      },
      clearQueue: function(e) {
          return this.queue(e || "fx", [])
      },
      promise: function(e, t) {
          var n, r = 1,
              i = S.Deferred(),
              o = this,
              a = this.length,
              s = function() {
                  --r || i.resolveWith(o, [o])
              };
          "string" != typeof e && (t = e, e = void 0), e = e || "fx";
          while (a--)(n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
          return s(), i.promise(t)
      }
  });
  var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
      te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"),
      ne = ["Top", "Right", "Bottom", "Left"],
      re = E.documentElement,
      ie = function(e) {
          return S.contains(e.ownerDocument, e)
      },
      oe = {
          composed: !0
      };
  re.getRootNode && (ie = function(e) {
      return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument
  });
  var ae = function(e, t) {
      return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display")
  };

  function se(e, t, n, r) {
      var i, o, a = 20,
          s = r ? function() {
              return r.cur()
          } : function() {
              return S.css(e, t, "")
          },
          u = s(),
          l = n && n[3] || (S.cssNumber[t] ? "" : "px"),
          c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t));
      if (c && c[3] !== l) {
          u /= 2, l = l || c[3], c = +u || 1;
          while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
          c *= 2, S.style(e, t, c + l), n = n || []
      }
      return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i
  }
  var ue = {};

  function le(e, t) {
      for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n)));
      for (c = 0; c < f; c++) null != l[c] && (e[c].style.display = l[c]);
      return e
  }
  S.fn.extend({
      show: function() {
          return le(this, !0)
      },
      hide: function() {
          return le(this)
      },
      toggle: function(e) {
          return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
              ae(this) ? S(this).show() : S(this).hide()
          })
      }
  });
  var ce, fe, pe = /^(?:checkbox|radio)$/i,
      de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
      he = /^$|^module$|\/(?:java|ecma)script/i;
  ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild;
  var ge = {
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
  };

  function ve(e, t) {
      var n;
      return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n
  }

  function ye(e, t) {
      for (var n = 0, r = e.length; n < r; n++) Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval"))
  }
  ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]);
  var me = /<|&#?\w+;/;

  function xe(e, t, n, r, i) {
      for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)
          if ((o = e[d]) || 0 === o)
              if ("object" === w(o)) S.merge(p, o.nodeType ? [o] : o);
              else if (me.test(o)) {
          a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0];
          while (c--) a = a.lastChild;
          S.merge(p, a.childNodes), (a = f.firstChild).textContent = ""
      } else p.push(t.createTextNode(o));
      f.textContent = "", d = 0;
      while (o = p[d++])
          if (r && -1 < S.inArray(o, r)) i && i.push(o);
          else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) {
          c = 0;
          while (o = a[c++]) he.test(o.type || "") && n.push(o)
      }
      return f
  }
  var be = /^([^.]*)(?:\.(.+)|)/;

  function we() {
      return !0
  }

  function Te() {
      return !1
  }

  function Ce(e, t) {
      return e === function() {
          try {
              return E.activeElement
          } catch (e) {}
      }() == ("focus" === t)
  }

  function Ee(e, t, n, r, i, o) {
      var a, s;
      if ("object" == typeof t) {
          for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ee(e, s, n, r, t[s], o);
          return e
      }
      if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Te;
      else if (!i) return e;
      return 1 === o && (a = i, (i = function(e) {
          return S().off(e), a.apply(this, arguments)
      }).guid = a.guid || (a.guid = S.guid++)), e.each(function() {
          S.event.add(this, t, i, r, n)
      })
  }

  function Se(e, i, o) {
      o ? (Y.set(e, i, !1), S.event.add(e, i, {
          namespace: !1,
          handler: function(e) {
              var t, n, r = Y.get(this, i);
              if (1 & e.isTrigger && this[i]) {
                  if (r.length)(S.event.special[i] || {}).delegateType && e.stopPropagation();
                  else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n && n.value
              } else r.length && (Y.set(this, i, {
                  value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this)
              }), e.stopImmediatePropagation())
          }
      })) : void 0 === Y.get(e, i) && S.event.add(e, i, we)
  }
  S.event = {
      global: {},
      add: function(t, e, n, r, i) {
          var o, a, s, u, l, c, f, p, d, h, g, v = Y.get(t);
          if (V(t)) {
              n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function(e) {
                  return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0
              }), l = (e = (e || "").match(P) || [""]).length;
              while (l--) d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({
                  type: d,
                  origType: g,
                  data: r,
                  handler: n,
                  guid: n.guid,
                  selector: i,
                  needsContext: i && S.expr.match.needsContext.test(i),
                  namespace: h.join(".")
              }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0)
          }
      },
      remove: function(e, t, n, r, i) {
          var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData(e) && Y.get(e);
          if (v && (u = v.events)) {
              l = (t = (t || "").match(P) || [""]).length;
              while (l--)
                  if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
                      f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;
                      while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
                      a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d])
                  } else
                      for (d in u) S.event.remove(e, d + t[l], n, r, !0);
              S.isEmptyObject(u) && Y.remove(e, "handle events")
          }
      },
      dispatch: function(e) {
          var t, n, r, i, o, a, s = new Array(arguments.length),
              u = S.event.fix(e),
              l = (Y.get(this, "events") || Object.create(null))[u.type] || [],
              c = S.event.special[u.type] || {};
          for (s[0] = u, t = 1; t < arguments.length; t++) s[t] = arguments[t];
          if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) {
              a = S.event.handlers.call(this, u, l), t = 0;
              while ((i = a[t++]) && !u.isPropagationStopped()) {
                  u.currentTarget = i.elem, n = 0;
                  while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation()))
              }
              return c.postDispatch && c.postDispatch.call(this, u), u.result
          }
      },
      handlers: function(e, t) {
          var n, r, i, o, a, s = [],
              u = t.delegateCount,
              l = e.target;
          if (u && l.nodeType && !("click" === e.type && 1 <= e.button))
              for (; l !== this; l = l.parentNode || this)
                  if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
                      for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r);
                      o.length && s.push({
                          elem: l,
                          handlers: o
                      })
                  } return l = this, u < t.length && s.push({
              elem: l,
              handlers: t.slice(u)
          }), s
      },
      addProp: function(t, e) {
          Object.defineProperty(S.Event.prototype, t, {
              enumerable: !0,
              configurable: !0,
              get: m(e) ? function() {
                  if (this.originalEvent) return e(this.originalEvent)
              } : function() {
                  if (this.originalEvent) return this.originalEvent[t]
              },
              set: function(e) {
                  Object.defineProperty(this, t, {
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                      value: e
                  })
              }
          })
      },
      fix: function(e) {
          return e[S.expando] ? e : new S.Event(e)
      },
      special: {
          load: {
              noBubble: !0
          },
          click: {
              setup: function(e) {
                  var t = this || e;
                  return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1
              },
              trigger: function(e) {
                  var t = this || e;
                  return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0
              },
              _default: function(e) {
                  var t = e.target;
                  return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a")
              }
          },
          beforeunload: {
              postDispatch: function(e) {
                  void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
              }
          }
      }
  }, S.removeEvent = function(e, t, n) {
      e.removeEventListener && e.removeEventListener(t, n)
  }, S.Event = function(e, t) {
      if (!(this instanceof S.Event)) return new S.Event(e, t);
      e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0
  }, S.Event.prototype = {
      constructor: S.Event,
      isDefaultPrevented: Te,
      isPropagationStopped: Te,
      isImmediatePropagationStopped: Te,
      isSimulated: !1,
      preventDefault: function() {
          var e = this.originalEvent;
          this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault()
      },
      stopPropagation: function() {
          var e = this.originalEvent;
          this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation()
      },
      stopImmediatePropagation: function() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
      }
  }, S.each({
      altKey: !0,
      bubbles: !0,
      cancelable: !0,
      changedTouches: !0,
      ctrlKey: !0,
      detail: !0,
      eventPhase: !0,
      metaKey: !0,
      pageX: !0,
      pageY: !0,
      shiftKey: !0,
      view: !0,
      "char": !0,
      code: !0,
      charCode: !0,
      key: !0,
      keyCode: !0,
      button: !0,
      buttons: !0,
      clientX: !0,
      clientY: !0,
      offsetX: !0,
      offsetY: !0,
      pointerId: !0,
      pointerType: !0,
      screenX: !0,
      screenY: !0,
      targetTouches: !0,
      toElement: !0,
      touches: !0,
      which: !0
  }, S.event.addProp), S.each({
      focus: "focusin",
      blur: "focusout"
  }, function(e, t) {
      S.event.special[e] = {
          setup: function() {
              return Se(this, e, Ce), !1
          },
          trigger: function() {
              return Se(this, e), !0
          },
          _default: function() {
              return !0
          },
          delegateType: t
      }
  }), S.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
  }, function(e, i) {
      S.event.special[e] = {
          delegateType: i,
          bindType: i,
          handle: function(e) {
              var t, n = e.relatedTarget,
                  r = e.handleObj;
              return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t
          }
      }
  }), S.fn.extend({
      on: function(e, t, n, r) {
          return Ee(this, e, t, n, r)
      },
      one: function(e, t, n, r) {
          return Ee(this, e, t, n, r, 1)
      },
      off: function(e, t, n) {
          var r, i;
          if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
          if ("object" == typeof e) {
              for (i in e) this.off(i, t, e[i]);
              return this
          }
          return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Te), this.each(function() {
              S.event.remove(this, e, n, t)
          })
      }
  });
  var ke = /<script|<style|<link/i,
      Ae = /checked\s*(?:[^=]|=\s*.checked.)/i,
      Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  function je(e, t) {
      return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e
  }

  function De(e) {
      return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
  }

  function qe(e) {
      return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
  }

  function Le(e, t) {
      var n, r, i, o, a, s;
      if (1 === t.nodeType) {
          if (Y.hasData(e) && (s = Y.get(e).events))
              for (i in Y.remove(t, "handle events"), s)
                  for (n = 0, r = s[i].length; n < r; n++) S.event.add(t, i, s[i][n]);
          Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a))
      }
  }

  function He(n, r, i, o) {
      r = g(r);
      var e, t, a, s, u, l, c = 0,
          f = n.length,
          p = f - 1,
          d = r[0],
          h = m(d);
      if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d)) return n.each(function(e) {
          var t = n.eq(e);
          h && (r[0] = d.call(this, e, t.html())), He(t, r, i, o)
      });
      if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
          for (s = (a = S.map(ve(e, "script"), De)).length; c < f; c++) u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c);
          if (s)
              for (l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++) u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, {
                  nonce: u.nonce || u.getAttribute("nonce")
              }, l) : b(u.textContent.replace(Ne, ""), u, l))
      }
      return n
  }

  function Oe(e, t, n) {
      for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r));
      return e
  }
  S.extend({
      htmlPrefilter: function(e) {
          return e
      },
      clone: function(e, t, n) {
          var r, i, o, a, s, u, l, c = e.cloneNode(!0),
              f = ie(e);
          if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e)))
              for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++) s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
          if (t)
              if (n)
                  for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++) Le(o[r], a[r]);
              else Le(e, c);
          return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c
      },
      cleanData: function(e) {
          for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)
              if (V(n)) {
                  if (t = n[Y.expando]) {
                      if (t.events)
                          for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle);
                      n[Y.expando] = void 0
                  }
                  n[Q.expando] && (n[Q.expando] = void 0)
              }
      }
  }), S.fn.extend({
      detach: function(e) {
          return Oe(this, e, !0)
      },
      remove: function(e) {
          return Oe(this, e)
      },
      text: function(e) {
          return $(this, function(e) {
              return void 0 === e ? S.text(this) : this.empty().each(function() {
                  1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
              })
          }, null, e, arguments.length)
      },
      append: function() {
          return He(this, arguments, function(e) {
              1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e)
          })
      },
      prepend: function() {
          return He(this, arguments, function(e) {
              if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                  var t = je(this, e);
                  t.insertBefore(e, t.firstChild)
              }
          })
      },
      before: function() {
          return He(this, arguments, function(e) {
              this.parentNode && this.parentNode.insertBefore(e, this)
          })
      },
      after: function() {
          return He(this, arguments, function(e) {
              this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
          })
      },
      empty: function() {
          for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = "");
          return this
      },
      clone: function(e, t) {
          return e = null != e && e, t = null == t ? e : t, this.map(function() {
              return S.clone(this, e, t)
          })
      },
      html: function(e) {
          return $(this, function(e) {
              var t = this[0] || {},
                  n = 0,
                  r = this.length;
              if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
              if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
                  e = S.htmlPrefilter(e);
                  try {
                      for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e);
                      t = 0
                  } catch (e) {}
              }
              t && this.empty().append(e)
          }, null, e, arguments.length)
      },
      replaceWith: function() {
          var n = [];
          return He(this, arguments, function(e) {
              var t = this.parentNode;
              S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this))
          }, n)
      }
  }), S.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
  }, function(e, a) {
      S.fn[e] = function(e) {
          for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++) t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get());
          return this.pushStack(n)
      }
  });
  var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"),
      Re = function(e) {
          var t = e.ownerDocument.defaultView;
          return t && t.opener || (t = C), t.getComputedStyle(e)
      },
      Me = function(e, t, n) {
          var r, i, o = {};
          for (i in t) o[i] = e.style[i], e.style[i] = t[i];
          for (i in r = n.call(e), t) e.style[i] = o[i];
          return r
      },
      Ie = new RegExp(ne.join("|"), "i");

  function We(e, t, n) {
      var r, i, o, a, s = e.style;
      return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a
  }

  function Fe(e, t) {
      return {
          get: function() {
              if (!e()) return (this.get = t).apply(this, arguments);
              delete this.get
          }
      }
  }! function() {
      function e() {
          if (l) {
              u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l);
              var e = C.getComputedStyle(l);
              n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null
          }
      }

      function t(e) {
          return Math.round(parseFloat(e))
      }
      var n, r, i, o, a, s, u = E.createElement("div"),
          l = E.createElement("div");
      l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, {
          boxSizingReliable: function() {
              return e(), r
          },
          pixelBoxStyles: function() {
              return e(), o
          },
          pixelPosition: function() {
              return e(), n
          },
          reliableMarginLeft: function() {
              return e(), s
          },
          scrollboxSize: function() {
              return e(), i
          },
          reliableTrDimensions: function() {
              var e, t, n, r;
              return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)), a
          }
      }))
  }();
  var Be = ["Webkit", "Moz", "ms"],
      $e = E.createElement("div").style,
      _e = {};

  function ze(e) {
      var t = S.cssProps[e] || _e[e];
      return t || (e in $e ? e : _e[e] = function(e) {
          var t = e[0].toUpperCase() + e.slice(1),
              n = Be.length;
          while (n--)
              if ((e = Be[n] + t) in $e) return e
      }(e) || e)
  }
  var Ue = /^(none|table(?!-c[ea]).+)/,
      Xe = /^--/,
      Ve = {
          position: "absolute",
          visibility: "hidden",
          display: "block"
      },
      Ge = {
          letterSpacing: "0",
          fontWeight: "400"
      };

  function Ye(e, t, n) {
      var r = te.exec(t);
      return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t
  }

  function Qe(e, t, n, r, i, o) {
      var a = "width" === t ? 1 : 0,
          s = 0,
          u = 0;
      if (n === (r ? "border" : "content")) return 0;
      for (; a < 4; a += 2) "margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i));
      return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u
  }

  function Je(e, t, n) {
      var r = Re(e),
          i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r),
          o = i,
          a = We(e, t, r),
          s = "offset" + t[0].toUpperCase() + t.slice(1);
      if (Pe.test(a)) {
          if (!n) return a;
          a = "auto"
      }
      return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px"
  }

  function Ke(e, t, n, r, i) {
      return new Ke.prototype.init(e, t, n, r, i)
  }
  S.extend({
      cssHooks: {
          opacity: {
              get: function(e, t) {
                  if (t) {
                      var n = We(e, "opacity");
                      return "" === n ? "1" : n
                  }
              }
          }
      },
      cssNumber: {
          animationIterationCount: !0,
          columnCount: !0,
          fillOpacity: !0,
          flexGrow: !0,
          flexShrink: !0,
          fontWeight: !0,
          gridArea: !0,
          gridColumn: !0,
          gridColumnEnd: !0,
          gridColumnStart: !0,
          gridRow: !0,
          gridRowEnd: !0,
          gridRowStart: !0,
          lineHeight: !0,
          opacity: !0,
          order: !0,
          orphans: !0,
          widows: !0,
          zIndex: !0,
          zoom: !0
      },
      cssProps: {},
      style: function(e, t, n, r) {
          if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
              var i, o, a, s = X(t),
                  u = Xe.test(t),
                  l = e.style;
              if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
              "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n))
          }
      },
      css: function(e, t, n, r) {
          var i, o, a, s = X(t);
          return Xe.test(t) || (t = ze(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = We(e, t, r)), "normal" === i && t in Ge && (i = Ge[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
      }
  }), S.each(["height", "width"], function(e, u) {
      S.cssHooks[u] = {
          get: function(e, t, n) {
              if (t) return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function() {
                  return Je(e, u, n)
              })
          },
          set: function(e, t, n) {
              var r, i = Re(e),
                  o = !y.scrollboxSize() && "absolute" === i.position,
                  a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i),
                  s = n ? Qe(e, u, n, a, i) : 0;
              return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Ye(0, t, s)
          }
      }
  }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function(e, t) {
      if (t) return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, {
          marginLeft: 0
      }, function() {
          return e.getBoundingClientRect().left
      })) + "px"
  }), S.each({
      margin: "",
      padding: "",
      border: "Width"
  }, function(i, o) {
      S.cssHooks[i + o] = {
          expand: function(e) {
              for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) n[i + ne[t] + o] = r[t] || r[t - 2] || r[0];
              return n
          }
      }, "margin" !== i && (S.cssHooks[i + o].set = Ye)
  }), S.fn.extend({
      css: function(e, t) {
          return $(this, function(e, t, n) {
              var r, i, o = {},
                  a = 0;
              if (Array.isArray(t)) {
                  for (r = Re(e), i = t.length; a < i; a++) o[t[a]] = S.css(e, t[a], !1, r);
                  return o
              }
              return void 0 !== n ? S.style(e, t, n) : S.css(e, t)
          }, e, t, 1 < arguments.length)
      }
  }), ((S.Tween = Ke).prototype = {
      constructor: Ke,
      init: function(e, t, n, r, i, o) {
          this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px")
      },
      cur: function() {
          var e = Ke.propHooks[this.prop];
          return e && e.get ? e.get(this) : Ke.propHooks._default.get(this)
      },
      run: function(e) {
          var t, n = Ke.propHooks[this.prop];
          return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this
      }
  }).init.prototype = Ke.prototype, (Ke.propHooks = {
      _default: {
          get: function(e) {
              var t;
              return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
          },
          set: function(e) {
              S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit)
          }
      }
  }).scrollTop = Ke.propHooks.scrollLeft = {
      set: function(e) {
          e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
      }
  }, S.easing = {
      linear: function(e) {
          return e
      },
      swing: function(e) {
          return .5 - Math.cos(e * Math.PI) / 2
      },
      _default: "swing"
  }, S.fx = Ke.prototype.init, S.fx.step = {};
  var Ze, et, tt, nt, rt = /^(?:toggle|show|hide)$/,
      it = /queueHooks$/;

  function ot() {
      et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick())
  }

  function at() {
      return C.setTimeout(function() {
          Ze = void 0
      }), Ze = Date.now()
  }

  function st(e, t) {
      var n, r = 0,
          i = {
              height: e
          };
      for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = ne[r])] = i["padding" + n] = e;
      return t && (i.opacity = i.width = e), i
  }

  function ut(e, t, n) {
      for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++)
          if (r = i[o].call(n, t, e)) return r
  }

  function lt(o, e, t) {
      var n, a, r = 0,
          i = lt.prefilters.length,
          s = S.Deferred().always(function() {
              delete u.elem
          }),
          u = function() {
              if (a) return !1;
              for (var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++) l.tweens[r].run(n);
              return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1)
          },
          l = s.promise({
              elem: o,
              props: S.extend({}, e),
              opts: S.extend(!0, {
                  specialEasing: {},
                  easing: S.easing._default
              }, t),
              originalProperties: e,
              originalOptions: t,
              startTime: Ze || at(),
              duration: t.duration,
              tweens: [],
              createTween: function(e, t) {
                  var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
                  return l.tweens.push(n), n
              },
              stop: function(e) {
                  var t = 0,
                      n = e ? l.tweens.length : 0;
                  if (a) return this;
                  for (a = !0; t < n; t++) l.tweens[t].run(1);
                  return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this
              }
          }),
          c = l.props;
      for (! function(e, t) {
              var n, r, i, o, a;
              for (n in e)
                  if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && "expand" in a)
                      for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i);
                  else t[r] = i
          }(c, l.opts.specialEasing); r < i; r++)
          if (n = lt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;
      return S.map(c, ut, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, {
          elem: o,
          anim: l,
          queue: l.opts.queue
      })), l
  }
  S.Animation = S.extend(lt, {
      tweeners: {
          "*": [function(e, t) {
              var n = this.createTween(e, t);
              return se(n.elem, e, te.exec(t), n), n
          }]
      },
      tweener: function(e, t) {
          m(e) ? (t = e, e = ["*"]) : e = e.match(P);
          for (var n, r = 0, i = e.length; r < i; r++) n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t)
      },
      prefilters: [function(e, t, n) {
          var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t,
              p = this,
              d = {},
              h = e.style,
              g = e.nodeType && ae(e),
              v = Y.get(e, "fxshow");
          for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() {
                  a.unqueued || s()
              }), a.unqueued++, p.always(function() {
                  p.always(function() {
                      a.unqueued--, S.queue(e, "fx").length || a.empty.fire()
                  })
              })), t)
              if (i = t[r], rt.test(i)) {
                  if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
                      if ("show" !== i || !v || void 0 === v[r]) continue;
                      g = !0
                  }
                  d[r] = v && v[r] || S.style(e, r)
              } if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d))
              for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function() {
                      h.display = l
                  }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function() {
                      h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2]
                  })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", {
                  display: l
              }), o && (v.hidden = !g), g && le([e], !0), p.done(function() {
                  for (r in g || le([e]), Y.remove(e, "fxshow"), d) S.style(e, r, d[r])
              })), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0))
      }],
      prefilter: function(e, t) {
          t ? lt.prefilters.unshift(e) : lt.prefilters.push(e)
      }
  }), S.speed = function(e, t, n) {
      var r = e && "object" == typeof e ? S.extend({}, e) : {
          complete: n || !n && t || m(e) && e,
          duration: e,
          easing: n && t || t && !m(t) && t
      };
      return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
          m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue)
      }, r
  }, S.fn.extend({
      fadeTo: function(e, t, n, r) {
          return this.filter(ae).css("opacity", 0).show().end().animate({
              opacity: t
          }, e, n, r)
      },
      animate: function(t, e, n, r) {
          var i = S.isEmptyObject(t),
              o = S.speed(e, n, r),
              a = function() {
                  var e = lt(this, S.extend({}, t), o);
                  (i || Y.get(this, "finish")) && e.stop(!0)
              };
          return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
      },
      stop: function(i, e, o) {
          var a = function(e) {
              var t = e.stop;
              delete e.stop, t(o)
          };
          return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function() {
              var e = !0,
                  t = null != i && i + "queueHooks",
                  n = S.timers,
                  r = Y.get(this);
              if (t) r[t] && r[t].stop && a(r[t]);
              else
                  for (t in r) r[t] && r[t].stop && it.test(t) && a(r[t]);
              for (t = n.length; t--;) n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));
              !e && o || S.dequeue(this, i)
          })
      },
      finish: function(a) {
          return !1 !== a && (a = a || "fx"), this.each(function() {
              var e, t = Y.get(this),
                  n = t[a + "queue"],
                  r = t[a + "queueHooks"],
                  i = S.timers,
                  o = n ? n.length : 0;
              for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;) i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));
              for (e = 0; e < o; e++) n[e] && n[e].finish && n[e].finish.call(this);
              delete t.finish
          })
      }
  }), S.each(["toggle", "show", "hide"], function(e, r) {
      var i = S.fn[r];
      S.fn[r] = function(e, t, n) {
          return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n)
      }
  }), S.each({
      slideDown: st("show"),
      slideUp: st("hide"),
      slideToggle: st("toggle"),
      fadeIn: {
          opacity: "show"
      },
      fadeOut: {
          opacity: "hide"
      },
      fadeToggle: {
          opacity: "toggle"
      }
  }, function(e, r) {
      S.fn[e] = function(e, t, n) {
          return this.animate(r, e, t, n)
      }
  }), S.timers = [], S.fx.tick = function() {
      var e, t = 0,
          n = S.timers;
      for (Ze = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
      n.length || S.fx.stop(), Ze = void 0
  }, S.fx.timer = function(e) {
      S.timers.push(e), S.fx.start()
  }, S.fx.interval = 13, S.fx.start = function() {
      et || (et = !0, ot())
  }, S.fx.stop = function() {
      et = null
  }, S.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
  }, S.fn.delay = function(r, e) {
      return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function(e, t) {
          var n = C.setTimeout(e, r);
          t.stop = function() {
              C.clearTimeout(n)
          }
      })
  }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value;
  var ct, ft = S.expr.attrHandle;
  S.fn.extend({
      attr: function(e, t) {
          return $(this, S.attr, e, t, 1 < arguments.length)
      },
      removeAttr: function(e) {
          return this.each(function() {
              S.removeAttr(this, e)
          })
      }
  }), S.extend({
      attr: function(e, t, n) {
          var r, i, o = e.nodeType;
          if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r)
      },
      attrHooks: {
          type: {
              set: function(e, t) {
                  if (!y.radioValue && "radio" === t && A(e, "input")) {
                      var n = e.value;
                      return e.setAttribute("type", t), n && (e.value = n), t
                  }
              }
          }
      },
      removeAttr: function(e, t) {
          var n, r = 0,
              i = t && t.match(P);
          if (i && 1 === e.nodeType)
              while (n = i[r++]) e.removeAttribute(n)
      }
  }), ct = {
      set: function(e, t, n) {
          return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n
      }
  }, S.each(S.expr.match.bool.source.match(/\w+/g), function(e, t) {
      var a = ft[t] || S.find.attr;
      ft[t] = function(e, t, n) {
          var r, i, o = t.toLowerCase();
          return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i), r
      }
  });
  var pt = /^(?:input|select|textarea|button)$/i,
      dt = /^(?:a|area)$/i;

  function ht(e) {
      return (e.match(P) || []).join(" ")
  }

  function gt(e) {
      return e.getAttribute && e.getAttribute("class") || ""
  }

  function vt(e) {
      return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || []
  }
  S.fn.extend({
      prop: function(e, t) {
          return $(this, S.prop, e, t, 1 < arguments.length)
      },
      removeProp: function(e) {
          return this.each(function() {
              delete this[S.propFix[e] || e]
          })
      }
  }), S.extend({
      prop: function(e, t, n) {
          var r, i, o = e.nodeType;
          if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]
      },
      propHooks: {
          tabIndex: {
              get: function(e) {
                  var t = S.find.attr(e, "tabindex");
                  return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1
              }
          }
      },
      propFix: {
          "for": "htmlFor",
          "class": "className"
      }
  }), y.optSelected || (S.propHooks.selected = {
      get: function(e) {
          var t = e.parentNode;
          return t && t.parentNode && t.parentNode.selectedIndex, null
      },
      set: function(e) {
          var t = e.parentNode;
          t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
      }
  }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
      S.propFix[this.toLowerCase()] = this
  }), S.fn.extend({
      addClass: function(t) {
          var e, n, r, i, o, a, s, u = 0;
          if (m(t)) return this.each(function(e) {
              S(this).addClass(t.call(this, e, gt(this)))
          });
          if ((e = vt(t)).length)
              while (n = this[u++])
                  if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
                      a = 0;
                      while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
                      i !== (s = ht(r)) && n.setAttribute("class", s)
                  } return this
      },
      removeClass: function(t) {
          var e, n, r, i, o, a, s, u = 0;
          if (m(t)) return this.each(function(e) {
              S(this).removeClass(t.call(this, e, gt(this)))
          });
          if (!arguments.length) return this.attr("class", "");
          if ((e = vt(t)).length)
              while (n = this[u++])
                  if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
                      a = 0;
                      while (o = e[a++])
                          while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " ");
                      i !== (s = ht(r)) && n.setAttribute("class", s)
                  } return this
      },
      toggleClass: function(i, t) {
          var o = typeof i,
              a = "string" === o || Array.isArray(i);
          return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function(e) {
              S(this).toggleClass(i.call(this, e, gt(this), t), t)
          }) : this.each(function() {
              var e, t, n, r;
              if (a) {
                  t = 0, n = S(this), r = vt(i);
                  while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e)
              } else void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || ""))
          })
      },
      hasClass: function(e) {
          var t, n, r = 0;
          t = " " + e + " ";
          while (n = this[r++])
              if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0;
          return !1
      }
  });
  var yt = /\r/g;
  S.fn.extend({
      val: function(n) {
          var r, e, i, t = this[0];
          return arguments.length ? (i = m(n), this.each(function(e) {
              var t;
              1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function(e) {
                  return null == e ? "" : e + ""
              })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t))
          })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof(e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0
      }
  }), S.extend({
      valHooks: {
          option: {
              get: function(e) {
                  var t = S.find.attr(e, "value");
                  return null != t ? t : ht(S.text(e))
              }
          },
          select: {
              get: function(e) {
                  var t, n, r, i = e.options,
                      o = e.selectedIndex,
                      a = "select-one" === e.type,
                      s = a ? null : [],
                      u = a ? o + 1 : i.length;
                  for (r = o < 0 ? u : a ? o : 0; r < u; r++)
                      if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
                          if (t = S(n).val(), a) return t;
                          s.push(t)
                      } return s
              },
              set: function(e, t) {
                  var n, r, i = e.options,
                      o = S.makeArray(t),
                      a = i.length;
                  while (a--)((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0);
                  return n || (e.selectedIndex = -1), o
              }
          }
      }
  }), S.each(["radio", "checkbox"], function() {
      S.valHooks[this] = {
          set: function(e, t) {
              if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t)
          }
      }, y.checkOn || (S.valHooks[this].get = function(e) {
          return null === e.getAttribute("value") ? "on" : e.value
      })
  }), y.focusin = "onfocusin" in C;
  var mt = /^(?:focusinfocus|focusoutblur)$/,
      xt = function(e) {
          e.stopPropagation()
      };
  S.extend(S.event, {
      trigger: function(e, t, n, r) {
          var i, o, a, s, u, l, c, f, p = [n || E],
              d = v.call(e, "type") ? e.type : e,
              h = v.call(e, "namespace") ? e.namespace.split(".") : [];
          if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
              if (!r && !c.noBubble && !x(n)) {
                  for (s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode) p.push(o), a = o;
                  a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C)
              }
              i = 0;
              while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
              return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)), e.result
          }
      },
      simulate: function(e, t, n) {
          var r = S.extend(new S.Event, n, {
              type: e,
              isSimulated: !0
          });
          S.event.trigger(r, null, t)
      }
  }), S.fn.extend({
      trigger: function(e, t) {
          return this.each(function() {
              S.event.trigger(e, t, this)
          })
      },
      triggerHandler: function(e, t) {
          var n = this[0];
          if (n) return S.event.trigger(e, t, n, !0)
      }
  }), y.focusin || S.each({
      focus: "focusin",
      blur: "focusout"
  }, function(n, r) {
      var i = function(e) {
          S.event.simulate(r, e.target, S.event.fix(e))
      };
      S.event.special[r] = {
          setup: function() {
              var e = this.ownerDocument || this.document || this,
                  t = Y.access(e, r);
              t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1)
          },
          teardown: function() {
              var e = this.ownerDocument || this.document || this,
                  t = Y.access(e, r) - 1;
              t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r))
          }
      }
  });
  var bt = C.location,
      wt = {
          guid: Date.now()
      },
      Tt = /\?/;
  S.parseXML = function(e) {
      var t, n;
      if (!e || "string" != typeof e) return null;
      try {
          t = (new C.DOMParser).parseFromString(e, "text/xml")
      } catch (e) {}
      return n = t && t.getElementsByTagName("parsererror")[0], t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function(e) {
          return e.textContent
      }).join("\n") : e)), t
  };
  var Ct = /\[\]$/,
      Et = /\r?\n/g,
      St = /^(?:submit|button|image|reset|file)$/i,
      kt = /^(?:input|select|textarea|keygen)/i;

  function At(n, e, r, i) {
      var t;
      if (Array.isArray(e)) S.each(e, function(e, t) {
          r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i)
      });
      else if (r || "object" !== w(e)) i(n, e);
      else
          for (t in e) At(n + "[" + t + "]", e[t], r, i)
  }
  S.param = function(e, t) {
      var n, r = [],
          i = function(e, t) {
              var n = m(t) ? t() : t;
              r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
          };
      if (null == e) return "";
      if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function() {
          i(this.name, this.value)
      });
      else
          for (n in e) At(n, e[n], t, i);
      return r.join("&")
  }, S.fn.extend({
      serialize: function() {
          return S.param(this.serializeArray())
      },
      serializeArray: function() {
          return this.map(function() {
              var e = S.prop(this, "elements");
              return e ? S.makeArray(e) : this
          }).filter(function() {
              var e = this.type;
              return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e))
          }).map(function(e, t) {
              var n = S(this).val();
              return null == n ? null : Array.isArray(n) ? S.map(n, function(e) {
                  return {
                      name: t.name,
                      value: e.replace(Et, "\r\n")
                  }
              }) : {
                  name: t.name,
                  value: n.replace(Et, "\r\n")
              }
          }).get()
      }
  });
  var Nt = /%20/g,
      jt = /#.*$/,
      Dt = /([?&])_=[^&]*/,
      qt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
      Lt = /^(?:GET|HEAD)$/,
      Ht = /^\/\//,
      Ot = {},
      Pt = {},
      Rt = "*/".concat("*"),
      Mt = E.createElement("a");

  function It(o) {
      return function(e, t) {
          "string" != typeof e && (t = e, e = "*");
          var n, r = 0,
              i = e.toLowerCase().match(P) || [];
          if (m(t))
              while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t)
      }
  }

  function Wt(t, i, o, a) {
      var s = {},
          u = t === Pt;

      function l(e) {
          var r;
          return s[e] = !0, S.each(t[e] || [], function(e, t) {
              var n = t(i, o, a);
              return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1)
          }), r
      }
      return l(i.dataTypes[0]) || !s["*"] && l("*")
  }

  function Ft(e, t) {
      var n, r, i = S.ajaxSettings.flatOptions || {};
      for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
      return r && S.extend(!0, e, r), e
  }
  Mt.href = bt.href, S.extend({
      active: 0,
      lastModified: {},
      etag: {},
      ajaxSettings: {
          url: bt.href,
          type: "GET",
          isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),
          global: !0,
          processData: !0,
          async: !0,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          accepts: {
              "*": Rt,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
          },
          contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
          },
          responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
          },
          converters: {
              "* text": String,
              "text html": !0,
              "text json": JSON.parse,
              "text xml": S.parseXML
          },
          flatOptions: {
              url: !0,
              context: !0
          }
      },
      ajaxSetup: function(e, t) {
          return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e)
      },
      ajaxPrefilter: It(Ot),
      ajaxTransport: It(Pt),
      ajax: function(e, t) {
          "object" == typeof e && (t = e, e = void 0), t = t || {};
          var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t),
              y = v.context || v,
              m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event,
              x = S.Deferred(),
              b = S.Callbacks("once memory"),
              w = v.statusCode || {},
              a = {},
              s = {},
              u = "canceled",
              T = {
                  readyState: 0,
                  getResponseHeader: function(e) {
                      var t;
                      if (h) {
                          if (!n) {
                              n = {};
                              while (t = qt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2])
                          }
                          t = n[e.toLowerCase() + " "]
                      }
                      return null == t ? null : t.join(", ")
                  },
                  getAllResponseHeaders: function() {
                      return h ? p : null
                  },
                  setRequestHeader: function(e, t) {
                      return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this
                  },
                  overrideMimeType: function(e) {
                      return null == h && (v.mimeType = e), this
                  },
                  statusCode: function(e) {
                      var t;
                      if (e)
                          if (h) T.always(e[T.status]);
                          else
                              for (t in e) w[t] = [w[t], e[t]];
                      return this
                  },
                  abort: function(e) {
                      var t = e || u;
                      return c && c.abort(t), l(0, t), this
                  }
              };
          if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) {
              r = E.createElement("a");
              try {
                  r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host
              } catch (e) {
                  v.crossDomain = !0
              }
          }
          if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T;
          for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]);
          if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort();
          if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) {
              if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T;
              v.async && 0 < v.timeout && (d = C.setTimeout(function() {
                  T.abort("timeout")
              }, v.timeout));
              try {
                  h = !1, c.send(a, l)
              } catch (e) {
                  if (h) throw e;
                  l(-1, e)
              }
          } else l(-1, "No Transport");

          function l(e, t, n, r) {
              var i, o, a, s, u, l = t;
              h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function(e, t, n) {
                  var r, i, o, a, s = e.contents,
                      u = e.dataTypes;
                  while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
                  if (r)
                      for (i in s)
                          if (s[i] && s[i].test(r)) {
                              u.unshift(i);
                              break
                          } if (u[0] in n) o = u[0];
                  else {
                      for (i in n) {
                          if (!u[0] || e.converters[i + " " + u[0]]) {
                              o = i;
                              break
                          }
                          a || (a = i)
                      }
                      o = o || a
                  }
                  if (o) return o !== u[0] && u.unshift(o), n[o]
              }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function() {}), s = function(e, t, n, r) {
                  var i, o, a, s, u, l = {},
                      c = e.dataTypes.slice();
                  if (c[1])
                      for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
                  o = c.shift();
                  while (o)
                      if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift())
                          if ("*" === o) o = u;
                          else if ("*" !== u && u !== o) {
                      if (!(a = l[u + " " + o] || l["* " + o]))
                          for (i in l)
                              if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
                                  !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
                                  break
                              } if (!0 !== a)
                          if (a && e["throws"]) t = a(t);
                          else try {
                              t = a(t)
                          } catch (e) {
                              return {
                                  state: "parsererror",
                                  error: a ? e : "No conversion from " + u + " to " + o
                              }
                          }
                  }
                  return {
                      state: "success",
                      data: t
                  }
              }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop")))
          }
          return T
      },
      getJSON: function(e, t, n) {
          return S.get(e, t, n, "json")
      },
      getScript: function(e, t) {
          return S.get(e, void 0, t, "script")
      }
  }), S.each(["get", "post"], function(e, i) {
      S[i] = function(e, t, n, r) {
          return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({
              url: e,
              type: i,
              dataType: r,
              data: t,
              success: n
          }, S.isPlainObject(e) && e))
      }
  }), S.ajaxPrefilter(function(e) {
      var t;
      for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "")
  }), S._evalUrl = function(e, t, n) {
      return S.ajax({
          url: e,
          type: "GET",
          dataType: "script",
          cache: !0,
          async: !1,
          global: !1,
          converters: {
              "text script": function() {}
          },
          dataFilter: function(e) {
              S.globalEval(e, t, n)
          }
      })
  }, S.fn.extend({
      wrapAll: function(e) {
          var t;
          return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
              var e = this;
              while (e.firstElementChild) e = e.firstElementChild;
              return e
          }).append(this)), this
      },
      wrapInner: function(n) {
          return m(n) ? this.each(function(e) {
              S(this).wrapInner(n.call(this, e))
          }) : this.each(function() {
              var e = S(this),
                  t = e.contents();
              t.length ? t.wrapAll(n) : e.append(n)
          })
      },
      wrap: function(t) {
          var n = m(t);
          return this.each(function(e) {
              S(this).wrapAll(n ? t.call(this, e) : t)
          })
      },
      unwrap: function(e) {
          return this.parent(e).not("body").each(function() {
              S(this).replaceWith(this.childNodes)
          }), this
      }
  }), S.expr.pseudos.hidden = function(e) {
      return !S.expr.pseudos.visible(e)
  }, S.expr.pseudos.visible = function(e) {
      return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
  }, S.ajaxSettings.xhr = function() {
      try {
          return new C.XMLHttpRequest
      } catch (e) {}
  };
  var Bt = {
          0: 200,
          1223: 204
      },
      $t = S.ajaxSettings.xhr();
  y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function(i) {
      var o, a;
      if (y.cors || $t && !i.crossDomain) return {
          send: function(e, t) {
              var n, r = i.xhr();
              if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields)
                  for (n in i.xhrFields) r[n] = i.xhrFields[n];
              for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]);
              o = function(e) {
                  return function() {
                      o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
                          binary: r.response
                      } : {
                          text: r.responseText
                      }, r.getAllResponseHeaders()))
                  }
              }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function() {
                  4 === r.readyState && C.setTimeout(function() {
                      o && a()
                  })
              }, o = o("abort");
              try {
                  r.send(i.hasContent && i.data || null)
              } catch (e) {
                  if (o) throw e
              }
          },
          abort: function() {
              o && o()
          }
      }
  }), S.ajaxPrefilter(function(e) {
      e.crossDomain && (e.contents.script = !1)
  }), S.ajaxSetup({
      accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
          script: /\b(?:java|ecma)script\b/
      },
      converters: {
          "text script": function(e) {
              return S.globalEval(e), e
          }
      }
  }), S.ajaxPrefilter("script", function(e) {
      void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
  }), S.ajaxTransport("script", function(n) {
      var r, i;
      if (n.crossDomain || n.scriptAttrs) return {
          send: function(e, t) {
              r = S("<script>").attr(n.scriptAttrs || {}).prop({
                  charset: n.scriptCharset,
                  src: n.url
              }).on("load error", i = function(e) {
                  r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type)
              }), E.head.appendChild(r[0])
          },
          abort: function() {
              i && i()
          }
      }
  });
  var _t, zt = [],
      Ut = /(=)\?(?=&|$)|\?\?/;
  S.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
          var e = zt.pop() || S.expando + "_" + wt.guid++;
          return this[e] = !0, e
      }
  }), S.ajaxPrefilter("json jsonp", function(e, t, n) {
      var r, i, o, a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data");
      if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() {
          return o || S.error(r + " was not called"), o[0]
      }, e.dataTypes[0] = "json", i = C[r], C[r] = function() {
          o = arguments
      }, n.always(function() {
          void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0
      }), "script"
  }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function(e, t, n) {
      return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes)));
      var r, i, o
  }, S.fn.load = function(e, t, n) {
      var r, i, o, a = this,
          s = e.indexOf(" ");
      return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({
          url: e,
          type: i || "GET",
          dataType: "html",
          data: t
      }).done(function(e) {
          o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e)
      }).always(n && function(e, t) {
          a.each(function() {
              n.apply(this, o || [e.responseText, t, e])
          })
      }), this
  }, S.expr.pseudos.animated = function(t) {
      return S.grep(S.timers, function(e) {
          return t === e.elem
      }).length
  }, S.offset = {
      setOffset: function(e, t, n) {
          var r, i, o, a, s, u, l = S.css(e, "position"),
              c = S(e),
              f = {};
          "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f)
      }
  }, S.fn.extend({
      offset: function(t) {
          if (arguments.length) return void 0 === t ? this : this.each(function(e) {
              S.offset.setOffset(this, t, e)
          });
          var e, n, r = this[0];
          return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
              top: e.top + n.pageYOffset,
              left: e.left + n.pageXOffset
          }) : {
              top: 0,
              left: 0
          } : void 0
      },
      position: function() {
          if (this[0]) {
              var e, t, n, r = this[0],
                  i = {
                      top: 0,
                      left: 0
                  };
              if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect();
              else {
                  t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;
                  while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode;
                  e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0))
              }
              return {
                  top: t.top - i.top - S.css(r, "marginTop", !0),
                  left: t.left - i.left - S.css(r, "marginLeft", !0)
              }
          }
      },
      offsetParent: function() {
          return this.map(function() {
              var e = this.offsetParent;
              while (e && "static" === S.css(e, "position")) e = e.offsetParent;
              return e || re
          })
      }
  }), S.each({
      scrollLeft: "pageXOffset",
      scrollTop: "pageYOffset"
  }, function(t, i) {
      var o = "pageYOffset" === i;
      S.fn[t] = function(e) {
          return $(this, function(e, t, n) {
              var r;
              if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
              r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n
          }, t, e, arguments.length)
      }
  }), S.each(["top", "left"], function(e, n) {
      S.cssHooks[n] = Fe(y.pixelPosition, function(e, t) {
          if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t
      })
  }), S.each({
      Height: "height",
      Width: "width"
  }, function(a, s) {
      S.each({
          padding: "inner" + a,
          content: s,
          "": "outer" + a
      }, function(r, o) {
          S.fn[o] = function(e, t) {
              var n = arguments.length && (r || "boolean" != typeof e),
                  i = r || (!0 === e || !0 === t ? "margin" : "border");
              return $(this, function(e, t, n) {
                  var r;
                  return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i)
              }, s, n ? e : void 0, n)
          }
      })
  }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
      S.fn[t] = function(e) {
          return this.on(t, e)
      }
  }), S.fn.extend({
      bind: function(e, t, n) {
          return this.on(e, null, t, n)
      },
      unbind: function(e, t) {
          return this.off(e, null, t)
      },
      delegate: function(e, t, n, r) {
          return this.on(t, e, n, r)
      },
      undelegate: function(e, t, n) {
          return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
      },
      hover: function(e, t) {
          return this.mouseenter(e).mouseleave(t || e)
      }
  }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, n) {
      S.fn[n] = function(e, t) {
          return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n)
      }
  });
  var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  S.proxy = function(e, t) {
      var n, r, i;
      if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function() {
          return e.apply(t || this, r.concat(s.call(arguments)))
      }).guid = e.guid = e.guid || S.guid++, i
  }, S.holdReady = function(e) {
      e ? S.readyWait++ : S.ready(!0)
  }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function(e) {
      var t = S.type(e);
      return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
  }, S.trim = function(e) {
      return null == e ? "" : (e + "").replace(Xt, "")
  }, "function" == typeof define && define.amd && define("jquery", [], function() {
      return S
  });
  var Vt = C.jQuery,
      Gt = C.$;
  return S.noConflict = function(e) {
      return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S
  }, "undefined" == typeof e && (C.jQuery = C.$ = S), S
});

/*!
* Bootstrap v5.0.2 (https://getbootstrap.com/)
* Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
*/
! function(t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e()
}(this, (function() {
  "use strict";
  const t = {
          find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
          findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
          children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),
          parents(t, e) {
              const i = [];
              let n = t.parentNode;
              for (; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;) n.matches(e) && i.push(n), n = n.parentNode;
              return i
          },
          prev(t, e) {
              let i = t.previousElementSibling;
              for (; i;) {
                  if (i.matches(e)) return [i];
                  i = i.previousElementSibling
              }
              return []
          },
          next(t, e) {
              let i = t.nextElementSibling;
              for (; i;) {
                  if (i.matches(e)) return [i];
                  i = i.nextElementSibling
              }
              return []
          }
      },
      e = t => {
          do {
              t += Math.floor(1e6 * Math.random())
          } while (document.getElementById(t));
          return t
      },
      i = t => {
          let e = t.getAttribute("data-bs-target");
          if (!e || "#" === e) {
              let i = t.getAttribute("href");
              if (!i || !i.includes("#") && !i.startsWith(".")) return null;
              i.includes("#") && !i.startsWith("#") && (i = "#" + i.split("#")[1]), e = i && "#" !== i ? i.trim() : null
          }
          return e
      },
      n = t => {
          const e = i(t);
          return e && document.querySelector(e) ? e : null
      },
      s = t => {
          const e = i(t);
          return e ? document.querySelector(e) : null
      },
      o = t => {
          t.dispatchEvent(new Event("transitionend"))
      },
      r = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
      a = e => r(e) ? e.jquery ? e[0] : e : "string" == typeof e && e.length > 0 ? t.findOne(e) : null,
      l = (t, e, i) => {
          Object.keys(i).forEach(n => {
              const s = i[n],
                  o = e[n],
                  a = o && r(o) ? "element" : null == (l = o) ? "" + l : {}.toString.call(l).match(/\s([a-z]+)/i)[1].toLowerCase();
              var l;
              if (!new RegExp(s).test(a)) throw new TypeError(`${t.toUpperCase()}: Option "${n}" provided type "${a}" but expected type "${s}".`)
          })
      },
      c = t => !(!r(t) || 0 === t.getClientRects().length) && "visible" === getComputedStyle(t).getPropertyValue("visibility"),
      h = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
      d = t => {
          if (!document.documentElement.attachShadow) return null;
          if ("function" == typeof t.getRootNode) {
              const e = t.getRootNode();
              return e instanceof ShadowRoot ? e : null
          }
          return t instanceof ShadowRoot ? t : t.parentNode ? d(t.parentNode) : null
      },
      u = () => {},
      f = t => t.offsetHeight,
      p = () => {
          const {
              jQuery: t
          } = window;
          return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null
      },
      m = [],
      g = () => "rtl" === document.documentElement.dir,
      _ = t => {
          var e;
          e = () => {
              const e = p();
              if (e) {
                  const i = t.NAME,
                      n = e.fn[i];
                  e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface)
              }
          }, "loading" === document.readyState ? (m.length || document.addEventListener("DOMContentLoaded", () => {
              m.forEach(t => t())
          }), m.push(e)) : e()
      },
      b = t => {
          "function" == typeof t && t()
      },
      v = (t, e, i = !0) => {
          if (!i) return void b(t);
          const n = (t => {
              if (!t) return 0;
              let {
                  transitionDuration: e,
                  transitionDelay: i
              } = window.getComputedStyle(t);
              const n = Number.parseFloat(e),
                  s = Number.parseFloat(i);
              return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
          })(e) + 5;
          let s = !1;
          const r = ({
              target: i
          }) => {
              i === e && (s = !0, e.removeEventListener("transitionend", r), b(t))
          };
          e.addEventListener("transitionend", r), setTimeout(() => {
              s || o(e)
          }, n)
      },
      y = (t, e, i, n) => {
          let s = t.indexOf(e);
          if (-1 === s) return t[!i && n ? t.length - 1 : 0];
          const o = t.length;
          return s += i ? 1 : -1, n && (s = (s + o) % o), t[Math.max(0, Math.min(s, o - 1))]
      },
      w = /[^.]*(?=\..*)\.|.*/,
      E = /\..*/,
      A = /::\d+$/,
      T = {};
  let O = 1;
  const C = {
          mouseenter: "mouseover",
          mouseleave: "mouseout"
      },
      k = /^(mouseenter|mouseleave)/i,
      L = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

  function x(t, e) {
      return e && `${e}::${O++}` || t.uidEvent || O++
  }

  function D(t) {
      const e = x(t);
      return t.uidEvent = e, T[e] = T[e] || {}, T[e]
  }

  function S(t, e, i = null) {
      const n = Object.keys(t);
      for (let s = 0, o = n.length; s < o; s++) {
          const o = t[n[s]];
          if (o.originalHandler === e && o.delegationSelector === i) return o
      }
      return null
  }

  function I(t, e, i) {
      const n = "string" == typeof e,
          s = n ? i : e;
      let o = M(t);
      return L.has(o) || (o = t), [n, s, o]
  }

  function N(t, e, i, n, s) {
      if ("string" != typeof e || !t) return;
      if (i || (i = n, n = null), k.test(e)) {
          const t = t => function(e) {
              if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e)
          };
          n ? n = t(n) : i = t(i)
      }
      const [o, r, a] = I(e, i, n), l = D(t), c = l[a] || (l[a] = {}), h = S(c, r, o ? i : null);
      if (h) return void(h.oneOff = h.oneOff && s);
      const d = x(r, e.replace(w, "")),
          u = o ? function(t, e, i) {
              return function n(s) {
                  const o = t.querySelectorAll(e);
                  for (let {
                          target: r
                      } = s; r && r !== this; r = r.parentNode)
                      for (let a = o.length; a--;)
                          if (o[a] === r) return s.delegateTarget = r, n.oneOff && P.off(t, s.type, e, i), i.apply(r, [s]);
                  return null
              }
          }(t, i, n) : function(t, e) {
              return function i(n) {
                  return n.delegateTarget = t, i.oneOff && P.off(t, n.type, e), e.apply(t, [n])
              }
          }(t, i);
      u.delegationSelector = o ? i : null, u.originalHandler = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o)
  }

  function j(t, e, i, n, s) {
      const o = S(e[i], n, s);
      o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent])
  }

  function M(t) {
      return t = t.replace(E, ""), C[t] || t
  }
  const P = {
          on(t, e, i, n) {
              N(t, e, i, n, !1)
          },
          one(t, e, i, n) {
              N(t, e, i, n, !0)
          },
          off(t, e, i, n) {
              if ("string" != typeof e || !t) return;
              const [s, o, r] = I(e, i, n), a = r !== e, l = D(t), c = e.startsWith(".");
              if (void 0 !== o) {
                  if (!l || !l[r]) return;
                  return void j(t, l, r, o, s ? i : null)
              }
              c && Object.keys(l).forEach(i => {
                  ! function(t, e, i, n) {
                      const s = e[i] || {};
                      Object.keys(s).forEach(o => {
                          if (o.includes(n)) {
                              const n = s[o];
                              j(t, e, i, n.originalHandler, n.delegationSelector)
                          }
                      })
                  }(t, l, i, e.slice(1))
              });
              const h = l[r] || {};
              Object.keys(h).forEach(i => {
                  const n = i.replace(A, "");
                  if (!a || e.includes(n)) {
                      const e = h[i];
                      j(t, l, r, e.originalHandler, e.delegationSelector)
                  }
              })
          },
          trigger(t, e, i) {
              if ("string" != typeof e || !t) return null;
              const n = p(),
                  s = M(e),
                  o = e !== s,
                  r = L.has(s);
              let a, l = !0,
                  c = !0,
                  h = !1,
                  d = null;
              return o && n && (a = n.Event(e, i), n(t).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), h = a.isDefaultPrevented()), r ? (d = document.createEvent("HTMLEvents"), d.initEvent(s, l, !0)) : d = new CustomEvent(e, {
                  bubbles: l,
                  cancelable: !0
              }), void 0 !== i && Object.keys(i).forEach(t => {
                  Object.defineProperty(d, t, {
                      get: () => i[t]
                  })
              }), h && d.preventDefault(), c && t.dispatchEvent(d), d.defaultPrevented && void 0 !== a && a.preventDefault(), d
          }
      },
      H = new Map;
  var R = {
      set(t, e, i) {
          H.has(t) || H.set(t, new Map);
          const n = H.get(t);
          n.has(e) || 0 === n.size ? n.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`)
      },
      get: (t, e) => H.has(t) && H.get(t).get(e) || null,
      remove(t, e) {
          if (!H.has(t)) return;
          const i = H.get(t);
          i.delete(e), 0 === i.size && H.delete(t)
      }
  };
  class B {
      constructor(t) {
          (t = a(t)) && (this._element = t, R.set(this._element, this.constructor.DATA_KEY, this))
      }
      dispose() {
          R.remove(this._element, this.constructor.DATA_KEY), P.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(t => {
              this[t] = null
          })
      }
      _queueCallback(t, e, i = !0) {
          v(t, e, i)
      }
      static getInstance(t) {
          return R.get(t, this.DATA_KEY)
      }
      static getOrCreateInstance(t, e = {}) {
          return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
      }
      static get VERSION() {
          return "5.0.2"
      }
      static get NAME() {
          throw new Error('You have to implement the static method "NAME", for each component!')
      }
      static get DATA_KEY() {
          return "bs." + this.NAME
      }
      static get EVENT_KEY() {
          return "." + this.DATA_KEY
      }
  }
  class W extends B {
      static get NAME() {
          return "alert"
      }
      close(t) {
          const e = t ? this._getRootElement(t) : this._element,
              i = this._triggerCloseEvent(e);
          null === i || i.defaultPrevented || this._removeElement(e)
      }
      _getRootElement(t) {
          return s(t) || t.closest(".alert")
      }
      _triggerCloseEvent(t) {
          return P.trigger(t, "close.bs.alert")
      }
      _removeElement(t) {
          t.classList.remove("show");
          const e = t.classList.contains("fade");
          this._queueCallback(() => this._destroyElement(t), t, e)
      }
      _destroyElement(t) {
          t.remove(), P.trigger(t, "closed.bs.alert")
      }
      static jQueryInterface(t) {
          return this.each((function() {
              const e = W.getOrCreateInstance(this);
              "close" === t && e[t](this)
          }))
      }
      static handleDismiss(t) {
          return function(e) {
              e && e.preventDefault(), t.close(this)
          }
      }
  }
  P.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', W.handleDismiss(new W)), _(W);
  class q extends B {
      static get NAME() {
          return "button"
      }
      toggle() {
          this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
      }
      static jQueryInterface(t) {
          return this.each((function() {
              const e = q.getOrCreateInstance(this);
              "toggle" === t && e[t]()
          }))
      }
  }

  function z(t) {
      return "true" === t || "false" !== t && (t === Number(t).toString() ? Number(t) : "" === t || "null" === t ? null : t)
  }

  function $(t) {
      return t.replace(/[A-Z]/g, t => "-" + t.toLowerCase())
  }
  P.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', t => {
      t.preventDefault();
      const e = t.target.closest('[data-bs-toggle="button"]');
      q.getOrCreateInstance(e).toggle()
  }), _(q);
  const U = {
          setDataAttribute(t, e, i) {
              t.setAttribute("data-bs-" + $(e), i)
          },
          removeDataAttribute(t, e) {
              t.removeAttribute("data-bs-" + $(e))
          },
          getDataAttributes(t) {
              if (!t) return {};
              const e = {};
              return Object.keys(t.dataset).filter(t => t.startsWith("bs")).forEach(i => {
                  let n = i.replace(/^bs/, "");
                  n = n.charAt(0).toLowerCase() + n.slice(1, n.length), e[n] = z(t.dataset[i])
              }), e
          },
          getDataAttribute: (t, e) => z(t.getAttribute("data-bs-" + $(e))),
          offset(t) {
              const e = t.getBoundingClientRect();
              return {
                  top: e.top + document.body.scrollTop,
                  left: e.left + document.body.scrollLeft
              }
          },
          position: t => ({
              top: t.offsetTop,
              left: t.offsetLeft
          })
      },
      F = {
          interval: 5e3,
          keyboard: !0,
          slide: !1,
          pause: "hover",
          wrap: !0,
          touch: !0
      },
      V = {
          interval: "(number|boolean)",
          keyboard: "boolean",
          slide: "(boolean|string)",
          pause: "(string|boolean)",
          wrap: "boolean",
          touch: "boolean"
      },
      K = "next",
      X = "prev",
      Y = "left",
      Q = "right",
      G = {
          ArrowLeft: Q,
          ArrowRight: Y
      };
  class Z extends B {
      constructor(e, i) {
          super(e), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(i), this._indicatorsElement = t.findOne(".carousel-indicators", this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners()
      }
      static get Default() {
          return F
      }
      static get NAME() {
          return "carousel"
      }
      next() {
          this._slide(K)
      }
      nextWhenVisible() {
          !document.hidden && c(this._element) && this.next()
      }
      prev() {
          this._slide(X)
      }
      pause(e) {
          e || (this._isPaused = !0), t.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (o(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
      }
      cycle(t) {
          t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
      }
      to(e) {
          this._activeElement = t.findOne(".active.carousel-item", this._element);
          const i = this._getItemIndex(this._activeElement);
          if (e > this._items.length - 1 || e < 0) return;
          if (this._isSliding) return void P.one(this._element, "slid.bs.carousel", () => this.to(e));
          if (i === e) return this.pause(), void this.cycle();
          const n = e > i ? K : X;
          this._slide(n, this._items[e])
      }
      _getConfig(t) {
          return t = {
              ...F,
              ...U.getDataAttributes(this._element),
              ..."object" == typeof t ? t : {}
          }, l("carousel", t, V), t
      }
      _handleSwipe() {
          const t = Math.abs(this.touchDeltaX);
          if (t <= 40) return;
          const e = t / this.touchDeltaX;
          this.touchDeltaX = 0, e && this._slide(e > 0 ? Q : Y)
      }
      _addEventListeners() {
          this._config.keyboard && P.on(this._element, "keydown.bs.carousel", t => this._keydown(t)), "hover" === this._config.pause && (P.on(this._element, "mouseenter.bs.carousel", t => this.pause(t)), P.on(this._element, "mouseleave.bs.carousel", t => this.cycle(t))), this._config.touch && this._touchSupported && this._addTouchEventListeners()
      }
      _addTouchEventListeners() {
          const e = t => {
                  !this._pointerEvent || "pen" !== t.pointerType && "touch" !== t.pointerType ? this._pointerEvent || (this.touchStartX = t.touches[0].clientX) : this.touchStartX = t.clientX
              },
              i = t => {
                  this.touchDeltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this.touchStartX
              },
              n = t => {
                  !this._pointerEvent || "pen" !== t.pointerType && "touch" !== t.pointerType || (this.touchDeltaX = t.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(t => this.cycle(t), 500 + this._config.interval))
              };
          t.find(".carousel-item img", this._element).forEach(t => {
              P.on(t, "dragstart.bs.carousel", t => t.preventDefault())
          }), this._pointerEvent ? (P.on(this._element, "pointerdown.bs.carousel", t => e(t)), P.on(this._element, "pointerup.bs.carousel", t => n(t)), this._element.classList.add("pointer-event")) : (P.on(this._element, "touchstart.bs.carousel", t => e(t)), P.on(this._element, "touchmove.bs.carousel", t => i(t)), P.on(this._element, "touchend.bs.carousel", t => n(t)))
      }
      _keydown(t) {
          if (/input|textarea/i.test(t.target.tagName)) return;
          const e = G[t.key];
          e && (t.preventDefault(), this._slide(e))
      }
      _getItemIndex(e) {
          return this._items = e && e.parentNode ? t.find(".carousel-item", e.parentNode) : [], this._items.indexOf(e)
      }
      _getItemByOrder(t, e) {
          const i = t === K;
          return y(this._items, e, i, this._config.wrap)
      }
      _triggerSlideEvent(e, i) {
          const n = this._getItemIndex(e),
              s = this._getItemIndex(t.findOne(".active.carousel-item", this._element));
          return P.trigger(this._element, "slide.bs.carousel", {
              relatedTarget: e,
              direction: i,
              from: s,
              to: n
          })
      }
      _setActiveIndicatorElement(e) {
          if (this._indicatorsElement) {
              const i = t.findOne(".active", this._indicatorsElement);
              i.classList.remove("active"), i.removeAttribute("aria-current");
              const n = t.find("[data-bs-target]", this._indicatorsElement);
              for (let t = 0; t < n.length; t++)
                  if (Number.parseInt(n[t].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(e)) {
                      n[t].classList.add("active"), n[t].setAttribute("aria-current", "true");
                      break
                  }
          }
      }
      _updateInterval() {
          const e = this._activeElement || t.findOne(".active.carousel-item", this._element);
          if (!e) return;
          const i = Number.parseInt(e.getAttribute("data-bs-interval"), 10);
          i ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = i) : this._config.interval = this._config.defaultInterval || this._config.interval
      }
      _slide(e, i) {
          const n = this._directionToOrder(e),
              s = t.findOne(".active.carousel-item", this._element),
              o = this._getItemIndex(s),
              r = i || this._getItemByOrder(n, s),
              a = this._getItemIndex(r),
              l = Boolean(this._interval),
              c = n === K,
              h = c ? "carousel-item-start" : "carousel-item-end",
              d = c ? "carousel-item-next" : "carousel-item-prev",
              u = this._orderToDirection(n);
          if (r && r.classList.contains("active")) return void(this._isSliding = !1);
          if (this._isSliding) return;
          if (this._triggerSlideEvent(r, u).defaultPrevented) return;
          if (!s || !r) return;
          this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;
          const p = () => {
              P.trigger(this._element, "slid.bs.carousel", {
                  relatedTarget: r,
                  direction: u,
                  from: o,
                  to: a
              })
          };
          if (this._element.classList.contains("slide")) {
              r.classList.add(d), f(r), s.classList.add(h), r.classList.add(h);
              const t = () => {
                  r.classList.remove(h, d), r.classList.add("active"), s.classList.remove("active", d, h), this._isSliding = !1, setTimeout(p, 0)
              };
              this._queueCallback(t, s, !0)
          } else s.classList.remove("active"), r.classList.add("active"), this._isSliding = !1, p();
          l && this.cycle()
      }
      _directionToOrder(t) {
          return [Q, Y].includes(t) ? g() ? t === Y ? X : K : t === Y ? K : X : t
      }
      _orderToDirection(t) {
          return [K, X].includes(t) ? g() ? t === X ? Y : Q : t === X ? Q : Y : t
      }
      static carouselInterface(t, e) {
          const i = Z.getOrCreateInstance(t, e);
          let {
              _config: n
          } = i;
          "object" == typeof e && (n = {
              ...n,
              ...e
          });
          const s = "string" == typeof e ? e : n.slide;
          if ("number" == typeof e) i.to(e);
          else if ("string" == typeof s) {
              if (void 0 === i[s]) throw new TypeError(`No method named "${s}"`);
              i[s]()
          } else n.interval && n.ride && (i.pause(), i.cycle())
      }
      static jQueryInterface(t) {
          return this.each((function() {
              Z.carouselInterface(this, t)
          }))
      }
      static dataApiClickHandler(t) {
          const e = s(this);
          if (!e || !e.classList.contains("carousel")) return;
          const i = {
                  ...U.getDataAttributes(e),
                  ...U.getDataAttributes(this)
              },
              n = this.getAttribute("data-bs-slide-to");
          n && (i.interval = !1), Z.carouselInterface(e, i), n && Z.getInstance(e).to(n), t.preventDefault()
      }
  }
  P.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Z.dataApiClickHandler), P.on(window, "load.bs.carousel.data-api", () => {
      const e = t.find('[data-bs-ride="carousel"]');
      for (let t = 0, i = e.length; t < i; t++) Z.carouselInterface(e[t], Z.getInstance(e[t]))
  }), _(Z);
  const J = {
          toggle: !0,
          parent: ""
      },
      tt = {
          toggle: "boolean",
          parent: "(string|element)"
      };
  class et extends B {
      constructor(e, i) {
          super(e), this._isTransitioning = !1, this._config = this._getConfig(i), this._triggerArray = t.find(`[data-bs-toggle="collapse"][href="#${this._element.id}"],[data-bs-toggle="collapse"][data-bs-target="#${this._element.id}"]`);
          const s = t.find('[data-bs-toggle="collapse"]');
          for (let e = 0, i = s.length; e < i; e++) {
              const i = s[e],
                  o = n(i),
                  r = t.find(o).filter(t => t === this._element);
              null !== o && r.length && (this._selector = o, this._triggerArray.push(i))
          }
          this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle()
      }
      static get Default() {
          return J
      }
      static get NAME() {
          return "collapse"
      }
      toggle() {
          this._element.classList.contains("show") ? this.hide() : this.show()
      }
      show() {
          if (this._isTransitioning || this._element.classList.contains("show")) return;
          let e, i;
          this._parent && (e = t.find(".show, .collapsing", this._parent).filter(t => "string" == typeof this._config.parent ? t.getAttribute("data-bs-parent") === this._config.parent : t.classList.contains("collapse")), 0 === e.length && (e = null));
          const n = t.findOne(this._selector);
          if (e) {
              const t = e.find(t => n !== t);
              if (i = t ? et.getInstance(t) : null, i && i._isTransitioning) return
          }
          if (P.trigger(this._element, "show.bs.collapse").defaultPrevented) return;
          e && e.forEach(t => {
              n !== t && et.collapseInterface(t, "hide"), i || R.set(t, "bs.collapse", null)
          });
          const s = this._getDimension();
          this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[s] = 0, this._triggerArray.length && this._triggerArray.forEach(t => {
              t.classList.remove("collapsed"), t.setAttribute("aria-expanded", !0)
          }), this.setTransitioning(!0);
          const o = "scroll" + (s[0].toUpperCase() + s.slice(1));
          this._queueCallback(() => {
              this._element.classList.remove("collapsing"), this._element.classList.add("collapse", "show"), this._element.style[s] = "", this.setTransitioning(!1), P.trigger(this._element, "shown.bs.collapse")
          }, this._element, !0), this._element.style[s] = this._element[o] + "px"
      }
      hide() {
          if (this._isTransitioning || !this._element.classList.contains("show")) return;
          if (P.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;
          const t = this._getDimension();
          this._element.style[t] = this._element.getBoundingClientRect()[t] + "px", f(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
          const e = this._triggerArray.length;
          if (e > 0)
              for (let t = 0; t < e; t++) {
                  const e = this._triggerArray[t],
                      i = s(e);
                  i && !i.classList.contains("show") && (e.classList.add("collapsed"), e.setAttribute("aria-expanded", !1))
              }
          this.setTransitioning(!0), this._element.style[t] = "", this._queueCallback(() => {
              this.setTransitioning(!1), this._element.classList.remove("collapsing"), this._element.classList.add("collapse"), P.trigger(this._element, "hidden.bs.collapse")
          }, this._element, !0)
      }
      setTransitioning(t) {
          this._isTransitioning = t
      }
      _getConfig(t) {
          return (t = {
              ...J,
              ...t
          }).toggle = Boolean(t.toggle), l("collapse", t, tt), t
      }
      _getDimension() {
          return this._element.classList.contains("width") ? "width" : "height"
      }
      _getParent() {
          let {
              parent: e
          } = this._config;
          e = a(e);
          const i = `[data-bs-toggle="collapse"][data-bs-parent="${e}"]`;
          return t.find(i, e).forEach(t => {
              const e = s(t);
              this._addAriaAndCollapsedClass(e, [t])
          }), e
      }
      _addAriaAndCollapsedClass(t, e) {
          if (!t || !e.length) return;
          const i = t.classList.contains("show");
          e.forEach(t => {
              i ? t.classList.remove("collapsed") : t.classList.add("collapsed"), t.setAttribute("aria-expanded", i)
          })
      }
      static collapseInterface(t, e) {
          let i = et.getInstance(t);
          const n = {
              ...J,
              ...U.getDataAttributes(t),
              ..."object" == typeof e && e ? e : {}
          };
          if (!i && n.toggle && "string" == typeof e && /show|hide/.test(e) && (n.toggle = !1), i || (i = new et(t, n)), "string" == typeof e) {
              if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`);
              i[e]()
          }
      }
      static jQueryInterface(t) {
          return this.each((function() {
              et.collapseInterface(this, t)
          }))
      }
  }
  P.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', (function(e) {
      ("A" === e.target.tagName || e.delegateTarget && "A" === e.delegateTarget.tagName) && e.preventDefault();
      const i = U.getDataAttributes(this),
          s = n(this);
      t.find(s).forEach(t => {
          const e = et.getInstance(t);
          let n;
          e ? (null === e._parent && "string" == typeof i.parent && (e._config.parent = i.parent, e._parent = e._getParent()), n = "toggle") : n = i, et.collapseInterface(t, n)
      })
  })), _(et);
  var it = "top",
      nt = "bottom",
      st = "right",
      ot = "left",
      rt = [it, nt, st, ot],
      at = rt.reduce((function(t, e) {
          return t.concat([e + "-start", e + "-end"])
      }), []),
      lt = [].concat(rt, ["auto"]).reduce((function(t, e) {
          return t.concat([e, e + "-start", e + "-end"])
      }), []),
      ct = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

  function ht(t) {
      return t ? (t.nodeName || "").toLowerCase() : null
  }

  function dt(t) {
      if (null == t) return window;
      if ("[object Window]" !== t.toString()) {
          var e = t.ownerDocument;
          return e && e.defaultView || window
      }
      return t
  }

  function ut(t) {
      return t instanceof dt(t).Element || t instanceof Element
  }

  function ft(t) {
      return t instanceof dt(t).HTMLElement || t instanceof HTMLElement
  }

  function pt(t) {
      return "undefined" != typeof ShadowRoot && (t instanceof dt(t).ShadowRoot || t instanceof ShadowRoot)
  }
  var mt = {
      name: "applyStyles",
      enabled: !0,
      phase: "write",
      fn: function(t) {
          var e = t.state;
          Object.keys(e.elements).forEach((function(t) {
              var i = e.styles[t] || {},
                  n = e.attributes[t] || {},
                  s = e.elements[t];
              ft(s) && ht(s) && (Object.assign(s.style, i), Object.keys(n).forEach((function(t) {
                  var e = n[t];
                  !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e)
              })))
          }))
      },
      effect: function(t) {
          var e = t.state,
              i = {
                  popper: {
                      position: e.options.strategy,
                      left: "0",
                      top: "0",
                      margin: "0"
                  },
                  arrow: {
                      position: "absolute"
                  },
                  reference: {}
              };
          return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow),
              function() {
                  Object.keys(e.elements).forEach((function(t) {
                      var n = e.elements[t],
                          s = e.attributes[t] || {},
                          o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce((function(t, e) {
                              return t[e] = "", t
                          }), {});
                      ft(n) && ht(n) && (Object.assign(n.style, o), Object.keys(s).forEach((function(t) {
                          n.removeAttribute(t)
                      })))
                  }))
              }
      },
      requires: ["computeStyles"]
  };

  function gt(t) {
      return t.split("-")[0]
  }

  function _t(t) {
      var e = t.getBoundingClientRect();
      return {
          width: e.width,
          height: e.height,
          top: e.top,
          right: e.right,
          bottom: e.bottom,
          left: e.left,
          x: e.left,
          y: e.top
      }
  }

  function bt(t) {
      var e = _t(t),
          i = t.offsetWidth,
          n = t.offsetHeight;
      return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
          x: t.offsetLeft,
          y: t.offsetTop,
          width: i,
          height: n
      }
  }

  function vt(t, e) {
      var i = e.getRootNode && e.getRootNode();
      if (t.contains(e)) return !0;
      if (i && pt(i)) {
          var n = e;
          do {
              if (n && t.isSameNode(n)) return !0;
              n = n.parentNode || n.host
          } while (n)
      }
      return !1
  }

  function yt(t) {
      return dt(t).getComputedStyle(t)
  }

  function wt(t) {
      return ["table", "td", "th"].indexOf(ht(t)) >= 0
  }

  function Et(t) {
      return ((ut(t) ? t.ownerDocument : t.document) || window.document).documentElement
  }

  function At(t) {
      return "html" === ht(t) ? t : t.assignedSlot || t.parentNode || (pt(t) ? t.host : null) || Et(t)
  }

  function Tt(t) {
      return ft(t) && "fixed" !== yt(t).position ? t.offsetParent : null
  }

  function Ot(t) {
      for (var e = dt(t), i = Tt(t); i && wt(i) && "static" === yt(i).position;) i = Tt(i);
      return i && ("html" === ht(i) || "body" === ht(i) && "static" === yt(i).position) ? e : i || function(t) {
          var e = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
          if (-1 !== navigator.userAgent.indexOf("Trident") && ft(t) && "fixed" === yt(t).position) return null;
          for (var i = At(t); ft(i) && ["html", "body"].indexOf(ht(i)) < 0;) {
              var n = yt(i);
              if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;
              i = i.parentNode
          }
          return null
      }(t) || e
  }

  function Ct(t) {
      return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
  }
  var kt = Math.max,
      Lt = Math.min,
      xt = Math.round;

  function Dt(t, e, i) {
      return kt(t, Lt(e, i))
  }

  function St(t) {
      return Object.assign({}, {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
      }, t)
  }

  function It(t, e) {
      return e.reduce((function(e, i) {
          return e[i] = t, e
      }), {})
  }
  var Nt = {
          name: "arrow",
          enabled: !0,
          phase: "main",
          fn: function(t) {
              var e, i = t.state,
                  n = t.name,
                  s = t.options,
                  o = i.elements.arrow,
                  r = i.modifiersData.popperOffsets,
                  a = gt(i.placement),
                  l = Ct(a),
                  c = [ot, st].indexOf(a) >= 0 ? "height" : "width";
              if (o && r) {
                  var h = function(t, e) {
                          return St("number" != typeof(t = "function" == typeof t ? t(Object.assign({}, e.rects, {
                              placement: e.placement
                          })) : t) ? t : It(t, rt))
                      }(s.padding, i),
                      d = bt(o),
                      u = "y" === l ? it : ot,
                      f = "y" === l ? nt : st,
                      p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c],
                      m = r[l] - i.rects.reference[l],
                      g = Ot(o),
                      _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0,
                      b = p / 2 - m / 2,
                      v = h[u],
                      y = _ - d[c] - h[f],
                      w = _ / 2 - d[c] / 2 + b,
                      E = Dt(v, w, y),
                      A = l;
                  i.modifiersData[n] = ((e = {})[A] = E, e.centerOffset = E - w, e)
              }
          },
          effect: function(t) {
              var e = t.state,
                  i = t.options.element,
                  n = void 0 === i ? "[data-popper-arrow]" : i;
              null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && vt(e.elements.popper, n) && (e.elements.arrow = n)
          },
          requires: ["popperOffsets"],
          requiresIfExists: ["preventOverflow"]
      },
      jt = {
          top: "auto",
          right: "auto",
          bottom: "auto",
          left: "auto"
      };

  function Mt(t) {
      var e, i = t.popper,
          n = t.popperRect,
          s = t.placement,
          o = t.offsets,
          r = t.position,
          a = t.gpuAcceleration,
          l = t.adaptive,
          c = t.roundOffsets,
          h = !0 === c ? function(t) {
              var e = t.x,
                  i = t.y,
                  n = window.devicePixelRatio || 1;
              return {
                  x: xt(xt(e * n) / n) || 0,
                  y: xt(xt(i * n) / n) || 0
              }
          }(o) : "function" == typeof c ? c(o) : o,
          d = h.x,
          u = void 0 === d ? 0 : d,
          f = h.y,
          p = void 0 === f ? 0 : f,
          m = o.hasOwnProperty("x"),
          g = o.hasOwnProperty("y"),
          _ = ot,
          b = it,
          v = window;
      if (l) {
          var y = Ot(i),
              w = "clientHeight",
              E = "clientWidth";
          y === dt(i) && "static" !== yt(y = Et(i)).position && (w = "scrollHeight", E = "scrollWidth"), y = y, s === it && (b = nt, p -= y[w] - n.height, p *= a ? 1 : -1), s === ot && (_ = st, u -= y[E] - n.width, u *= a ? 1 : -1)
      }
      var A, T = Object.assign({
          position: r
      }, l && jt);
      return a ? Object.assign({}, T, ((A = {})[b] = g ? "0" : "", A[_] = m ? "0" : "", A.transform = (v.devicePixelRatio || 1) < 2 ? "translate(" + u + "px, " + p + "px)" : "translate3d(" + u + "px, " + p + "px, 0)", A)) : Object.assign({}, T, ((e = {})[b] = g ? p + "px" : "", e[_] = m ? u + "px" : "", e.transform = "", e))
  }
  var Pt = {
          name: "computeStyles",
          enabled: !0,
          phase: "beforeWrite",
          fn: function(t) {
              var e = t.state,
                  i = t.options,
                  n = i.gpuAcceleration,
                  s = void 0 === n || n,
                  o = i.adaptive,
                  r = void 0 === o || o,
                  a = i.roundOffsets,
                  l = void 0 === a || a,
                  c = {
                      placement: gt(e.placement),
                      popper: e.elements.popper,
                      popperRect: e.rects.popper,
                      gpuAcceleration: s
                  };
              null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, Mt(Object.assign({}, c, {
                  offsets: e.modifiersData.popperOffsets,
                  position: e.options.strategy,
                  adaptive: r,
                  roundOffsets: l
              })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, Mt(Object.assign({}, c, {
                  offsets: e.modifiersData.arrow,
                  position: "absolute",
                  adaptive: !1,
                  roundOffsets: l
              })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
                  "data-popper-placement": e.placement
              })
          },
          data: {}
      },
      Ht = {
          passive: !0
      },
      Rt = {
          name: "eventListeners",
          enabled: !0,
          phase: "write",
          fn: function() {},
          effect: function(t) {
              var e = t.state,
                  i = t.instance,
                  n = t.options,
                  s = n.scroll,
                  o = void 0 === s || s,
                  r = n.resize,
                  a = void 0 === r || r,
                  l = dt(e.elements.popper),
                  c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
              return o && c.forEach((function(t) {
                      t.addEventListener("scroll", i.update, Ht)
                  })), a && l.addEventListener("resize", i.update, Ht),
                  function() {
                      o && c.forEach((function(t) {
                          t.removeEventListener("scroll", i.update, Ht)
                      })), a && l.removeEventListener("resize", i.update, Ht)
                  }
          },
          data: {}
      },
      Bt = {
          left: "right",
          right: "left",
          bottom: "top",
          top: "bottom"
      };

  function Wt(t) {
      return t.replace(/left|right|bottom|top/g, (function(t) {
          return Bt[t]
      }))
  }
  var qt = {
      start: "end",
      end: "start"
  };

  function zt(t) {
      return t.replace(/start|end/g, (function(t) {
          return qt[t]
      }))
  }

  function $t(t) {
      var e = dt(t);
      return {
          scrollLeft: e.pageXOffset,
          scrollTop: e.pageYOffset
      }
  }

  function Ut(t) {
      return _t(Et(t)).left + $t(t).scrollLeft
  }

  function Ft(t) {
      var e = yt(t),
          i = e.overflow,
          n = e.overflowX,
          s = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(i + s + n)
  }

  function Vt(t, e) {
      var i;
      void 0 === e && (e = []);
      var n = function t(e) {
              return ["html", "body", "#document"].indexOf(ht(e)) >= 0 ? e.ownerDocument.body : ft(e) && Ft(e) ? e : t(At(e))
          }(t),
          s = n === (null == (i = t.ownerDocument) ? void 0 : i.body),
          o = dt(n),
          r = s ? [o].concat(o.visualViewport || [], Ft(n) ? n : []) : n,
          a = e.concat(r);
      return s ? a : a.concat(Vt(At(r)))
  }

  function Kt(t) {
      return Object.assign({}, t, {
          left: t.x,
          top: t.y,
          right: t.x + t.width,
          bottom: t.y + t.height
      })
  }

  function Xt(t, e) {
      return "viewport" === e ? Kt(function(t) {
          var e = dt(t),
              i = Et(t),
              n = e.visualViewport,
              s = i.clientWidth,
              o = i.clientHeight,
              r = 0,
              a = 0;
          return n && (s = n.width, o = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = n.offsetLeft, a = n.offsetTop)), {
              width: s,
              height: o,
              x: r + Ut(t),
              y: a
          }
      }(t)) : ft(e) ? function(t) {
          var e = _t(t);
          return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e
      }(e) : Kt(function(t) {
          var e, i = Et(t),
              n = $t(t),
              s = null == (e = t.ownerDocument) ? void 0 : e.body,
              o = kt(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0),
              r = kt(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0),
              a = -n.scrollLeft + Ut(t),
              l = -n.scrollTop;
          return "rtl" === yt(s || i).direction && (a += kt(i.clientWidth, s ? s.clientWidth : 0) - o), {
              width: o,
              height: r,
              x: a,
              y: l
          }
      }(Et(t)))
  }

  function Yt(t) {
      return t.split("-")[1]
  }

  function Qt(t) {
      var e, i = t.reference,
          n = t.element,
          s = t.placement,
          o = s ? gt(s) : null,
          r = s ? Yt(s) : null,
          a = i.x + i.width / 2 - n.width / 2,
          l = i.y + i.height / 2 - n.height / 2;
      switch (o) {
          case it:
              e = {
                  x: a,
                  y: i.y - n.height
              };
              break;
          case nt:
              e = {
                  x: a,
                  y: i.y + i.height
              };
              break;
          case st:
              e = {
                  x: i.x + i.width,
                  y: l
              };
              break;
          case ot:
              e = {
                  x: i.x - n.width,
                  y: l
              };
              break;
          default:
              e = {
                  x: i.x,
                  y: i.y
              }
      }
      var c = o ? Ct(o) : null;
      if (null != c) {
          var h = "y" === c ? "height" : "width";
          switch (r) {
              case "start":
                  e[c] = e[c] - (i[h] / 2 - n[h] / 2);
                  break;
              case "end":
                  e[c] = e[c] + (i[h] / 2 - n[h] / 2)
          }
      }
      return e
  }

  function Gt(t, e) {
      void 0 === e && (e = {});
      var i = e,
          n = i.placement,
          s = void 0 === n ? t.placement : n,
          o = i.boundary,
          r = void 0 === o ? "clippingParents" : o,
          a = i.rootBoundary,
          l = void 0 === a ? "viewport" : a,
          c = i.elementContext,
          h = void 0 === c ? "popper" : c,
          d = i.altBoundary,
          u = void 0 !== d && d,
          f = i.padding,
          p = void 0 === f ? 0 : f,
          m = St("number" != typeof p ? p : It(p, rt)),
          g = "popper" === h ? "reference" : "popper",
          _ = t.elements.reference,
          b = t.rects.popper,
          v = t.elements[u ? g : h],
          y = function(t, e, i) {
              var n = "clippingParents" === e ? function(t) {
                      var e = Vt(At(t)),
                          i = ["absolute", "fixed"].indexOf(yt(t).position) >= 0 && ft(t) ? Ot(t) : t;
                      return ut(i) ? e.filter((function(t) {
                          return ut(t) && vt(t, i) && "body" !== ht(t)
                      })) : []
                  }(t) : [].concat(e),
                  s = [].concat(n, [i]),
                  o = s[0],
                  r = s.reduce((function(e, i) {
                      var n = Xt(t, i);
                      return e.top = kt(n.top, e.top), e.right = Lt(n.right, e.right), e.bottom = Lt(n.bottom, e.bottom), e.left = kt(n.left, e.left), e
                  }), Xt(t, o));
              return r.width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r
          }(ut(v) ? v : v.contextElement || Et(t.elements.popper), r, l),
          w = _t(_),
          E = Qt({
              reference: w,
              element: b,
              strategy: "absolute",
              placement: s
          }),
          A = Kt(Object.assign({}, b, E)),
          T = "popper" === h ? A : w,
          O = {
              top: y.top - T.top + m.top,
              bottom: T.bottom - y.bottom + m.bottom,
              left: y.left - T.left + m.left,
              right: T.right - y.right + m.right
          },
          C = t.modifiersData.offset;
      if ("popper" === h && C) {
          var k = C[s];
          Object.keys(O).forEach((function(t) {
              var e = [st, nt].indexOf(t) >= 0 ? 1 : -1,
                  i = [it, nt].indexOf(t) >= 0 ? "y" : "x";
              O[t] += k[i] * e
          }))
      }
      return O
  }

  function Zt(t, e) {
      void 0 === e && (e = {});
      var i = e,
          n = i.placement,
          s = i.boundary,
          o = i.rootBoundary,
          r = i.padding,
          a = i.flipVariations,
          l = i.allowedAutoPlacements,
          c = void 0 === l ? lt : l,
          h = Yt(n),
          d = h ? a ? at : at.filter((function(t) {
              return Yt(t) === h
          })) : rt,
          u = d.filter((function(t) {
              return c.indexOf(t) >= 0
          }));
      0 === u.length && (u = d);
      var f = u.reduce((function(e, i) {
          return e[i] = Gt(t, {
              placement: i,
              boundary: s,
              rootBoundary: o,
              padding: r
          })[gt(i)], e
      }), {});
      return Object.keys(f).sort((function(t, e) {
          return f[t] - f[e]
      }))
  }
  var Jt = {
      name: "flip",
      enabled: !0,
      phase: "main",
      fn: function(t) {
          var e = t.state,
              i = t.options,
              n = t.name;
          if (!e.modifiersData[n]._skip) {
              for (var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = gt(g), b = l || (_ !== g && p ? function(t) {
                      if ("auto" === gt(t)) return [];
                      var e = Wt(t);
                      return [zt(t), e, zt(e)]
                  }(g) : [Wt(g)]), v = [g].concat(b).reduce((function(t, i) {
                      return t.concat("auto" === gt(i) ? Zt(e, {
                          placement: i,
                          boundary: h,
                          rootBoundary: d,
                          padding: c,
                          flipVariations: p,
                          allowedAutoPlacements: m
                      }) : i)
                  }), []), y = e.rects.reference, w = e.rects.popper, E = new Map, A = !0, T = v[0], O = 0; O < v.length; O++) {
                  var C = v[O],
                      k = gt(C),
                      L = "start" === Yt(C),
                      x = [it, nt].indexOf(k) >= 0,
                      D = x ? "width" : "height",
                      S = Gt(e, {
                          placement: C,
                          boundary: h,
                          rootBoundary: d,
                          altBoundary: u,
                          padding: c
                      }),
                      I = x ? L ? st : ot : L ? nt : it;
                  y[D] > w[D] && (I = Wt(I));
                  var N = Wt(I),
                      j = [];
                  if (o && j.push(S[k] <= 0), a && j.push(S[I] <= 0, S[N] <= 0), j.every((function(t) {
                          return t
                      }))) {
                      T = C, A = !1;
                      break
                  }
                  E.set(C, j)
              }
              if (A)
                  for (var M = function(t) {
                          var e = v.find((function(e) {
                              var i = E.get(e);
                              if (i) return i.slice(0, t).every((function(t) {
                                  return t
                              }))
                          }));
                          if (e) return T = e, "break"
                      }, P = p ? 3 : 1; P > 0 && "break" !== M(P); P--);
              e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0)
          }
      },
      requiresIfExists: ["offset"],
      data: {
          _skip: !1
      }
  };

  function te(t, e, i) {
      return void 0 === i && (i = {
          x: 0,
          y: 0
      }), {
          top: t.top - e.height - i.y,
          right: t.right - e.width + i.x,
          bottom: t.bottom - e.height + i.y,
          left: t.left - e.width - i.x
      }
  }

  function ee(t) {
      return [it, st, nt, ot].some((function(e) {
          return t[e] >= 0
      }))
  }
  var ie = {
          name: "hide",
          enabled: !0,
          phase: "main",
          requiresIfExists: ["preventOverflow"],
          fn: function(t) {
              var e = t.state,
                  i = t.name,
                  n = e.rects.reference,
                  s = e.rects.popper,
                  o = e.modifiersData.preventOverflow,
                  r = Gt(e, {
                      elementContext: "reference"
                  }),
                  a = Gt(e, {
                      altBoundary: !0
                  }),
                  l = te(r, n),
                  c = te(a, s, o),
                  h = ee(l),
                  d = ee(c);
              e.modifiersData[i] = {
                  referenceClippingOffsets: l,
                  popperEscapeOffsets: c,
                  isReferenceHidden: h,
                  hasPopperEscaped: d
              }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
                  "data-popper-reference-hidden": h,
                  "data-popper-escaped": d
              })
          }
      },
      ne = {
          name: "offset",
          enabled: !0,
          phase: "main",
          requires: ["popperOffsets"],
          fn: function(t) {
              var e = t.state,
                  i = t.options,
                  n = t.name,
                  s = i.offset,
                  o = void 0 === s ? [0, 0] : s,
                  r = lt.reduce((function(t, i) {
                      return t[i] = function(t, e, i) {
                          var n = gt(t),
                              s = [ot, it].indexOf(n) >= 0 ? -1 : 1,
                              o = "function" == typeof i ? i(Object.assign({}, e, {
                                  placement: t
                              })) : i,
                              r = o[0],
                              a = o[1];
                          return r = r || 0, a = (a || 0) * s, [ot, st].indexOf(n) >= 0 ? {
                              x: a,
                              y: r
                          } : {
                              x: r,
                              y: a
                          }
                      }(i, e.rects, o), t
                  }), {}),
                  a = r[e.placement],
                  l = a.x,
                  c = a.y;
              null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r
          }
      },
      se = {
          name: "popperOffsets",
          enabled: !0,
          phase: "read",
          fn: function(t) {
              var e = t.state,
                  i = t.name;
              e.modifiersData[i] = Qt({
                  reference: e.rects.reference,
                  element: e.rects.popper,
                  strategy: "absolute",
                  placement: e.placement
              })
          },
          data: {}
      },
      oe = {
          name: "preventOverflow",
          enabled: !0,
          phase: "main",
          fn: function(t) {
              var e = t.state,
                  i = t.options,
                  n = t.name,
                  s = i.mainAxis,
                  o = void 0 === s || s,
                  r = i.altAxis,
                  a = void 0 !== r && r,
                  l = i.boundary,
                  c = i.rootBoundary,
                  h = i.altBoundary,
                  d = i.padding,
                  u = i.tether,
                  f = void 0 === u || u,
                  p = i.tetherOffset,
                  m = void 0 === p ? 0 : p,
                  g = Gt(e, {
                      boundary: l,
                      rootBoundary: c,
                      padding: d,
                      altBoundary: h
                  }),
                  _ = gt(e.placement),
                  b = Yt(e.placement),
                  v = !b,
                  y = Ct(_),
                  w = "x" === y ? "y" : "x",
                  E = e.modifiersData.popperOffsets,
                  A = e.rects.reference,
                  T = e.rects.popper,
                  O = "function" == typeof m ? m(Object.assign({}, e.rects, {
                      placement: e.placement
                  })) : m,
                  C = {
                      x: 0,
                      y: 0
                  };
              if (E) {
                  if (o || a) {
                      var k = "y" === y ? it : ot,
                          L = "y" === y ? nt : st,
                          x = "y" === y ? "height" : "width",
                          D = E[y],
                          S = E[y] + g[k],
                          I = E[y] - g[L],
                          N = f ? -T[x] / 2 : 0,
                          j = "start" === b ? A[x] : T[x],
                          M = "start" === b ? -T[x] : -A[x],
                          P = e.elements.arrow,
                          H = f && P ? bt(P) : {
                              width: 0,
                              height: 0
                          },
                          R = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
                              top: 0,
                              right: 0,
                              bottom: 0,
                              left: 0
                          },
                          B = R[k],
                          W = R[L],
                          q = Dt(0, A[x], H[x]),
                          z = v ? A[x] / 2 - N - q - B - O : j - q - B - O,
                          $ = v ? -A[x] / 2 + N + q + W + O : M + q + W + O,
                          U = e.elements.arrow && Ot(e.elements.arrow),
                          F = U ? "y" === y ? U.clientTop || 0 : U.clientLeft || 0 : 0,
                          V = e.modifiersData.offset ? e.modifiersData.offset[e.placement][y] : 0,
                          K = E[y] + z - V - F,
                          X = E[y] + $ - V;
                      if (o) {
                          var Y = Dt(f ? Lt(S, K) : S, D, f ? kt(I, X) : I);
                          E[y] = Y, C[y] = Y - D
                      }
                      if (a) {
                          var Q = "x" === y ? it : ot,
                              G = "x" === y ? nt : st,
                              Z = E[w],
                              J = Z + g[Q],
                              tt = Z - g[G],
                              et = Dt(f ? Lt(J, K) : J, Z, f ? kt(tt, X) : tt);
                          E[w] = et, C[w] = et - Z
                      }
                  }
                  e.modifiersData[n] = C
              }
          },
          requiresIfExists: ["offset"]
      };

  function re(t, e, i) {
      void 0 === i && (i = !1);
      var n, s, o = Et(e),
          r = _t(t),
          a = ft(e),
          l = {
              scrollLeft: 0,
              scrollTop: 0
          },
          c = {
              x: 0,
              y: 0
          };
      return (a || !a && !i) && (("body" !== ht(e) || Ft(o)) && (l = (n = e) !== dt(n) && ft(n) ? {
          scrollLeft: (s = n).scrollLeft,
          scrollTop: s.scrollTop
      } : $t(n)), ft(e) ? ((c = _t(e)).x += e.clientLeft, c.y += e.clientTop) : o && (c.x = Ut(o))), {
          x: r.left + l.scrollLeft - c.x,
          y: r.top + l.scrollTop - c.y,
          width: r.width,
          height: r.height
      }
  }
  var ae = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
  };

  function le() {
      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
      return !e.some((function(t) {
          return !(t && "function" == typeof t.getBoundingClientRect)
      }))
  }

  function ce(t) {
      void 0 === t && (t = {});
      var e = t,
          i = e.defaultModifiers,
          n = void 0 === i ? [] : i,
          s = e.defaultOptions,
          o = void 0 === s ? ae : s;
      return function(t, e, i) {
          void 0 === i && (i = o);
          var s, r, a = {
                  placement: "bottom",
                  orderedModifiers: [],
                  options: Object.assign({}, ae, o),
                  modifiersData: {},
                  elements: {
                      reference: t,
                      popper: e
                  },
                  attributes: {},
                  styles: {}
              },
              l = [],
              c = !1,
              h = {
                  state: a,
                  setOptions: function(i) {
                      d(), a.options = Object.assign({}, o, a.options, i), a.scrollParents = {
                          reference: ut(t) ? Vt(t) : t.contextElement ? Vt(t.contextElement) : [],
                          popper: Vt(e)
                      };
                      var s, r, c = function(t) {
                          var e = function(t) {
                              var e = new Map,
                                  i = new Set,
                                  n = [];
                              return t.forEach((function(t) {
                                  e.set(t.name, t)
                              })), t.forEach((function(t) {
                                  i.has(t.name) || function t(s) {
                                      i.add(s.name), [].concat(s.requires || [], s.requiresIfExists || []).forEach((function(n) {
                                          if (!i.has(n)) {
                                              var s = e.get(n);
                                              s && t(s)
                                          }
                                      })), n.push(s)
                                  }(t)
                              })), n
                          }(t);
                          return ct.reduce((function(t, i) {
                              return t.concat(e.filter((function(t) {
                                  return t.phase === i
                              })))
                          }), [])
                      }((s = [].concat(n, a.options.modifiers), r = s.reduce((function(t, e) {
                          var i = t[e.name];
                          return t[e.name] = i ? Object.assign({}, i, e, {
                              options: Object.assign({}, i.options, e.options),
                              data: Object.assign({}, i.data, e.data)
                          }) : e, t
                      }), {}), Object.keys(r).map((function(t) {
                          return r[t]
                      }))));
                      return a.orderedModifiers = c.filter((function(t) {
                          return t.enabled
                      })), a.orderedModifiers.forEach((function(t) {
                          var e = t.name,
                              i = t.options,
                              n = void 0 === i ? {} : i,
                              s = t.effect;
                          if ("function" == typeof s) {
                              var o = s({
                                  state: a,
                                  name: e,
                                  instance: h,
                                  options: n
                              });
                              l.push(o || function() {})
                          }
                      })), h.update()
                  },
                  forceUpdate: function() {
                      if (!c) {
                          var t = a.elements,
                              e = t.reference,
                              i = t.popper;
                          if (le(e, i)) {
                              a.rects = {
                                  reference: re(e, Ot(i), "fixed" === a.options.strategy),
                                  popper: bt(i)
                              }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function(t) {
                                  return a.modifiersData[t.name] = Object.assign({}, t.data)
                              }));
                              for (var n = 0; n < a.orderedModifiers.length; n++)
                                  if (!0 !== a.reset) {
                                      var s = a.orderedModifiers[n],
                                          o = s.fn,
                                          r = s.options,
                                          l = void 0 === r ? {} : r,
                                          d = s.name;
                                      "function" == typeof o && (a = o({
                                          state: a,
                                          options: l,
                                          name: d,
                                          instance: h
                                      }) || a)
                                  } else a.reset = !1, n = -1
                          }
                      }
                  },
                  update: (s = function() {
                      return new Promise((function(t) {
                          h.forceUpdate(), t(a)
                      }))
                  }, function() {
                      return r || (r = new Promise((function(t) {
                          Promise.resolve().then((function() {
                              r = void 0, t(s())
                          }))
                      }))), r
                  }),
                  destroy: function() {
                      d(), c = !0
                  }
              };
          if (!le(t, e)) return h;

          function d() {
              l.forEach((function(t) {
                  return t()
              })), l = []
          }
          return h.setOptions(i).then((function(t) {
              !c && i.onFirstUpdate && i.onFirstUpdate(t)
          })), h
      }
  }
  var he = ce(),
      de = ce({
          defaultModifiers: [Rt, se, Pt, mt]
      }),
      ue = ce({
          defaultModifiers: [Rt, se, Pt, mt, ne, Jt, oe, Nt, ie]
      }),
      fe = Object.freeze({
          __proto__: null,
          popperGenerator: ce,
          detectOverflow: Gt,
          createPopperBase: he,
          createPopper: ue,
          createPopperLite: de,
          top: it,
          bottom: nt,
          right: st,
          left: ot,
          auto: "auto",
          basePlacements: rt,
          start: "start",
          end: "end",
          clippingParents: "clippingParents",
          viewport: "viewport",
          popper: "popper",
          reference: "reference",
          variationPlacements: at,
          placements: lt,
          beforeRead: "beforeRead",
          read: "read",
          afterRead: "afterRead",
          beforeMain: "beforeMain",
          main: "main",
          afterMain: "afterMain",
          beforeWrite: "beforeWrite",
          write: "write",
          afterWrite: "afterWrite",
          modifierPhases: ct,
          applyStyles: mt,
          arrow: Nt,
          computeStyles: Pt,
          eventListeners: Rt,
          flip: Jt,
          hide: ie,
          offset: ne,
          popperOffsets: se,
          preventOverflow: oe
      });
  const pe = new RegExp("ArrowUp|ArrowDown|Escape"),
      me = g() ? "top-end" : "top-start",
      ge = g() ? "top-start" : "top-end",
      _e = g() ? "bottom-end" : "bottom-start",
      be = g() ? "bottom-start" : "bottom-end",
      ve = g() ? "left-start" : "right-start",
      ye = g() ? "right-start" : "left-start",
      we = {
          offset: [0, 2],
          boundary: "clippingParents",
          reference: "toggle",
          display: "dynamic",
          popperConfig: null,
          autoClose: !0
      },
      Ee = {
          offset: "(array|string|function)",
          boundary: "(string|element)",
          reference: "(string|element|object)",
          display: "string",
          popperConfig: "(null|object|function)",
          autoClose: "(boolean|string)"
      };
  class Ae extends B {
      constructor(t, e) {
          super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners()
      }
      static get Default() {
          return we
      }
      static get DefaultType() {
          return Ee
      }
      static get NAME() {
          return "dropdown"
      }
      toggle() {
          h(this._element) || (this._element.classList.contains("show") ? this.hide() : this.show())
      }
      show() {
          if (h(this._element) || this._menu.classList.contains("show")) return;
          const t = Ae.getParentFromElement(this._element),
              e = {
                  relatedTarget: this._element
              };
          if (!P.trigger(this._element, "show.bs.dropdown", e).defaultPrevented) {
              if (this._inNavbar) U.setDataAttribute(this._menu, "popper", "none");
              else {
                  if (void 0 === fe) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                  let e = this._element;
                  "parent" === this._config.reference ? e = t : r(this._config.reference) ? e = a(this._config.reference) : "object" == typeof this._config.reference && (e = this._config.reference);
                  const i = this._getPopperConfig(),
                      n = i.modifiers.find(t => "applyStyles" === t.name && !1 === t.enabled);
                  this._popper = ue(e, this._menu, i), n && U.setDataAttribute(this._menu, "popper", "static")
              }
              "ontouchstart" in document.documentElement && !t.closest(".navbar-nav") && [].concat(...document.body.children).forEach(t => P.on(t, "mouseover", u)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), P.trigger(this._element, "shown.bs.dropdown", e)
          }
      }
      hide() {
          if (h(this._element) || !this._menu.classList.contains("show")) return;
          const t = {
              relatedTarget: this._element
          };
          this._completeHide(t)
      }
      dispose() {
          this._popper && this._popper.destroy(), super.dispose()
      }
      update() {
          this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
      }
      _addEventListeners() {
          P.on(this._element, "click.bs.dropdown", t => {
              t.preventDefault(), this.toggle()
          })
      }
      _completeHide(t) {
          P.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => P.off(t, "mouseover", u)), this._popper && this._popper.destroy(), this._menu.classList.remove("show"), this._element.classList.remove("show"), this._element.setAttribute("aria-expanded", "false"), U.removeDataAttribute(this._menu, "popper"), P.trigger(this._element, "hidden.bs.dropdown", t))
      }
      _getConfig(t) {
          if (t = {
                  ...this.constructor.Default,
                  ...U.getDataAttributes(this._element),
                  ...t
              }, l("dropdown", t, this.constructor.DefaultType), "object" == typeof t.reference && !r(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError("dropdown".toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.');
          return t
      }
      _getMenuElement() {
          return t.next(this._element, ".dropdown-menu")[0]
      }
      _getPlacement() {
          const t = this._element.parentNode;
          if (t.classList.contains("dropend")) return ve;
          if (t.classList.contains("dropstart")) return ye;
          const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
          return t.classList.contains("dropup") ? e ? ge : me : e ? be : _e
      }
      _detectNavbar() {
          return null !== this._element.closest(".navbar")
      }
      _getOffset() {
          const {
              offset: t
          } = this._config;
          return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t
      }
      _getPopperConfig() {
          const t = {
              placement: this._getPlacement(),
              modifiers: [{
                  name: "preventOverflow",
                  options: {
                      boundary: this._config.boundary
                  }
              }, {
                  name: "offset",
                  options: {
                      offset: this._getOffset()
                  }
              }]
          };
          return "static" === this._config.display && (t.modifiers = [{
              name: "applyStyles",
              enabled: !1
          }]), {
              ...t,
              ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig
          }
      }
      _selectMenuItem({
          key: e,
          target: i
      }) {
          const n = t.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(c);
          n.length && y(n, i, "ArrowDown" === e, !n.includes(i)).focus()
      }
      static dropdownInterface(t, e) {
          const i = Ae.getOrCreateInstance(t, e);
          if ("string" == typeof e) {
              if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`);
              i[e]()
          }
      }
      static jQueryInterface(t) {
          return this.each((function() {
              Ae.dropdownInterface(this, t)
          }))
      }
      static clearMenus(e) {
          if (e && (2 === e.button || "keyup" === e.type && "Tab" !== e.key)) return;
          const i = t.find('[data-bs-toggle="dropdown"]');
          for (let t = 0, n = i.length; t < n; t++) {
              const n = Ae.getInstance(i[t]);
              if (!n || !1 === n._config.autoClose) continue;
              if (!n._element.classList.contains("show")) continue;
              const s = {
                  relatedTarget: n._element
              };
              if (e) {
                  const t = e.composedPath(),
                      i = t.includes(n._menu);
                  if (t.includes(n._element) || "inside" === n._config.autoClose && !i || "outside" === n._config.autoClose && i) continue;
                  if (n._menu.contains(e.target) && ("keyup" === e.type && "Tab" === e.key || /input|select|option|textarea|form/i.test(e.target.tagName))) continue;
                  "click" === e.type && (s.clickEvent = e)
              }
              n._completeHide(s)
          }
      }
      static getParentFromElement(t) {
          return s(t) || t.parentNode
      }
      static dataApiKeydownHandler(e) {
          if (/input|textarea/i.test(e.target.tagName) ? "Space" === e.key || "Escape" !== e.key && ("ArrowDown" !== e.key && "ArrowUp" !== e.key || e.target.closest(".dropdown-menu")) : !pe.test(e.key)) return;
          const i = this.classList.contains("show");
          if (!i && "Escape" === e.key) return;
          if (e.preventDefault(), e.stopPropagation(), h(this)) return;
          const n = () => this.matches('[data-bs-toggle="dropdown"]') ? this : t.prev(this, '[data-bs-toggle="dropdown"]')[0];
          return "Escape" === e.key ? (n().focus(), void Ae.clearMenus()) : "ArrowUp" === e.key || "ArrowDown" === e.key ? (i || n().click(), void Ae.getInstance(n())._selectMenuItem(e)) : void(i && "Space" !== e.key || Ae.clearMenus())
      }
  }
  P.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', Ae.dataApiKeydownHandler), P.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", Ae.dataApiKeydownHandler), P.on(document, "click.bs.dropdown.data-api", Ae.clearMenus), P.on(document, "keyup.bs.dropdown.data-api", Ae.clearMenus), P.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', (function(t) {
      t.preventDefault(), Ae.dropdownInterface(this)
  })), _(Ae);
  class Te {
      constructor() {
          this._element = document.body
      }
      getWidth() {
          const t = document.documentElement.clientWidth;
          return Math.abs(window.innerWidth - t)
      }
      hide() {
          const t = this.getWidth();
          this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", e => e + t), this._setElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight", e => e + t), this._setElementAttributes(".sticky-top", "marginRight", e => e - t)
      }
      _disableOverFlow() {
          this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
      }
      _setElementAttributes(t, e, i) {
          const n = this.getWidth();
          this._applyManipulationCallback(t, t => {
              if (t !== this._element && window.innerWidth > t.clientWidth + n) return;
              this._saveInitialAttribute(t, e);
              const s = window.getComputedStyle(t)[e];
              t.style[e] = i(Number.parseFloat(s)) + "px"
          })
      }
      reset() {
          this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight"), this._resetElementAttributes(".sticky-top", "marginRight")
      }
      _saveInitialAttribute(t, e) {
          const i = t.style[e];
          i && U.setDataAttribute(t, e, i)
      }
      _resetElementAttributes(t, e) {
          this._applyManipulationCallback(t, t => {
              const i = U.getDataAttribute(t, e);
              void 0 === i ? t.style.removeProperty(e) : (U.removeDataAttribute(t, e), t.style[e] = i)
          })
      }
      _applyManipulationCallback(e, i) {
          r(e) ? i(e) : t.find(e, this._element).forEach(i)
      }
      isOverflowing() {
          return this.getWidth() > 0
      }
  }
  const Oe = {
          isVisible: !0,
          isAnimated: !1,
          rootElement: "body",
          clickCallback: null
      },
      Ce = {
          isVisible: "boolean",
          isAnimated: "boolean",
          rootElement: "(element|string)",
          clickCallback: "(function|null)"
      };
  class ke {
      constructor(t) {
          this._config = this._getConfig(t), this._isAppended = !1, this._element = null
      }
      show(t) {
          this._config.isVisible ? (this._append(), this._config.isAnimated && f(this._getElement()), this._getElement().classList.add("show"), this._emulateAnimation(() => {
              b(t)
          })) : b(t)
      }
      hide(t) {
          this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => {
              this.dispose(), b(t)
          })) : b(t)
      }
      _getElement() {
          if (!this._element) {
              const t = document.createElement("div");
              t.className = "modal-backdrop", this._config.isAnimated && t.classList.add("fade"), this._element = t
          }
          return this._element
      }
      _getConfig(t) {
          return (t = {
              ...Oe,
              ..."object" == typeof t ? t : {}
          }).rootElement = a(t.rootElement), l("backdrop", t, Ce), t
      }
      _append() {
          this._isAppended || (this._config.rootElement.appendChild(this._getElement()), P.on(this._getElement(), "mousedown.bs.backdrop", () => {
              b(this._config.clickCallback)
          }), this._isAppended = !0)
      }
      dispose() {
          this._isAppended && (P.off(this._element, "mousedown.bs.backdrop"), this._element.remove(), this._isAppended = !1)
      }
      _emulateAnimation(t) {
          v(t, this._getElement(), this._config.isAnimated)
      }
  }
  const Le = {
          backdrop: !0,
          keyboard: !0,
          focus: !0
      },
      xe = {
          backdrop: "(boolean|string)",
          keyboard: "boolean",
          focus: "boolean"
      };
  class De extends B {
      constructor(e, i) {
          super(e), this._config = this._getConfig(i), this._dialog = t.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new Te
      }
      static get Default() {
          return Le
      }
      static get NAME() {
          return "modal"
      }
      toggle(t) {
          return this._isShown ? this.hide() : this.show(t)
      }
      show(t) {
          this._isShown || this._isTransitioning || P.trigger(this._element, "show.bs.modal", {
              relatedTarget: t
          }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add("modal-open"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), P.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', t => this.hide(t)), P.on(this._dialog, "mousedown.dismiss.bs.modal", () => {
              P.one(this._element, "mouseup.dismiss.bs.modal", t => {
                  t.target === this._element && (this._ignoreBackdropClick = !0)
              })
          }), this._showBackdrop(() => this._showElement(t)))
      }
      hide(t) {
          if (t && ["A", "AREA"].includes(t.target.tagName) && t.preventDefault(), !this._isShown || this._isTransitioning) return;
          if (P.trigger(this._element, "hide.bs.modal").defaultPrevented) return;
          this._isShown = !1;
          const e = this._isAnimated();
          e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), P.off(document, "focusin.bs.modal"), this._element.classList.remove("show"), P.off(this._element, "click.dismiss.bs.modal"), P.off(this._dialog, "mousedown.dismiss.bs.modal"), this._queueCallback(() => this._hideModal(), this._element, e)
      }
      dispose() {
          [window, this._dialog].forEach(t => P.off(t, ".bs.modal")), this._backdrop.dispose(), super.dispose(), P.off(document, "focusin.bs.modal")
      }
      handleUpdate() {
          this._adjustDialog()
      }
      _initializeBackDrop() {
          return new ke({
              isVisible: Boolean(this._config.backdrop),
              isAnimated: this._isAnimated()
          })
      }
      _getConfig(t) {
          return t = {
              ...Le,
              ...U.getDataAttributes(this._element),
              ..."object" == typeof t ? t : {}
          }, l("modal", t, xe), t
      }
      _showElement(e) {
          const i = this._isAnimated(),
              n = t.findOne(".modal-body", this._dialog);
          this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n && (n.scrollTop = 0), i && f(this._element), this._element.classList.add("show"), this._config.focus && this._enforceFocus(), this._queueCallback(() => {
              this._config.focus && this._element.focus(), this._isTransitioning = !1, P.trigger(this._element, "shown.bs.modal", {
                  relatedTarget: e
              })
          }, this._dialog, i)
      }
      _enforceFocus() {
          P.off(document, "focusin.bs.modal"), P.on(document, "focusin.bs.modal", t => {
              document === t.target || this._element === t.target || this._element.contains(t.target) || this._element.focus()
          })
      }
      _setEscapeEvent() {
          this._isShown ? P.on(this._element, "keydown.dismiss.bs.modal", t => {
              this._config.keyboard && "Escape" === t.key ? (t.preventDefault(), this.hide()) : this._config.keyboard || "Escape" !== t.key || this._triggerBackdropTransition()
          }) : P.off(this._element, "keydown.dismiss.bs.modal")
      }
      _setResizeEvent() {
          this._isShown ? P.on(window, "resize.bs.modal", () => this._adjustDialog()) : P.off(window, "resize.bs.modal")
      }
      _hideModal() {
          this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
              document.body.classList.remove("modal-open"), this._resetAdjustments(), this._scrollBar.reset(), P.trigger(this._element, "hidden.bs.modal")
          })
      }
      _showBackdrop(t) {
          P.on(this._element, "click.dismiss.bs.modal", t => {
              this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : t.target === t.currentTarget && (!0 === this._config.backdrop ? this.hide() : "static" === this._config.backdrop && this._triggerBackdropTransition())
          }), this._backdrop.show(t)
      }
      _isAnimated() {
          return this._element.classList.contains("fade")
      }
      _triggerBackdropTransition() {
          if (P.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) return;
          const {
              classList: t,
              scrollHeight: e,
              style: i
          } = this._element, n = e > document.documentElement.clientHeight;
          !n && "hidden" === i.overflowY || t.contains("modal-static") || (n || (i.overflowY = "hidden"), t.add("modal-static"), this._queueCallback(() => {
              t.remove("modal-static"), n || this._queueCallback(() => {
                  i.overflowY = ""
              }, this._dialog)
          }, this._dialog), this._element.focus())
      }
      _adjustDialog() {
          const t = this._element.scrollHeight > document.documentElement.clientHeight,
              e = this._scrollBar.getWidth(),
              i = e > 0;
          (!i && t && !g() || i && !t && g()) && (this._element.style.paddingLeft = e + "px"), (i && !t && !g() || !i && t && g()) && (this._element.style.paddingRight = e + "px")
      }
      _resetAdjustments() {
          this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
      }
      static jQueryInterface(t, e) {
          return this.each((function() {
              const i = De.getOrCreateInstance(this, t);
              if ("string" == typeof t) {
                  if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
                  i[t](e)
              }
          }))
      }
  }
  P.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function(t) {
      const e = s(this);
      ["A", "AREA"].includes(this.tagName) && t.preventDefault(), P.one(e, "show.bs.modal", t => {
          t.defaultPrevented || P.one(e, "hidden.bs.modal", () => {
              c(this) && this.focus()
          })
      }), De.getOrCreateInstance(e).toggle(this)
  })), _(De);
  const Se = {
          backdrop: !0,
          keyboard: !0,
          scroll: !1
      },
      Ie = {
          backdrop: "boolean",
          keyboard: "boolean",
          scroll: "boolean"
      };
  class Ne extends B {
      constructor(t, e) {
          super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._addEventListeners()
      }
      static get NAME() {
          return "offcanvas"
      }
      static get Default() {
          return Se
      }
      toggle(t) {
          return this._isShown ? this.hide() : this.show(t)
      }
      show(t) {
          this._isShown || P.trigger(this._element, "show.bs.offcanvas", {
              relatedTarget: t
          }).defaultPrevented || (this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || ((new Te).hide(), this._enforceFocusOnElement(this._element)), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add("show"), this._queueCallback(() => {
              P.trigger(this._element, "shown.bs.offcanvas", {
                  relatedTarget: t
              })
          }, this._element, !0))
      }
      hide() {
          this._isShown && (P.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (P.off(document, "focusin.bs.offcanvas"), this._element.blur(), this._isShown = !1, this._element.classList.remove("show"), this._backdrop.hide(), this._queueCallback(() => {
              this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || (new Te).reset(), P.trigger(this._element, "hidden.bs.offcanvas")
          }, this._element, !0)))
      }
      dispose() {
          this._backdrop.dispose(), super.dispose(), P.off(document, "focusin.bs.offcanvas")
      }
      _getConfig(t) {
          return t = {
              ...Se,
              ...U.getDataAttributes(this._element),
              ..."object" == typeof t ? t : {}
          }, l("offcanvas", t, Ie), t
      }
      _initializeBackDrop() {
          return new ke({
              isVisible: this._config.backdrop,
              isAnimated: !0,
              rootElement: this._element.parentNode,
              clickCallback: () => this.hide()
          })
      }
      _enforceFocusOnElement(t) {
          P.off(document, "focusin.bs.offcanvas"), P.on(document, "focusin.bs.offcanvas", e => {
              document === e.target || t === e.target || t.contains(e.target) || t.focus()
          }), t.focus()
      }
      _addEventListeners() {
          P.on(this._element, "click.dismiss.bs.offcanvas", '[data-bs-dismiss="offcanvas"]', () => this.hide()), P.on(this._element, "keydown.dismiss.bs.offcanvas", t => {
              this._config.keyboard && "Escape" === t.key && this.hide()
          })
      }
      static jQueryInterface(t) {
          return this.each((function() {
              const e = Ne.getOrCreateInstance(this, t);
              if ("string" == typeof t) {
                  if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                  e[t](this)
              }
          }))
      }
  }
  P.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', (function(e) {
      const i = s(this);
      if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), h(this)) return;
      P.one(i, "hidden.bs.offcanvas", () => {
          c(this) && this.focus()
      });
      const n = t.findOne(".offcanvas.show");
      n && n !== i && Ne.getInstance(n).hide(), Ne.getOrCreateInstance(i).toggle(this)
  })), P.on(window, "load.bs.offcanvas.data-api", () => t.find(".offcanvas.show").forEach(t => Ne.getOrCreateInstance(t).show())), _(Ne);
  const je = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
      Me = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i,
      Pe = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
      He = (t, e) => {
          const i = t.nodeName.toLowerCase();
          if (e.includes(i)) return !je.has(i) || Boolean(Me.test(t.nodeValue) || Pe.test(t.nodeValue));
          const n = e.filter(t => t instanceof RegExp);
          for (let t = 0, e = n.length; t < e; t++)
              if (n[t].test(i)) return !0;
          return !1
      };

  function Re(t, e, i) {
      if (!t.length) return t;
      if (i && "function" == typeof i) return i(t);
      const n = (new window.DOMParser).parseFromString(t, "text/html"),
          s = Object.keys(e),
          o = [].concat(...n.body.querySelectorAll("*"));
      for (let t = 0, i = o.length; t < i; t++) {
          const i = o[t],
              n = i.nodeName.toLowerCase();
          if (!s.includes(n)) {
              i.remove();
              continue
          }
          const r = [].concat(...i.attributes),
              a = [].concat(e["*"] || [], e[n] || []);
          r.forEach(t => {
              He(t, a) || i.removeAttribute(t.nodeName)
          })
      }
      return n.body.innerHTML
  }
  const Be = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
      We = new Set(["sanitize", "allowList", "sanitizeFn"]),
      qe = {
          animation: "boolean",
          template: "string",
          title: "(string|element|function)",
          trigger: "string",
          delay: "(number|object)",
          html: "boolean",
          selector: "(string|boolean)",
          placement: "(string|function)",
          offset: "(array|string|function)",
          container: "(string|element|boolean)",
          fallbackPlacements: "array",
          boundary: "(string|element)",
          customClass: "(string|function)",
          sanitize: "boolean",
          sanitizeFn: "(null|function)",
          allowList: "object",
          popperConfig: "(null|object|function)"
      },
      ze = {
          AUTO: "auto",
          TOP: "top",
          RIGHT: g() ? "left" : "right",
          BOTTOM: "bottom",
          LEFT: g() ? "right" : "left"
      },
      $e = {
          animation: !0,
          template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
          trigger: "hover focus",
          title: "",
          delay: 0,
          html: !1,
          selector: !1,
          placement: "top",
          offset: [0, 0],
          container: !1,
          fallbackPlacements: ["top", "right", "bottom", "left"],
          boundary: "clippingParents",
          customClass: "",
          sanitize: !0,
          sanitizeFn: null,
          allowList: {
              "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
              a: ["target", "href", "title", "rel"],
              area: [],
              b: [],
              br: [],
              col: [],
              code: [],
              div: [],
              em: [],
              hr: [],
              h1: [],
              h2: [],
              h3: [],
              h4: [],
              h5: [],
              h6: [],
              i: [],
              img: ["src", "srcset", "alt", "title", "width", "height"],
              li: [],
              ol: [],
              p: [],
              pre: [],
              s: [],
              small: [],
              span: [],
              sub: [],
              sup: [],
              strong: [],
              u: [],
              ul: []
          },
          popperConfig: null
      },
      Ue = {
          HIDE: "hide.bs.tooltip",
          HIDDEN: "hidden.bs.tooltip",
          SHOW: "show.bs.tooltip",
          SHOWN: "shown.bs.tooltip",
          INSERTED: "inserted.bs.tooltip",
          CLICK: "click.bs.tooltip",
          FOCUSIN: "focusin.bs.tooltip",
          FOCUSOUT: "focusout.bs.tooltip",
          MOUSEENTER: "mouseenter.bs.tooltip",
          MOUSELEAVE: "mouseleave.bs.tooltip"
      };
  class Fe extends B {
      constructor(t, e) {
          if (void 0 === fe) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
          super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners()
      }
      static get Default() {
          return $e
      }
      static get NAME() {
          return "tooltip"
      }
      static get Event() {
          return Ue
      }
      static get DefaultType() {
          return qe
      }
      enable() {
          this._isEnabled = !0
      }
      disable() {
          this._isEnabled = !1
      }
      toggleEnabled() {
          this._isEnabled = !this._isEnabled
      }
      toggle(t) {
          if (this._isEnabled)
              if (t) {
                  const e = this._initializeOnDelegatedTarget(t);
                  e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e)
              } else {
                  if (this.getTipElement().classList.contains("show")) return void this._leave(null, this);
                  this._enter(null, this)
              }
      }
      dispose() {
          clearTimeout(this._timeout), P.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.remove(), this._popper && this._popper.destroy(), super.dispose()
      }
      show() {
          if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
          if (!this.isWithContent() || !this._isEnabled) return;
          const t = P.trigger(this._element, this.constructor.Event.SHOW),
              i = d(this._element),
              n = null === i ? this._element.ownerDocument.documentElement.contains(this._element) : i.contains(this._element);
          if (t.defaultPrevented || !n) return;
          const s = this.getTipElement(),
              o = e(this.constructor.NAME);
          s.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this.setContent(), this._config.animation && s.classList.add("fade");
          const r = "function" == typeof this._config.placement ? this._config.placement.call(this, s, this._element) : this._config.placement,
              a = this._getAttachment(r);
          this._addAttachmentClass(a);
          const {
              container: l
          } = this._config;
          R.set(s, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.appendChild(s), P.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = ue(this._element, s, this._getPopperConfig(a)), s.classList.add("show");
          const c = "function" == typeof this._config.customClass ? this._config.customClass() : this._config.customClass;
          c && s.classList.add(...c.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => {
              P.on(t, "mouseover", u)
          });
          const h = this.tip.classList.contains("fade");
          this._queueCallback(() => {
              const t = this._hoverState;
              this._hoverState = null, P.trigger(this._element, this.constructor.Event.SHOWN), "out" === t && this._leave(null, this)
          }, this.tip, h)
      }
      hide() {
          if (!this._popper) return;
          const t = this.getTipElement();
          if (P.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return;
          t.classList.remove("show"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => P.off(t, "mouseover", u)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1;
          const e = this.tip.classList.contains("fade");
          this._queueCallback(() => {
              this._isWithActiveTrigger() || ("show" !== this._hoverState && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), P.trigger(this._element, this.constructor.Event.HIDDEN), this._popper && (this._popper.destroy(), this._popper = null))
          }, this.tip, e), this._hoverState = ""
      }
      update() {
          null !== this._popper && this._popper.update()
      }
      isWithContent() {
          return Boolean(this.getTitle())
      }
      getTipElement() {
          if (this.tip) return this.tip;
          const t = document.createElement("div");
          return t.innerHTML = this._config.template, this.tip = t.children[0], this.tip
      }
      setContent() {
          const e = this.getTipElement();
          this.setElementContent(t.findOne(".tooltip-inner", e), this.getTitle()), e.classList.remove("fade", "show")
      }
      setElementContent(t, e) {
          if (null !== t) return r(e) ? (e = a(e), void(this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.appendChild(e)) : t.textContent = e.textContent)) : void(this._config.html ? (this._config.sanitize && (e = Re(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e)
      }
      getTitle() {
          let t = this._element.getAttribute("data-bs-original-title");
          return t || (t = "function" == typeof this._config.title ? this._config.title.call(this._element) : this._config.title), t
      }
      updateAttachment(t) {
          return "right" === t ? "end" : "left" === t ? "start" : t
      }
      _initializeOnDelegatedTarget(t, e) {
          const i = this.constructor.DATA_KEY;
          return (e = e || R.get(t.delegateTarget, i)) || (e = new this.constructor(t.delegateTarget, this._getDelegateConfig()), R.set(t.delegateTarget, i, e)), e
      }
      _getOffset() {
          const {
              offset: t
          } = this._config;
          return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t
      }
      _getPopperConfig(t) {
          const e = {
              placement: t,
              modifiers: [{
                  name: "flip",
                  options: {
                      fallbackPlacements: this._config.fallbackPlacements
                  }
              }, {
                  name: "offset",
                  options: {
                      offset: this._getOffset()
                  }
              }, {
                  name: "preventOverflow",
                  options: {
                      boundary: this._config.boundary
                  }
              }, {
                  name: "arrow",
                  options: {
                      element: `.${this.constructor.NAME}-arrow`
                  }
              }, {
                  name: "onChange",
                  enabled: !0,
                  phase: "afterWrite",
                  fn: t => this._handlePopperPlacementChange(t)
              }],
              onFirstUpdate: t => {
                  t.options.placement !== t.placement && this._handlePopperPlacementChange(t)
              }
          };
          return {
              ...e,
              ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig
          }
      }
      _addAttachmentClass(t) {
          this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(t))
      }
      _getAttachment(t) {
          return ze[t.toUpperCase()]
      }
      _setListeners() {
          this._config.trigger.split(" ").forEach(t => {
              if ("click" === t) P.on(this._element, this.constructor.Event.CLICK, this._config.selector, t => this.toggle(t));
              else if ("manual" !== t) {
                  const e = "hover" === t ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN,
                      i = "hover" === t ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
                  P.on(this._element, e, this._config.selector, t => this._enter(t)), P.on(this._element, i, this._config.selector, t => this._leave(t))
              }
          }), this._hideModalHandler = () => {
              this._element && this.hide()
          }, P.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this._config.selector ? this._config = {
              ...this._config,
              trigger: "manual",
              selector: ""
          } : this._fixTitle()
      }
      _fixTitle() {
          const t = this._element.getAttribute("title"),
              e = typeof this._element.getAttribute("data-bs-original-title");
          (t || "string" !== e) && (this._element.setAttribute("data-bs-original-title", t || ""), !t || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""))
      }
      _enter(t, e) {
          e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusin" === t.type ? "focus" : "hover"] = !0), e.getTipElement().classList.contains("show") || "show" === e._hoverState ? e._hoverState = "show" : (clearTimeout(e._timeout), e._hoverState = "show", e._config.delay && e._config.delay.show ? e._timeout = setTimeout(() => {
              "show" === e._hoverState && e.show()
          }, e._config.delay.show) : e.show())
      }
      _leave(t, e) {
          e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusout" === t.type ? "focus" : "hover"] = e._element.contains(t.relatedTarget)), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = "out", e._config.delay && e._config.delay.hide ? e._timeout = setTimeout(() => {
              "out" === e._hoverState && e.hide()
          }, e._config.delay.hide) : e.hide())
      }
      _isWithActiveTrigger() {
          for (const t in this._activeTrigger)
              if (this._activeTrigger[t]) return !0;
          return !1
      }
      _getConfig(t) {
          const e = U.getDataAttributes(this._element);
          return Object.keys(e).forEach(t => {
              We.has(t) && delete e[t]
          }), (t = {
              ...this.constructor.Default,
              ...e,
              ..."object" == typeof t && t ? t : {}
          }).container = !1 === t.container ? document.body : a(t.container), "number" == typeof t.delay && (t.delay = {
              show: t.delay,
              hide: t.delay
          }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), l("tooltip", t, this.constructor.DefaultType), t.sanitize && (t.template = Re(t.template, t.allowList, t.sanitizeFn)), t
      }
      _getDelegateConfig() {
          const t = {};
          if (this._config)
              for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
          return t
      }
      _cleanTipClass() {
          const t = this.getTipElement(),
              e = t.getAttribute("class").match(Be);
          null !== e && e.length > 0 && e.map(t => t.trim()).forEach(e => t.classList.remove(e))
      }
      _handlePopperPlacementChange(t) {
          const {
              state: e
          } = t;
          e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)))
      }
      static jQueryInterface(t) {
          return this.each((function() {
              const e = Fe.getOrCreateInstance(this, t);
              if ("string" == typeof t) {
                  if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                  e[t]()
              }
          }))
      }
  }
  _(Fe);
  const Ve = new RegExp("(^|\\s)bs-popover\\S+", "g"),
      Ke = {
          ...Fe.Default,
          placement: "right",
          offset: [0, 8],
          trigger: "click",
          content: "",
          template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
      },
      Xe = {
          ...Fe.DefaultType,
          content: "(string|element|function)"
      },
      Ye = {
          HIDE: "hide.bs.popover",
          HIDDEN: "hidden.bs.popover",
          SHOW: "show.bs.popover",
          SHOWN: "shown.bs.popover",
          INSERTED: "inserted.bs.popover",
          CLICK: "click.bs.popover",
          FOCUSIN: "focusin.bs.popover",
          FOCUSOUT: "focusout.bs.popover",
          MOUSEENTER: "mouseenter.bs.popover",
          MOUSELEAVE: "mouseleave.bs.popover"
      };
  class Qe extends Fe {
      static get Default() {
          return Ke
      }
      static get NAME() {
          return "popover"
      }
      static get Event() {
          return Ye
      }
      static get DefaultType() {
          return Xe
      }
      isWithContent() {
          return this.getTitle() || this._getContent()
      }
      getTipElement() {
          return this.tip || (this.tip = super.getTipElement(), this.getTitle() || t.findOne(".popover-header", this.tip).remove(), this._getContent() || t.findOne(".popover-body", this.tip).remove()), this.tip
      }
      setContent() {
          const e = this.getTipElement();
          this.setElementContent(t.findOne(".popover-header", e), this.getTitle());
          let i = this._getContent();
          "function" == typeof i && (i = i.call(this._element)), this.setElementContent(t.findOne(".popover-body", e), i), e.classList.remove("fade", "show")
      }
      _addAttachmentClass(t) {
          this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(t))
      }
      _getContent() {
          return this._element.getAttribute("data-bs-content") || this._config.content
      }
      _cleanTipClass() {
          const t = this.getTipElement(),
              e = t.getAttribute("class").match(Ve);
          null !== e && e.length > 0 && e.map(t => t.trim()).forEach(e => t.classList.remove(e))
      }
      static jQueryInterface(t) {
          return this.each((function() {
              const e = Qe.getOrCreateInstance(this, t);
              if ("string" == typeof t) {
                  if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                  e[t]()
              }
          }))
      }
  }
  _(Qe);
  const Ge = {
          offset: 10,
          method: "auto",
          target: ""
      },
      Ze = {
          offset: "number",
          method: "string",
          target: "(string|element)"
      };
  class Je extends B {
      constructor(t, e) {
          super(t), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(e), this._selector = `${this._config.target} .nav-link, ${this._config.target} .list-group-item, ${this._config.target} .dropdown-item`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, P.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process()), this.refresh(), this._process()
      }
      static get Default() {
          return Ge
      }
      static get NAME() {
          return "scrollspy"
      }
      refresh() {
          const e = this._scrollElement === this._scrollElement.window ? "offset" : "position",
              i = "auto" === this._config.method ? e : this._config.method,
              s = "position" === i ? this._getScrollTop() : 0;
          this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), t.find(this._selector).map(e => {
              const o = n(e),
                  r = o ? t.findOne(o) : null;
              if (r) {
                  const t = r.getBoundingClientRect();
                  if (t.width || t.height) return [U[i](r).top + s, o]
              }
              return null
          }).filter(t => t).sort((t, e) => t[0] - e[0]).forEach(t => {
              this._offsets.push(t[0]), this._targets.push(t[1])
          })
      }
      dispose() {
          P.off(this._scrollElement, ".bs.scrollspy"), super.dispose()
      }
      _getConfig(t) {
          if ("string" != typeof(t = {
                  ...Ge,
                  ...U.getDataAttributes(this._element),
                  ..."object" == typeof t && t ? t : {}
              }).target && r(t.target)) {
              let {
                  id: i
              } = t.target;
              i || (i = e("scrollspy"), t.target.id = i), t.target = "#" + i
          }
          return l("scrollspy", t, Ze), t
      }
      _getScrollTop() {
          return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
      }
      _getScrollHeight() {
          return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
      }
      _getOffsetHeight() {
          return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
      }
      _process() {
          const t = this._getScrollTop() + this._config.offset,
              e = this._getScrollHeight(),
              i = this._config.offset + e - this._getOffsetHeight();
          if (this._scrollHeight !== e && this.refresh(), t >= i) {
              const t = this._targets[this._targets.length - 1];
              this._activeTarget !== t && this._activate(t)
          } else {
              if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();
              for (let e = this._offsets.length; e--;) this._activeTarget !== this._targets[e] && t >= this._offsets[e] && (void 0 === this._offsets[e + 1] || t < this._offsets[e + 1]) && this._activate(this._targets[e])
          }
      }
      _activate(e) {
          this._activeTarget = e, this._clear();
          const i = this._selector.split(",").map(t => `${t}[data-bs-target="${e}"],${t}[href="${e}"]`),
              n = t.findOne(i.join(","));
          n.classList.contains("dropdown-item") ? (t.findOne(".dropdown-toggle", n.closest(".dropdown")).classList.add("active"), n.classList.add("active")) : (n.classList.add("active"), t.parents(n, ".nav, .list-group").forEach(e => {
              t.prev(e, ".nav-link, .list-group-item").forEach(t => t.classList.add("active")), t.prev(e, ".nav-item").forEach(e => {
                  t.children(e, ".nav-link").forEach(t => t.classList.add("active"))
              })
          })), P.trigger(this._scrollElement, "activate.bs.scrollspy", {
              relatedTarget: e
          })
      }
      _clear() {
          t.find(this._selector).filter(t => t.classList.contains("active")).forEach(t => t.classList.remove("active"))
      }
      static jQueryInterface(t) {
          return this.each((function() {
              const e = Je.getOrCreateInstance(this, t);
              if ("string" == typeof t) {
                  if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                  e[t]()
              }
          }))
      }
  }
  P.on(window, "load.bs.scrollspy.data-api", () => {
      t.find('[data-bs-spy="scroll"]').forEach(t => new Je(t))
  }), _(Je);
  class ti extends B {
      static get NAME() {
          return "tab"
      }
      show() {
          if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active")) return;
          let e;
          const i = s(this._element),
              n = this._element.closest(".nav, .list-group");
          if (n) {
              const i = "UL" === n.nodeName || "OL" === n.nodeName ? ":scope > li > .active" : ".active";
              e = t.find(i, n), e = e[e.length - 1]
          }
          const o = e ? P.trigger(e, "hide.bs.tab", {
              relatedTarget: this._element
          }) : null;
          if (P.trigger(this._element, "show.bs.tab", {
                  relatedTarget: e
              }).defaultPrevented || null !== o && o.defaultPrevented) return;
          this._activate(this._element, n);
          const r = () => {
              P.trigger(e, "hidden.bs.tab", {
                  relatedTarget: this._element
              }), P.trigger(this._element, "shown.bs.tab", {
                  relatedTarget: e
              })
          };
          i ? this._activate(i, i.parentNode, r) : r()
      }
      _activate(e, i, n) {
          const s = (!i || "UL" !== i.nodeName && "OL" !== i.nodeName ? t.children(i, ".active") : t.find(":scope > li > .active", i))[0],
              o = n && s && s.classList.contains("fade"),
              r = () => this._transitionComplete(e, s, n);
          s && o ? (s.classList.remove("show"), this._queueCallback(r, e, !0)) : r()
      }
      _transitionComplete(e, i, n) {
          if (i) {
              i.classList.remove("active");
              const e = t.findOne(":scope > .dropdown-menu .active", i.parentNode);
              e && e.classList.remove("active"), "tab" === i.getAttribute("role") && i.setAttribute("aria-selected", !1)
          }
          e.classList.add("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !0), f(e), e.classList.contains("fade") && e.classList.add("show");
          let s = e.parentNode;
          if (s && "LI" === s.nodeName && (s = s.parentNode), s && s.classList.contains("dropdown-menu")) {
              const i = e.closest(".dropdown");
              i && t.find(".dropdown-toggle", i).forEach(t => t.classList.add("active")), e.setAttribute("aria-expanded", !0)
          }
          n && n()
      }
      static jQueryInterface(t) {
          return this.each((function() {
              const e = ti.getOrCreateInstance(this);
              if ("string" == typeof t) {
                  if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                  e[t]()
              }
          }))
      }
  }
  P.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function(t) {
      ["A", "AREA"].includes(this.tagName) && t.preventDefault(), h(this) || ti.getOrCreateInstance(this).show()
  })), _(ti);
  const ei = {
          animation: "boolean",
          autohide: "boolean",
          delay: "number"
      },
      ii = {
          animation: !0,
          autohide: !0,
          delay: 5e3
      };
  class ni extends B {
      constructor(t, e) {
          super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
      }
      static get DefaultType() {
          return ei
      }
      static get Default() {
          return ii
      }
      static get NAME() {
          return "toast"
      }
      show() {
          P.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove("hide"), f(this._element), this._element.classList.add("showing"), this._queueCallback(() => {
              this._element.classList.remove("showing"), this._element.classList.add("show"), P.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide()
          }, this._element, this._config.animation))
      }
      hide() {
          this._element.classList.contains("show") && (P.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.remove("show"), this._queueCallback(() => {
              this._element.classList.add("hide"), P.trigger(this._element, "hidden.bs.toast")
          }, this._element, this._config.animation)))
      }
      dispose() {
          this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), super.dispose()
      }
      _getConfig(t) {
          return t = {
              ...ii,
              ...U.getDataAttributes(this._element),
              ..."object" == typeof t && t ? t : {}
          }, l("toast", t, this.constructor.DefaultType), t
      }
      _maybeScheduleHide() {
          this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
              this.hide()
          }, this._config.delay)))
      }
      _onInteraction(t, e) {
          switch (t.type) {
              case "mouseover":
              case "mouseout":
                  this._hasMouseInteraction = e;
                  break;
              case "focusin":
              case "focusout":
                  this._hasKeyboardInteraction = e
          }
          if (e) return void this._clearTimeout();
          const i = t.relatedTarget;
          this._element === i || this._element.contains(i) || this._maybeScheduleHide()
      }
      _setListeners() {
          P.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', () => this.hide()), P.on(this._element, "mouseover.bs.toast", t => this._onInteraction(t, !0)), P.on(this._element, "mouseout.bs.toast", t => this._onInteraction(t, !1)), P.on(this._element, "focusin.bs.toast", t => this._onInteraction(t, !0)), P.on(this._element, "focusout.bs.toast", t => this._onInteraction(t, !1))
      }
      _clearTimeout() {
          clearTimeout(this._timeout), this._timeout = null
      }
      static jQueryInterface(t) {
          return this.each((function() {
              const e = ni.getOrCreateInstance(this, t);
              if ("string" == typeof t) {
                  if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                  e[t](this)
              }
          }))
      }
  }
  return _(ni), {
      Alert: W,
      Button: q,
      Carousel: Z,
      Collapse: et,
      Dropdown: Ae,
      Modal: De,
      Offcanvas: Ne,
      Popover: Qe,
      ScrollSpy: Je,
      Tab: ti,
      Toast: ni,
      Tooltip: Fe
  }
}));
//# sourceMappingURL=bootstrap.bundle.min.js.map
! function(i) {
  "use strict";
  "function" == typeof define && define.amd ? define(["jquery"], i) : "undefined" != typeof exports ? module.exports = i(require("jquery")) : i(jQuery)
}(function(i) {
  "use strict";
  var e = window.Slick || {};
  (e = function() {
      var e = 0;
      return function(t, o) {
          var s, n = this;
          n.defaults = {
              accessibility: !0,
              adaptiveHeight: !1,
              appendArrows: i(t),
              appendDots: i(t),
              arrows: !0,
              asNavFor: null,
              prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
              nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
              autoplay: !1,
              autoplaySpeed: 3e3,
              centerMode: !1,
              centerPadding: "50px",
              cssEase: "ease",
              customPaging: function(e, t) {
                  return i('<button type="button" />').text(t + 1)
              },
              dots: !1,
              dotsClass: "slick-dots",
              draggable: !0,
              easing: "linear",
              edgeFriction: .35,
              fade: !1,
              focusOnSelect: !1,
              focusOnChange: !1,
              infinite: !0,
              initialSlide: 0,
              lazyLoad: "ondemand",
              mobileFirst: !1,
              pauseOnHover: !0,
              pauseOnFocus: !0,
              pauseOnDotsHover: !1,
              respondTo: "window",
              responsive: null,
              rows: 1,
              rtl: !1,
              slide: "",
              slidesPerRow: 1,
              slidesToShow: 1,
              slidesToScroll: 1,
              speed: 500,
              swipe: !0,
              swipeToSlide: !1,
              touchMove: !0,
              touchThreshold: 5,
              useCSS: !0,
              useTransform: !0,
              variableWidth: !1,
              vertical: !1,
              verticalSwiping: !1,
              waitForAnimate: !0,
              zIndex: 1e3
          }, n.initials = {
              animating: !1,
              dragging: !1,
              autoPlayTimer: null,
              currentDirection: 0,
              currentLeft: null,
              currentSlide: 0,
              direction: 1,
              $dots: null,
              listWidth: null,
              listHeight: null,
              loadIndex: 0,
              $nextArrow: null,
              $prevArrow: null,
              scrolling: !1,
              slideCount: null,
              slideWidth: null,
              $slideTrack: null,
              $slides: null,
              sliding: !1,
              slideOffset: 0,
              swipeLeft: null,
              swiping: !1,
              $list: null,
              touchObject: {},
              transformsEnabled: !1,
              unslicked: !1
          }, i.extend(n, n.initials), n.activeBreakpoint = null, n.animType = null, n.animProp = null, n.breakpoints = [], n.breakpointSettings = [], n.cssTransitions = !1, n.focussed = !1, n.interrupted = !1, n.hidden = "hidden", n.paused = !0, n.positionProp = null, n.respondTo = null, n.rowCount = 1, n.shouldClick = !0, n.$slider = i(t), n.$slidesCache = null, n.transformType = null, n.transitionType = null, n.visibilityChange = "visibilitychange", n.windowWidth = 0, n.windowTimer = null, s = i(t).data("slick") || {}, n.options = i.extend({}, n.defaults, o, s), n.currentSlide = n.options.initialSlide, n.originalSettings = n.options, void 0 !== document.mozHidden ? (n.hidden = "mozHidden", n.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (n.hidden = "webkitHidden", n.visibilityChange = "webkitvisibilitychange"), n.autoPlay = i.proxy(n.autoPlay, n), n.autoPlayClear = i.proxy(n.autoPlayClear, n), n.autoPlayIterator = i.proxy(n.autoPlayIterator, n), n.changeSlide = i.proxy(n.changeSlide, n), n.clickHandler = i.proxy(n.clickHandler, n), n.selectHandler = i.proxy(n.selectHandler, n), n.setPosition = i.proxy(n.setPosition, n), n.swipeHandler = i.proxy(n.swipeHandler, n), n.dragHandler = i.proxy(n.dragHandler, n), n.keyHandler = i.proxy(n.keyHandler, n), n.instanceUid = e++, n.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, n.registerBreakpoints(), n.init(!0)
      }
  }()).prototype.activateADA = function() {
      this.$slideTrack.find(".slick-active").attr({
          "aria-hidden": "false"
      }).find("a, input, button, select").attr({
          tabindex: "0"
      })
  }, e.prototype.addSlide = e.prototype.slickAdd = function(e, t, o) {
      var s = this;
      if ("boolean" == typeof t) o = t, t = null;
      else if (t < 0 || t >= s.slideCount) return !1;
      s.unload(), "number" == typeof t ? 0 === t && 0 === s.$slides.length ? i(e).appendTo(s.$slideTrack) : o ? i(e).insertBefore(s.$slides.eq(t)) : i(e).insertAfter(s.$slides.eq(t)) : !0 === o ? i(e).prependTo(s.$slideTrack) : i(e).appendTo(s.$slideTrack), s.$slides = s.$slideTrack.children(this.options.slide), s.$slideTrack.children(this.options.slide).detach(), s.$slideTrack.append(s.$slides), s.$slides.each(function(e, t) {
          i(t).attr("data-slick-index", e)
      }), s.$slidesCache = s.$slides, s.reinit()
  }, e.prototype.animateHeight = function() {
      var i = this;
      if (1 === i.options.slidesToShow && !0 === i.options.adaptiveHeight && !1 === i.options.vertical) {
          var e = i.$slides.eq(i.currentSlide).outerHeight(!0);
          i.$list.animate({
              height: e
          }, i.options.speed)
      }
  }, e.prototype.animateSlide = function(e, t) {
      var o = {},
          s = this;
      s.animateHeight(), !0 === s.options.rtl && !1 === s.options.vertical && (e = -e), !1 === s.transformsEnabled ? !1 === s.options.vertical ? s.$slideTrack.animate({
          left: e
      }, s.options.speed, s.options.easing, t) : s.$slideTrack.animate({
          top: e
      }, s.options.speed, s.options.easing, t) : !1 === s.cssTransitions ? (!0 === s.options.rtl && (s.currentLeft = -s.currentLeft), i({
          animStart: s.currentLeft
      }).animate({
          animStart: e
      }, {
          duration: s.options.speed,
          easing: s.options.easing,
          step: function(i) {
              i = Math.ceil(i), !1 === s.options.vertical ? (o[s.animType] = "translate(" + i + "px, 0px)", s.$slideTrack.css(o)) : (o[s.animType] = "translate(0px," + i + "px)", s.$slideTrack.css(o))
          },
          complete: function() {
              t && t.call()
          }
      })) : (s.applyTransition(), e = Math.ceil(e), !1 === s.options.vertical ? o[s.animType] = "translate3d(" + e + "px, 0px, 0px)" : o[s.animType] = "translate3d(0px," + e + "px, 0px)", s.$slideTrack.css(o), t && setTimeout(function() {
          s.disableTransition(), t.call()
      }, s.options.speed))
  }, e.prototype.getNavTarget = function() {
      var e = this,
          t = e.options.asNavFor;
      return t && null !== t && (t = i(t).not(e.$slider)), t
  }, e.prototype.asNavFor = function(e) {
      var t = this.getNavTarget();
      null !== t && "object" == typeof t && t.each(function() {
          var t = i(this).slick("getSlick");
          t.unslicked || t.slideHandler(e, !0)
      })
  }, e.prototype.applyTransition = function(i) {
      var e = this,
          t = {};
      !1 === e.options.fade ? t[e.transitionType] = e.transformType + " " + e.options.speed + "ms " + e.options.cssEase : t[e.transitionType] = "opacity " + e.options.speed + "ms " + e.options.cssEase, !1 === e.options.fade ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t)
  }, e.prototype.autoPlay = function() {
      var i = this;
      i.autoPlayClear(), i.slideCount > i.options.slidesToShow && (i.autoPlayTimer = setInterval(i.autoPlayIterator, i.options.autoplaySpeed))
  }, e.prototype.autoPlayClear = function() {
      var i = this;
      i.autoPlayTimer && clearInterval(i.autoPlayTimer)
  }, e.prototype.autoPlayIterator = function() {
      var i = this,
          e = i.currentSlide + i.options.slidesToScroll;
      i.paused || i.interrupted || i.focussed || (!1 === i.options.infinite && (1 === i.direction && i.currentSlide + 1 === i.slideCount - 1 ? i.direction = 0 : 0 === i.direction && (e = i.currentSlide - i.options.slidesToScroll, i.currentSlide - 1 == 0 && (i.direction = 1))), i.slideHandler(e))
  }, e.prototype.buildArrows = function() {
      var e = this;
      !0 === e.options.arrows && (e.$prevArrow = i(e.options.prevArrow).addClass("slick-arrow"), e.$nextArrow = i(e.options.nextArrow).addClass("slick-arrow"), e.slideCount > e.options.slidesToShow ? (e.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.prependTo(e.options.appendArrows), e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.appendTo(e.options.appendArrows), !0 !== e.options.infinite && e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : e.$prevArrow.add(e.$nextArrow).addClass("slick-hidden").attr({
          "aria-disabled": "true",
          tabindex: "-1"
      }))
  }, e.prototype.buildDots = function() {
      var e, t, o = this;
      if (!0 === o.options.dots) {
          for (o.$slider.addClass("slick-dotted"), t = i("<ul />").addClass(o.options.dotsClass), e = 0; e <= o.getDotCount(); e += 1) t.append(i("<li />").append(o.options.customPaging.call(this, o, e)));
          o.$dots = t.appendTo(o.options.appendDots), o.$dots.find("li").first().addClass("slick-active")
      }
  }, e.prototype.buildOut = function() {
      var e = this;
      e.$slides = e.$slider.children(e.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), e.slideCount = e.$slides.length, e.$slides.each(function(e, t) {
          i(t).attr("data-slick-index", e).data("originalStyling", i(t).attr("style") || "")
      }), e.$slider.addClass("slick-slider"), e.$slideTrack = 0 === e.slideCount ? i('<div class="slick-track"/>').appendTo(e.$slider) : e.$slides.wrapAll('<div class="slick-track"/>').parent(), e.$list = e.$slideTrack.wrap('<div class="slick-list"/>').parent(), e.$slideTrack.css("opacity", 0), !0 !== e.options.centerMode && !0 !== e.options.swipeToSlide || (e.options.slidesToScroll = 1), i("img[data-lazy]", e.$slider).not("[src]").addClass("slick-loading"), e.setupInfinite(), e.buildArrows(), e.buildDots(), e.updateDots(), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), !0 === e.options.draggable && e.$list.addClass("draggable")
  }, e.prototype.buildRows = function() {
      var i, e, t, o, s, n, r, l = this;
      if (o = document.createDocumentFragment(), n = l.$slider.children(), l.options.rows > 1) {
          for (r = l.options.slidesPerRow * l.options.rows, s = Math.ceil(n.length / r), i = 0; i < s; i++) {
              var d = document.createElement("div");
              for (e = 0; e < l.options.rows; e++) {
                  var a = document.createElement("div");
                  for (t = 0; t < l.options.slidesPerRow; t++) {
                      var c = i * r + (e * l.options.slidesPerRow + t);
                      n.get(c) && a.appendChild(n.get(c))
                  }
                  d.appendChild(a)
              }
              o.appendChild(d)
          }
          l.$slider.empty().append(o), l.$slider.children().children().children().css({
              width: 100 / l.options.slidesPerRow + "%",
              display: "inline-block"
          })
      }
  }, e.prototype.checkResponsive = function(e, t) {
      var o, s, n, r = this,
          l = !1,
          d = r.$slider.width(),
          a = window.innerWidth || i(window).width();
      if ("window" === r.respondTo ? n = a : "slider" === r.respondTo ? n = d : "min" === r.respondTo && (n = Math.min(a, d)), r.options.responsive && r.options.responsive.length && null !== r.options.responsive) {
          s = null;
          for (o in r.breakpoints) r.breakpoints.hasOwnProperty(o) && (!1 === r.originalSettings.mobileFirst ? n < r.breakpoints[o] && (s = r.breakpoints[o]) : n > r.breakpoints[o] && (s = r.breakpoints[o]));
          null !== s ? null !== r.activeBreakpoint ? (s !== r.activeBreakpoint || t) && (r.activeBreakpoint = s, "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]), !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e)), l = s) : (r.activeBreakpoint = s, "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]), !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e)), l = s) : null !== r.activeBreakpoint && (r.activeBreakpoint = null, r.options = r.originalSettings, !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e), l = s), e || !1 === l || r.$slider.trigger("breakpoint", [r, l])
      }
  }, e.prototype.changeSlide = function(e, t) {
      var o, s, n, r = this,
          l = i(e.currentTarget);
      switch (l.is("a") && e.preventDefault(), l.is("li") || (l = l.closest("li")), n = r.slideCount % r.options.slidesToScroll != 0, o = n ? 0 : (r.slideCount - r.currentSlide) % r.options.slidesToScroll, e.data.message) {
          case "previous":
              s = 0 === o ? r.options.slidesToScroll : r.options.slidesToShow - o, r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide - s, !1, t);
              break;
          case "next":
              s = 0 === o ? r.options.slidesToScroll : o, r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide + s, !1, t);
              break;
          case "index":
              var d = 0 === e.data.index ? 0 : e.data.index || l.index() * r.options.slidesToScroll;
              r.slideHandler(r.checkNavigable(d), !1, t), l.children().trigger("focus");
              break;
          default:
              return
      }
  }, e.prototype.checkNavigable = function(i) {
      var e, t;
      if (e = this.getNavigableIndexes(), t = 0, i > e[e.length - 1]) i = e[e.length - 1];
      else
          for (var o in e) {
              if (i < e[o]) {
                  i = t;
                  break
              }
              t = e[o]
          }
      return i
  }, e.prototype.cleanUpEvents = function() {
      var e = this;
      e.options.dots && null !== e.$dots && (i("li", e.$dots).off("click.slick", e.changeSlide).off("mouseenter.slick", i.proxy(e.interrupt, e, !0)).off("mouseleave.slick", i.proxy(e.interrupt, e, !1)), !0 === e.options.accessibility && e.$dots.off("keydown.slick", e.keyHandler)), e.$slider.off("focus.slick blur.slick"), !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.$prevArrow && e.$prevArrow.off("click.slick", e.changeSlide), e.$nextArrow && e.$nextArrow.off("click.slick", e.changeSlide), !0 === e.options.accessibility && (e.$prevArrow && e.$prevArrow.off("keydown.slick", e.keyHandler), e.$nextArrow && e.$nextArrow.off("keydown.slick", e.keyHandler))), e.$list.off("touchstart.slick mousedown.slick", e.swipeHandler), e.$list.off("touchmove.slick mousemove.slick", e.swipeHandler), e.$list.off("touchend.slick mouseup.slick", e.swipeHandler), e.$list.off("touchcancel.slick mouseleave.slick", e.swipeHandler), e.$list.off("click.slick", e.clickHandler), i(document).off(e.visibilityChange, e.visibility), e.cleanUpSlideEvents(), !0 === e.options.accessibility && e.$list.off("keydown.slick", e.keyHandler), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().off("click.slick", e.selectHandler), i(window).off("orientationchange.slick.slick-" + e.instanceUid, e.orientationChange), i(window).off("resize.slick.slick-" + e.instanceUid, e.resize), i("[draggable!=true]", e.$slideTrack).off("dragstart", e.preventDefault), i(window).off("load.slick.slick-" + e.instanceUid, e.setPosition)
  }, e.prototype.cleanUpSlideEvents = function() {
      var e = this;
      e.$list.off("mouseenter.slick", i.proxy(e.interrupt, e, !0)), e.$list.off("mouseleave.slick", i.proxy(e.interrupt, e, !1))
  }, e.prototype.cleanUpRows = function() {
      var i, e = this;
      e.options.rows > 1 && ((i = e.$slides.children().children()).removeAttr("style"), e.$slider.empty().append(i))
  }, e.prototype.clickHandler = function(i) {
      !1 === this.shouldClick && (i.stopImmediatePropagation(), i.stopPropagation(), i.preventDefault())
  }, e.prototype.destroy = function(e) {
      var t = this;
      t.autoPlayClear(), t.touchObject = {}, t.cleanUpEvents(), i(".slick-cloned", t.$slider).detach(), t.$dots && t.$dots.remove(), t.$prevArrow && t.$prevArrow.length && (t.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.remove()), t.$nextArrow && t.$nextArrow.length && (t.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.remove()), t.$slides && (t.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function() {
          i(this).attr("style", i(this).data("originalStyling"))
      }), t.$slideTrack.children(this.options.slide).detach(), t.$slideTrack.detach(), t.$list.detach(), t.$slider.append(t.$slides)), t.cleanUpRows(), t.$slider.removeClass("slick-slider"), t.$slider.removeClass("slick-initialized"), t.$slider.removeClass("slick-dotted"), t.unslicked = !0, e || t.$slider.trigger("destroy", [t])
  }, e.prototype.disableTransition = function(i) {
      var e = this,
          t = {};
      t[e.transitionType] = "", !1 === e.options.fade ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t)
  }, e.prototype.fadeSlide = function(i, e) {
      var t = this;
      !1 === t.cssTransitions ? (t.$slides.eq(i).css({
          zIndex: t.options.zIndex
      }), t.$slides.eq(i).animate({
          opacity: 1
      }, t.options.speed, t.options.easing, e)) : (t.applyTransition(i), t.$slides.eq(i).css({
          opacity: 1,
          zIndex: t.options.zIndex
      }), e && setTimeout(function() {
          t.disableTransition(i), e.call()
      }, t.options.speed))
  }, e.prototype.fadeSlideOut = function(i) {
      var e = this;
      !1 === e.cssTransitions ? e.$slides.eq(i).animate({
          opacity: 0,
          zIndex: e.options.zIndex - 2
      }, e.options.speed, e.options.easing) : (e.applyTransition(i), e.$slides.eq(i).css({
          opacity: 0,
          zIndex: e.options.zIndex - 2
      }))
  }, e.prototype.filterSlides = e.prototype.slickFilter = function(i) {
      var e = this;
      null !== i && (e.$slidesCache = e.$slides, e.unload(), e.$slideTrack.children(this.options.slide).detach(), e.$slidesCache.filter(i).appendTo(e.$slideTrack), e.reinit())
  }, e.prototype.focusHandler = function() {
      var e = this;
      e.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", function(t) {
          t.stopImmediatePropagation();
          var o = i(this);
          setTimeout(function() {
              e.options.pauseOnFocus && (e.focussed = o.is(":focus"), e.autoPlay())
          }, 0)
      })
  }, e.prototype.getCurrent = e.prototype.slickCurrentSlide = function() {
      return this.currentSlide
  }, e.prototype.getDotCount = function() {
      var i = this,
          e = 0,
          t = 0,
          o = 0;
      if (!0 === i.options.infinite)
          if (i.slideCount <= i.options.slidesToShow) ++o;
          else
              for (; e < i.slideCount;) ++o, e = t + i.options.slidesToScroll, t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;
      else if (!0 === i.options.centerMode) o = i.slideCount;
      else if (i.options.asNavFor)
          for (; e < i.slideCount;) ++o, e = t + i.options.slidesToScroll, t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;
      else o = 1 + Math.ceil((i.slideCount - i.options.slidesToShow) / i.options.slidesToScroll);
      return o - 1
  }, e.prototype.getLeft = function(i) {
      var e, t, o, s, n = this,
          r = 0;
      return n.slideOffset = 0, t = n.$slides.first().outerHeight(!0), !0 === n.options.infinite ? (n.slideCount > n.options.slidesToShow && (n.slideOffset = n.slideWidth * n.options.slidesToShow * -1, s = -1, !0 === n.options.vertical && !0 === n.options.centerMode && (2 === n.options.slidesToShow ? s = -1.5 : 1 === n.options.slidesToShow && (s = -2)), r = t * n.options.slidesToShow * s), n.slideCount % n.options.slidesToScroll != 0 && i + n.options.slidesToScroll > n.slideCount && n.slideCount > n.options.slidesToShow && (i > n.slideCount ? (n.slideOffset = (n.options.slidesToShow - (i - n.slideCount)) * n.slideWidth * -1, r = (n.options.slidesToShow - (i - n.slideCount)) * t * -1) : (n.slideOffset = n.slideCount % n.options.slidesToScroll * n.slideWidth * -1, r = n.slideCount % n.options.slidesToScroll * t * -1))) : i + n.options.slidesToShow > n.slideCount && (n.slideOffset = (i + n.options.slidesToShow - n.slideCount) * n.slideWidth, r = (i + n.options.slidesToShow - n.slideCount) * t), n.slideCount <= n.options.slidesToShow && (n.slideOffset = 0, r = 0), !0 === n.options.centerMode && n.slideCount <= n.options.slidesToShow ? n.slideOffset = n.slideWidth * Math.floor(n.options.slidesToShow) / 2 - n.slideWidth * n.slideCount / 2 : !0 === n.options.centerMode && !0 === n.options.infinite ? n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2) - n.slideWidth : !0 === n.options.centerMode && (n.slideOffset = 0, n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2)), e = !1 === n.options.vertical ? i * n.slideWidth * -1 + n.slideOffset : i * t * -1 + r, !0 === n.options.variableWidth && (o = n.slideCount <= n.options.slidesToShow || !1 === n.options.infinite ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow), e = !0 === n.options.rtl ? o[0] ? -1 * (n.$slideTrack.width() - o[0].offsetLeft - o.width()) : 0 : o[0] ? -1 * o[0].offsetLeft : 0, !0 === n.options.centerMode && (o = n.slideCount <= n.options.slidesToShow || !1 === n.options.infinite ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow + 1), e = !0 === n.options.rtl ? o[0] ? -1 * (n.$slideTrack.width() - o[0].offsetLeft - o.width()) : 0 : o[0] ? -1 * o[0].offsetLeft : 0, e += (n.$list.width() - o.outerWidth()) / 2)), e
  }, e.prototype.getOption = e.prototype.slickGetOption = function(i) {
      return this.options[i]
  }, e.prototype.getNavigableIndexes = function() {
      var i, e = this,
          t = 0,
          o = 0,
          s = [];
      for (!1 === e.options.infinite ? i = e.slideCount : (t = -1 * e.options.slidesToScroll, o = -1 * e.options.slidesToScroll, i = 2 * e.slideCount); t < i;) s.push(t), t = o + e.options.slidesToScroll, o += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;
      return s
  }, e.prototype.getSlick = function() {
      return this
  }, e.prototype.getSlideCount = function() {
      var e, t, o = this;
      return t = !0 === o.options.centerMode ? o.slideWidth * Math.floor(o.options.slidesToShow / 2) : 0, !0 === o.options.swipeToSlide ? (o.$slideTrack.find(".slick-slide").each(function(s, n) {
          if (n.offsetLeft - t + i(n).outerWidth() / 2 > -1 * o.swipeLeft) return e = n, !1
      }), Math.abs(i(e).attr("data-slick-index") - o.currentSlide) || 1) : o.options.slidesToScroll
  }, e.prototype.goTo = e.prototype.slickGoTo = function(i, e) {
      this.changeSlide({
          data: {
              message: "index",
              index: parseInt(i)
          }
      }, e)
  }, e.prototype.init = function(e) {
      var t = this;
      i(t.$slider).hasClass("slick-initialized") || (i(t.$slider).addClass("slick-initialized"), t.buildRows(), t.buildOut(), t.setProps(), t.startLoad(), t.loadSlider(), t.initializeEvents(), t.updateArrows(), t.updateDots(), t.checkResponsive(!0), t.focusHandler()), e && t.$slider.trigger("init", [t]), !0 === t.options.accessibility && t.initADA(), t.options.autoplay && (t.paused = !1, t.autoPlay())
  }, e.prototype.initADA = function() {
      var e = this,
          t = Math.ceil(e.slideCount / e.options.slidesToShow),
          o = e.getNavigableIndexes().filter(function(i) {
              return i >= 0 && i < e.slideCount
          });
      e.$slides.add(e.$slideTrack.find(".slick-cloned")).attr({
          "aria-hidden": "true",
          tabindex: "-1"
      }).find("a, input, button, select").attr({
          tabindex: "-1"
      }), null !== e.$dots && (e.$slides.not(e.$slideTrack.find(".slick-cloned")).each(function(t) {
          var s = o.indexOf(t);
          i(this).attr({
              role: "tabpanel",
              id: "slick-slide" + e.instanceUid + t,
              tabindex: -1
          }), -1 !== s && i(this).attr({
              "aria-describedby": "slick-slide-control" + e.instanceUid + s
          })
      }), e.$dots.attr("role", "tablist").find("li").each(function(s) {
          var n = o[s];
          i(this).attr({
              role: "presentation"
          }), i(this).find("button").first().attr({
              role: "tab",
              id: "slick-slide-control" + e.instanceUid + s,
              "aria-controls": "slick-slide" + e.instanceUid + n,
              "aria-label": s + 1 + " of " + t,
              "aria-selected": null,
              tabindex: "-1"
          })
      }).eq(e.currentSlide).find("button").attr({
          "aria-selected": "true",
          tabindex: "0"
      }).end());
      for (var s = e.currentSlide, n = s + e.options.slidesToShow; s < n; s++) e.$slides.eq(s).attr("tabindex", 0);
      e.activateADA()
  }, e.prototype.initArrowEvents = function() {
      var i = this;
      !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.off("click.slick").on("click.slick", {
          message: "previous"
      }, i.changeSlide), i.$nextArrow.off("click.slick").on("click.slick", {
          message: "next"
      }, i.changeSlide), !0 === i.options.accessibility && (i.$prevArrow.on("keydown.slick", i.keyHandler), i.$nextArrow.on("keydown.slick", i.keyHandler)))
  }, e.prototype.initDotEvents = function() {
      var e = this;
      !0 === e.options.dots && (i("li", e.$dots).on("click.slick", {
          message: "index"
      }, e.changeSlide), !0 === e.options.accessibility && e.$dots.on("keydown.slick", e.keyHandler)), !0 === e.options.dots && !0 === e.options.pauseOnDotsHover && i("li", e.$dots).on("mouseenter.slick", i.proxy(e.interrupt, e, !0)).on("mouseleave.slick", i.proxy(e.interrupt, e, !1))
  }, e.prototype.initSlideEvents = function() {
      var e = this;
      e.options.pauseOnHover && (e.$list.on("mouseenter.slick", i.proxy(e.interrupt, e, !0)), e.$list.on("mouseleave.slick", i.proxy(e.interrupt, e, !1)))
  }, e.prototype.initializeEvents = function() {
      var e = this;
      e.initArrowEvents(), e.initDotEvents(), e.initSlideEvents(), e.$list.on("touchstart.slick mousedown.slick", {
          action: "start"
      }, e.swipeHandler), e.$list.on("touchmove.slick mousemove.slick", {
          action: "move"
      }, e.swipeHandler), e.$list.on("touchend.slick mouseup.slick", {
          action: "end"
      }, e.swipeHandler), e.$list.on("touchcancel.slick mouseleave.slick", {
          action: "end"
      }, e.swipeHandler), e.$list.on("click.slick", e.clickHandler), i(document).on(e.visibilityChange, i.proxy(e.visibility, e)), !0 === e.options.accessibility && e.$list.on("keydown.slick", e.keyHandler), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().on("click.slick", e.selectHandler), i(window).on("orientationchange.slick.slick-" + e.instanceUid, i.proxy(e.orientationChange, e)), i(window).on("resize.slick.slick-" + e.instanceUid, i.proxy(e.resize, e)), i("[draggable!=true]", e.$slideTrack).on("dragstart", e.preventDefault), i(window).on("load.slick.slick-" + e.instanceUid, e.setPosition), i(e.setPosition)
  }, e.prototype.initUI = function() {
      var i = this;
      !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.show(), i.$nextArrow.show()), !0 === i.options.dots && i.slideCount > i.options.slidesToShow && i.$dots.show()
  }, e.prototype.keyHandler = function(i) {
      var e = this;
      i.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === i.keyCode && !0 === e.options.accessibility ? e.changeSlide({
          data: {
              message: !0 === e.options.rtl ? "next" : "previous"
          }
      }) : 39 === i.keyCode && !0 === e.options.accessibility && e.changeSlide({
          data: {
              message: !0 === e.options.rtl ? "previous" : "next"
          }
      }))
  }, e.prototype.lazyLoad = function() {
      function e(e) {
          i("img[data-lazy]", e).each(function() {
              var e = i(this),
                  t = i(this).attr("data-lazy"),
                  o = i(this).attr("data-srcset"),
                  s = i(this).attr("data-sizes") || n.$slider.attr("data-sizes"),
                  r = document.createElement("img");
              r.onload = function() {
                  e.animate({
                      opacity: 0
                  }, 100, function() {
                      o && (e.attr("srcset", o), s && e.attr("sizes", s)), e.attr("src", t).animate({
                          opacity: 1
                      }, 200, function() {
                          e.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading")
                      }), n.$slider.trigger("lazyLoaded", [n, e, t])
                  })
              }, r.onerror = function() {
                  e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), n.$slider.trigger("lazyLoadError", [n, e, t])
              }, r.src = t
          })
      }
      var t, o, s, n = this;
      if (!0 === n.options.centerMode ? !0 === n.options.infinite ? s = (o = n.currentSlide + (n.options.slidesToShow / 2 + 1)) + n.options.slidesToShow + 2 : (o = Math.max(0, n.currentSlide - (n.options.slidesToShow / 2 + 1)), s = n.options.slidesToShow / 2 + 1 + 2 + n.currentSlide) : (o = n.options.infinite ? n.options.slidesToShow + n.currentSlide : n.currentSlide, s = Math.ceil(o + n.options.slidesToShow), !0 === n.options.fade && (o > 0 && o--, s <= n.slideCount && s++)), t = n.$slider.find(".slick-slide").slice(o, s), "anticipated" === n.options.lazyLoad)
          for (var r = o - 1, l = s, d = n.$slider.find(".slick-slide"), a = 0; a < n.options.slidesToScroll; a++) r < 0 && (r = n.slideCount - 1), t = (t = t.add(d.eq(r))).add(d.eq(l)), r--, l++;
      e(t), n.slideCount <= n.options.slidesToShow ? e(n.$slider.find(".slick-slide")) : n.currentSlide >= n.slideCount - n.options.slidesToShow ? e(n.$slider.find(".slick-cloned").slice(0, n.options.slidesToShow)) : 0 === n.currentSlide && e(n.$slider.find(".slick-cloned").slice(-1 * n.options.slidesToShow))
  }, e.prototype.loadSlider = function() {
      var i = this;
      i.setPosition(), i.$slideTrack.css({
          opacity: 1
      }), i.$slider.removeClass("slick-loading"), i.initUI(), "progressive" === i.options.lazyLoad && i.progressiveLazyLoad()
  }, e.prototype.next = e.prototype.slickNext = function() {
      this.changeSlide({
          data: {
              message: "next"
          }
      })
  }, e.prototype.orientationChange = function() {
      var i = this;
      i.checkResponsive(), i.setPosition()
  }, e.prototype.pause = e.prototype.slickPause = function() {
      var i = this;
      i.autoPlayClear(), i.paused = !0
  }, e.prototype.play = e.prototype.slickPlay = function() {
      var i = this;
      i.autoPlay(), i.options.autoplay = !0, i.paused = !1, i.focussed = !1, i.interrupted = !1
  }, e.prototype.postSlide = function(e) {
      var t = this;
      t.unslicked || (t.$slider.trigger("afterChange", [t, e]), t.animating = !1, t.slideCount > t.options.slidesToShow && t.setPosition(), t.swipeLeft = null, t.options.autoplay && t.autoPlay(), !0 === t.options.accessibility && (t.initADA(), t.options.focusOnChange && i(t.$slides.get(t.currentSlide)).attr("tabindex", 0).focus()))
  }, e.prototype.prev = e.prototype.slickPrev = function() {
      this.changeSlide({
          data: {
              message: "previous"
          }
      })
  }, e.prototype.preventDefault = function(i) {
      i.preventDefault()
  }, e.prototype.progressiveLazyLoad = function(e) {
      e = e || 1;
      var t, o, s, n, r, l = this,
          d = i("img[data-lazy]", l.$slider);
      d.length ? (t = d.first(), o = t.attr("data-lazy"), s = t.attr("data-srcset"), n = t.attr("data-sizes") || l.$slider.attr("data-sizes"), (r = document.createElement("img")).onload = function() {
          s && (t.attr("srcset", s), n && t.attr("sizes", n)), t.attr("src", o).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"), !0 === l.options.adaptiveHeight && l.setPosition(), l.$slider.trigger("lazyLoaded", [l, t, o]), l.progressiveLazyLoad()
      }, r.onerror = function() {
          e < 3 ? setTimeout(function() {
              l.progressiveLazyLoad(e + 1)
          }, 500) : (t.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), l.$slider.trigger("lazyLoadError", [l, t, o]), l.progressiveLazyLoad())
      }, r.src = o) : l.$slider.trigger("allImagesLoaded", [l])
  }, e.prototype.refresh = function(e) {
      var t, o, s = this;
      o = s.slideCount - s.options.slidesToShow, !s.options.infinite && s.currentSlide > o && (s.currentSlide = o), s.slideCount <= s.options.slidesToShow && (s.currentSlide = 0), t = s.currentSlide, s.destroy(!0), i.extend(s, s.initials, {
          currentSlide: t
      }), s.init(), e || s.changeSlide({
          data: {
              message: "index",
              index: t
          }
      }, !1)
  }, e.prototype.registerBreakpoints = function() {
      var e, t, o, s = this,
          n = s.options.responsive || null;
      if ("array" === i.type(n) && n.length) {
          s.respondTo = s.options.respondTo || "window";
          for (e in n)
              if (o = s.breakpoints.length - 1, n.hasOwnProperty(e)) {
                  for (t = n[e].breakpoint; o >= 0;) s.breakpoints[o] && s.breakpoints[o] === t && s.breakpoints.splice(o, 1), o--;
                  s.breakpoints.push(t), s.breakpointSettings[t] = n[e].settings
              } s.breakpoints.sort(function(i, e) {
              return s.options.mobileFirst ? i - e : e - i
          })
      }
  }, e.prototype.reinit = function() {
      var e = this;
      e.$slides = e.$slideTrack.children(e.options.slide).addClass("slick-slide"), e.slideCount = e.$slides.length, e.currentSlide >= e.slideCount && 0 !== e.currentSlide && (e.currentSlide = e.currentSlide - e.options.slidesToScroll), e.slideCount <= e.options.slidesToShow && (e.currentSlide = 0), e.registerBreakpoints(), e.setProps(), e.setupInfinite(), e.buildArrows(), e.updateArrows(), e.initArrowEvents(), e.buildDots(), e.updateDots(), e.initDotEvents(), e.cleanUpSlideEvents(), e.initSlideEvents(), e.checkResponsive(!1, !0), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().on("click.slick", e.selectHandler), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), e.setPosition(), e.focusHandler(), e.paused = !e.options.autoplay, e.autoPlay(), e.$slider.trigger("reInit", [e])
  }, e.prototype.resize = function() {
      var e = this;
      i(window).width() !== e.windowWidth && (clearTimeout(e.windowDelay), e.windowDelay = window.setTimeout(function() {
          e.windowWidth = i(window).width(), e.checkResponsive(), e.unslicked || e.setPosition()
      }, 50))
  }, e.prototype.removeSlide = e.prototype.slickRemove = function(i, e, t) {
      var o = this;
      if (i = "boolean" == typeof i ? !0 === (e = i) ? 0 : o.slideCount - 1 : !0 === e ? --i : i, o.slideCount < 1 || i < 0 || i > o.slideCount - 1) return !1;
      o.unload(), !0 === t ? o.$slideTrack.children().remove() : o.$slideTrack.children(this.options.slide).eq(i).remove(), o.$slides = o.$slideTrack.children(this.options.slide), o.$slideTrack.children(this.options.slide).detach(), o.$slideTrack.append(o.$slides), o.$slidesCache = o.$slides, o.reinit()
  }, e.prototype.setCSS = function(i) {
      var e, t, o = this,
          s = {};
      !0 === o.options.rtl && (i = -i), e = "left" == o.positionProp ? Math.ceil(i) + "px" : "0px", t = "top" == o.positionProp ? Math.ceil(i) + "px" : "0px", s[o.positionProp] = i, !1 === o.transformsEnabled ? o.$slideTrack.css(s) : (s = {}, !1 === o.cssTransitions ? (s[o.animType] = "translate(" + e + ", " + t + ")", o.$slideTrack.css(s)) : (s[o.animType] = "translate3d(" + e + ", " + t + ", 0px)", o.$slideTrack.css(s)))
  }, e.prototype.setDimensions = function() {
      var i = this;
      !1 === i.options.vertical ? !0 === i.options.centerMode && i.$list.css({
          padding: "0px " + i.options.centerPadding
      }) : (i.$list.height(i.$slides.first().outerHeight(!0) * i.options.slidesToShow), !0 === i.options.centerMode && i.$list.css({
          padding: i.options.centerPadding + " 0px"
      })), i.listWidth = i.$list.width(), i.listHeight = i.$list.height(), !1 === i.options.vertical && !1 === i.options.variableWidth ? (i.slideWidth = Math.ceil(i.listWidth / i.options.slidesToShow), i.$slideTrack.width(Math.ceil(i.slideWidth * i.$slideTrack.children(".slick-slide").length))) : !0 === i.options.variableWidth ? i.$slideTrack.width(5e3 * i.slideCount) : (i.slideWidth = Math.ceil(i.listWidth), i.$slideTrack.height(Math.ceil(i.$slides.first().outerHeight(!0) * i.$slideTrack.children(".slick-slide").length)));
      var e = i.$slides.first().outerWidth(!0) - i.$slides.first().width();
      !1 === i.options.variableWidth && i.$slideTrack.children(".slick-slide").width(i.slideWidth - e)
  }, e.prototype.setFade = function() {
      var e, t = this;
      t.$slides.each(function(o, s) {
          e = t.slideWidth * o * -1, !0 === t.options.rtl ? i(s).css({
              position: "relative",
              right: e,
              top: 0,
              zIndex: t.options.zIndex - 2,
              opacity: 0
          }) : i(s).css({
              position: "relative",
              left: e,
              top: 0,
              zIndex: t.options.zIndex - 2,
              opacity: 0
          })
      }), t.$slides.eq(t.currentSlide).css({
          zIndex: t.options.zIndex - 1,
          opacity: 1
      })
  }, e.prototype.setHeight = function() {
      var i = this;
      if (1 === i.options.slidesToShow && !0 === i.options.adaptiveHeight && !1 === i.options.vertical) {
          var e = i.$slides.eq(i.currentSlide).outerHeight(!0);
          i.$list.css("height", e)
      }
  }, e.prototype.setOption = e.prototype.slickSetOption = function() {
      var e, t, o, s, n, r = this,
          l = !1;
      if ("object" === i.type(arguments[0]) ? (o = arguments[0], l = arguments[1], n = "multiple") : "string" === i.type(arguments[0]) && (o = arguments[0], s = arguments[1], l = arguments[2], "responsive" === arguments[0] && "array" === i.type(arguments[1]) ? n = "responsive" : void 0 !== arguments[1] && (n = "single")), "single" === n) r.options[o] = s;
      else if ("multiple" === n) i.each(o, function(i, e) {
          r.options[i] = e
      });
      else if ("responsive" === n)
          for (t in s)
              if ("array" !== i.type(r.options.responsive)) r.options.responsive = [s[t]];
              else {
                  for (e = r.options.responsive.length - 1; e >= 0;) r.options.responsive[e].breakpoint === s[t].breakpoint && r.options.responsive.splice(e, 1), e--;
                  r.options.responsive.push(s[t])
              } l && (r.unload(), r.reinit())
  }, e.prototype.setPosition = function() {
      var i = this;
      i.setDimensions(), i.setHeight(), !1 === i.options.fade ? i.setCSS(i.getLeft(i.currentSlide)) : i.setFade(), i.$slider.trigger("setPosition", [i])
  }, e.prototype.setProps = function() {
      var i = this,
          e = document.body.style;
      i.positionProp = !0 === i.options.vertical ? "top" : "left", "top" === i.positionProp ? i.$slider.addClass("slick-vertical") : i.$slider.removeClass("slick-vertical"), void 0 === e.WebkitTransition && void 0 === e.MozTransition && void 0 === e.msTransition || !0 === i.options.useCSS && (i.cssTransitions = !0), i.options.fade && ("number" == typeof i.options.zIndex ? i.options.zIndex < 3 && (i.options.zIndex = 3) : i.options.zIndex = i.defaults.zIndex), void 0 !== e.OTransform && (i.animType = "OTransform", i.transformType = "-o-transform", i.transitionType = "OTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)), void 0 !== e.MozTransform && (i.animType = "MozTransform", i.transformType = "-moz-transform", i.transitionType = "MozTransition", void 0 === e.perspectiveProperty && void 0 === e.MozPerspective && (i.animType = !1)), void 0 !== e.webkitTransform && (i.animType = "webkitTransform", i.transformType = "-webkit-transform", i.transitionType = "webkitTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)), void 0 !== e.msTransform && (i.animType = "msTransform", i.transformType = "-ms-transform", i.transitionType = "msTransition", void 0 === e.msTransform && (i.animType = !1)), void 0 !== e.transform && !1 !== i.animType && (i.animType = "transform", i.transformType = "transform", i.transitionType = "transition"), i.transformsEnabled = i.options.useTransform && null !== i.animType && !1 !== i.animType
  }, e.prototype.setSlideClasses = function(i) {
      var e, t, o, s, n = this;
      if (t = n.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), n.$slides.eq(i).addClass("slick-current"), !0 === n.options.centerMode) {
          var r = n.options.slidesToShow % 2 == 0 ? 1 : 0;
          e = Math.floor(n.options.slidesToShow / 2), !0 === n.options.infinite && (i >= e && i <= n.slideCount - 1 - e ? n.$slides.slice(i - e + r, i + e + 1).addClass("slick-active").attr("aria-hidden", "false") : (o = n.options.slidesToShow + i, t.slice(o - e + 1 + r, o + e + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === i ? t.eq(t.length - 1 - n.options.slidesToShow).addClass("slick-center") : i === n.slideCount - 1 && t.eq(n.options.slidesToShow).addClass("slick-center")), n.$slides.eq(i).addClass("slick-center")
      } else i >= 0 && i <= n.slideCount - n.options.slidesToShow ? n.$slides.slice(i, i + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : t.length <= n.options.slidesToShow ? t.addClass("slick-active").attr("aria-hidden", "false") : (s = n.slideCount % n.options.slidesToShow, o = !0 === n.options.infinite ? n.options.slidesToShow + i : i, n.options.slidesToShow == n.options.slidesToScroll && n.slideCount - i < n.options.slidesToShow ? t.slice(o - (n.options.slidesToShow - s), o + s).addClass("slick-active").attr("aria-hidden", "false") : t.slice(o, o + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));
      "ondemand" !== n.options.lazyLoad && "anticipated" !== n.options.lazyLoad || n.lazyLoad()
  }, e.prototype.setupInfinite = function() {
      var e, t, o, s = this;
      if (!0 === s.options.fade && (s.options.centerMode = !1), !0 === s.options.infinite && !1 === s.options.fade && (t = null, s.slideCount > s.options.slidesToShow)) {
          for (o = !0 === s.options.centerMode ? s.options.slidesToShow + 1 : s.options.slidesToShow, e = s.slideCount; e > s.slideCount - o; e -= 1) t = e - 1, i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t - s.slideCount).prependTo(s.$slideTrack).addClass("slick-cloned");
          for (e = 0; e < o + s.slideCount; e += 1) t = e, i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t + s.slideCount).appendTo(s.$slideTrack).addClass("slick-cloned");
          s.$slideTrack.find(".slick-cloned").find("[id]").each(function() {
              i(this).attr("id", "")
          })
      }
  }, e.prototype.interrupt = function(i) {
      var e = this;
      i || e.autoPlay(), e.interrupted = i
  }, e.prototype.selectHandler = function(e) {
      var t = this,
          o = i(e.target).is(".slick-slide") ? i(e.target) : i(e.target).parents(".slick-slide"),
          s = parseInt(o.attr("data-slick-index"));
      s || (s = 0), t.slideCount <= t.options.slidesToShow ? t.slideHandler(s, !1, !0) : t.slideHandler(s)
  }, e.prototype.slideHandler = function(i, e, t) {
      var o, s, n, r, l, d = null,
          a = this;
      if (e = e || !1, !(!0 === a.animating && !0 === a.options.waitForAnimate || !0 === a.options.fade && a.currentSlide === i))
          if (!1 === e && a.asNavFor(i), o = i, d = a.getLeft(o), r = a.getLeft(a.currentSlide), a.currentLeft = null === a.swipeLeft ? r : a.swipeLeft, !1 === a.options.infinite && !1 === a.options.centerMode && (i < 0 || i > a.getDotCount() * a.options.slidesToScroll)) !1 === a.options.fade && (o = a.currentSlide, !0 !== t ? a.animateSlide(r, function() {
              a.postSlide(o)
          }) : a.postSlide(o));
          else if (!1 === a.options.infinite && !0 === a.options.centerMode && (i < 0 || i > a.slideCount - a.options.slidesToScroll)) !1 === a.options.fade && (o = a.currentSlide, !0 !== t ? a.animateSlide(r, function() {
          a.postSlide(o)
      }) : a.postSlide(o));
      else {
          if (a.options.autoplay && clearInterval(a.autoPlayTimer), s = o < 0 ? a.slideCount % a.options.slidesToScroll != 0 ? a.slideCount - a.slideCount % a.options.slidesToScroll : a.slideCount + o : o >= a.slideCount ? a.slideCount % a.options.slidesToScroll != 0 ? 0 : o - a.slideCount : o, a.animating = !0, a.$slider.trigger("beforeChange", [a, a.currentSlide, s]), n = a.currentSlide, a.currentSlide = s, a.setSlideClasses(a.currentSlide), a.options.asNavFor && (l = (l = a.getNavTarget()).slick("getSlick")).slideCount <= l.options.slidesToShow && l.setSlideClasses(a.currentSlide), a.updateDots(), a.updateArrows(), !0 === a.options.fade) return !0 !== t ? (a.fadeSlideOut(n), a.fadeSlide(s, function() {
              a.postSlide(s)
          })) : a.postSlide(s), void a.animateHeight();
          !0 !== t ? a.animateSlide(d, function() {
              a.postSlide(s)
          }) : a.postSlide(s)
      }
  }, e.prototype.startLoad = function() {
      var i = this;
      !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.hide(), i.$nextArrow.hide()), !0 === i.options.dots && i.slideCount > i.options.slidesToShow && i.$dots.hide(), i.$slider.addClass("slick-loading")
  }, e.prototype.swipeDirection = function() {
      var i, e, t, o, s = this;
      return i = s.touchObject.startX - s.touchObject.curX, e = s.touchObject.startY - s.touchObject.curY, t = Math.atan2(e, i), (o = Math.round(180 * t / Math.PI)) < 0 && (o = 360 - Math.abs(o)), o <= 45 && o >= 0 ? !1 === s.options.rtl ? "left" : "right" : o <= 360 && o >= 315 ? !1 === s.options.rtl ? "left" : "right" : o >= 135 && o <= 225 ? !1 === s.options.rtl ? "right" : "left" : !0 === s.options.verticalSwiping ? o >= 35 && o <= 135 ? "down" : "up" : "vertical"
  }, e.prototype.swipeEnd = function(i) {
      var e, t, o = this;
      if (o.dragging = !1, o.swiping = !1, o.scrolling) return o.scrolling = !1, !1;
      if (o.interrupted = !1, o.shouldClick = !(o.touchObject.swipeLength > 10), void 0 === o.touchObject.curX) return !1;
      if (!0 === o.touchObject.edgeHit && o.$slider.trigger("edge", [o, o.swipeDirection()]), o.touchObject.swipeLength >= o.touchObject.minSwipe) {
          switch (t = o.swipeDirection()) {
              case "left":
              case "down":
                  e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide + o.getSlideCount()) : o.currentSlide + o.getSlideCount(), o.currentDirection = 0;
                  break;
              case "right":
              case "up":
                  e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide - o.getSlideCount()) : o.currentSlide - o.getSlideCount(), o.currentDirection = 1
          }
          "vertical" != t && (o.slideHandler(e), o.touchObject = {}, o.$slider.trigger("swipe", [o, t]))
      } else o.touchObject.startX !== o.touchObject.curX && (o.slideHandler(o.currentSlide), o.touchObject = {})
  }, e.prototype.swipeHandler = function(i) {
      var e = this;
      if (!(!1 === e.options.swipe || "ontouchend" in document && !1 === e.options.swipe || !1 === e.options.draggable && -1 !== i.type.indexOf("mouse"))) switch (e.touchObject.fingerCount = i.originalEvent && void 0 !== i.originalEvent.touches ? i.originalEvent.touches.length : 1, e.touchObject.minSwipe = e.listWidth / e.options.touchThreshold, !0 === e.options.verticalSwiping && (e.touchObject.minSwipe = e.listHeight / e.options.touchThreshold), i.data.action) {
          case "start":
              e.swipeStart(i);
              break;
          case "move":
              e.swipeMove(i);
              break;
          case "end":
              e.swipeEnd(i)
      }
  }, e.prototype.swipeMove = function(i) {
      var e, t, o, s, n, r, l = this;
      return n = void 0 !== i.originalEvent ? i.originalEvent.touches : null, !(!l.dragging || l.scrolling || n && 1 !== n.length) && (e = l.getLeft(l.currentSlide), l.touchObject.curX = void 0 !== n ? n[0].pageX : i.clientX, l.touchObject.curY = void 0 !== n ? n[0].pageY : i.clientY, l.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(l.touchObject.curX - l.touchObject.startX, 2))), r = Math.round(Math.sqrt(Math.pow(l.touchObject.curY - l.touchObject.startY, 2))), !l.options.verticalSwiping && !l.swiping && r > 4 ? (l.scrolling = !0, !1) : (!0 === l.options.verticalSwiping && (l.touchObject.swipeLength = r), t = l.swipeDirection(), void 0 !== i.originalEvent && l.touchObject.swipeLength > 4 && (l.swiping = !0, i.preventDefault()), s = (!1 === l.options.rtl ? 1 : -1) * (l.touchObject.curX > l.touchObject.startX ? 1 : -1), !0 === l.options.verticalSwiping && (s = l.touchObject.curY > l.touchObject.startY ? 1 : -1), o = l.touchObject.swipeLength, l.touchObject.edgeHit = !1, !1 === l.options.infinite && (0 === l.currentSlide && "right" === t || l.currentSlide >= l.getDotCount() && "left" === t) && (o = l.touchObject.swipeLength * l.options.edgeFriction, l.touchObject.edgeHit = !0), !1 === l.options.vertical ? l.swipeLeft = e + o * s : l.swipeLeft = e + o * (l.$list.height() / l.listWidth) * s, !0 === l.options.verticalSwiping && (l.swipeLeft = e + o * s), !0 !== l.options.fade && !1 !== l.options.touchMove && (!0 === l.animating ? (l.swipeLeft = null, !1) : void l.setCSS(l.swipeLeft))))
  }, e.prototype.swipeStart = function(i) {
      var e, t = this;
      if (t.interrupted = !0, 1 !== t.touchObject.fingerCount || t.slideCount <= t.options.slidesToShow) return t.touchObject = {}, !1;
      void 0 !== i.originalEvent && void 0 !== i.originalEvent.touches && (e = i.originalEvent.touches[0]), t.touchObject.startX = t.touchObject.curX = void 0 !== e ? e.pageX : i.clientX, t.touchObject.startY = t.touchObject.curY = void 0 !== e ? e.pageY : i.clientY, t.dragging = !0
  }, e.prototype.unfilterSlides = e.prototype.slickUnfilter = function() {
      var i = this;
      null !== i.$slidesCache && (i.unload(), i.$slideTrack.children(this.options.slide).detach(), i.$slidesCache.appendTo(i.$slideTrack), i.reinit())
  }, e.prototype.unload = function() {
      var e = this;
      i(".slick-cloned", e.$slider).remove(), e.$dots && e.$dots.remove(), e.$prevArrow && e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.remove(), e.$nextArrow && e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.remove(), e.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "")
  }, e.prototype.unslick = function(i) {
      var e = this;
      e.$slider.trigger("unslick", [e, i]), e.destroy()
  }, e.prototype.updateArrows = function() {
      var i = this;
      Math.floor(i.options.slidesToShow / 2), !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && !i.options.infinite && (i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), i.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === i.currentSlide ? (i.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : i.currentSlide >= i.slideCount - i.options.slidesToShow && !1 === i.options.centerMode ? (i.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : i.currentSlide >= i.slideCount - 1 && !0 === i.options.centerMode && (i.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")))
  }, e.prototype.updateDots = function() {
      var i = this;
      null !== i.$dots && (i.$dots.find("li").removeClass("slick-active").end(), i.$dots.find("li").eq(Math.floor(i.currentSlide / i.options.slidesToScroll)).addClass("slick-active"))
  }, e.prototype.visibility = function() {
      var i = this;
      i.options.autoplay && (document[i.hidden] ? i.interrupted = !0 : i.interrupted = !1)
  }, i.fn.slick = function() {
      var i, t, o = this,
          s = arguments[0],
          n = Array.prototype.slice.call(arguments, 1),
          r = o.length;
      for (i = 0; i < r; i++)
          if ("object" == typeof s || void 0 === s ? o[i].slick = new e(o[i], s) : t = o[i].slick[s].apply(o[i].slick, n), void 0 !== t) return t;
      return o
  }
});

// @fancyapps/ui/Fancybox v4.0.0-beta.1
! function(t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).window = t.window || {})
}(this, (function(t) {
  "use strict";

  function e(t, e) {
      var i = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(t);
          e && (n = n.filter((function(e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable
          }))), i.push.apply(i, n)
      }
      return i
  }

  function i(t) {
      for (var i = 1; i < arguments.length; i++) {
          var n = null != arguments[i] ? arguments[i] : {};
          i % 2 ? e(Object(n), !0).forEach((function(e) {
              r(t, e, n[e])
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : e(Object(n)).forEach((function(e) {
              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
          }))
      }
      return t
  }

  function n(t) {
      return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
          return typeof t
      } : function(t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(t)
  }

  function o(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function a(t, e) {
      for (var i = 0; i < e.length; i++) {
          var n = e[i];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
      }
  }

  function s(t, e, i) {
      return e && a(t.prototype, e), i && a(t, i), t
  }

  function r(t, e, i) {
      return e in t ? Object.defineProperty(t, e, {
          value: i,
          enumerable: !0,
          configurable: !0,
          writable: !0
      }) : t[e] = i, t
  }

  function l(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
          constructor: {
              value: t,
              writable: !0,
              configurable: !0
          }
      }), e && h(t, e)
  }

  function c(t) {
      return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
          return t.__proto__ || Object.getPrototypeOf(t)
      })(t)
  }

  function h(t, e) {
      return (h = Object.setPrototypeOf || function(t, e) {
          return t.__proto__ = e, t
      })(t, e)
  }

  function d(t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
  }

  function u(t, e) {
      return !e || "object" != typeof e && "function" != typeof e ? d(t) : e
  }

  function f(t) {
      var e = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
          } catch (t) {
              return !1
          }
      }();
      return function() {
          var i, n = c(t);
          if (e) {
              var o = c(this).constructor;
              i = Reflect.construct(n, arguments, o)
          } else i = n.apply(this, arguments);
          return u(this, i)
      }
  }

  function v(t, e) {
      return function(t) {
          if (Array.isArray(t)) return t
      }(t) || function(t, e) {
          var i = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
          if (null == i) return;
          var n, o, a = [],
              s = !0,
              r = !1;
          try {
              for (i = i.call(t); !(s = (n = i.next()).done) && (a.push(n.value), !e || a.length !== e); s = !0);
          } catch (t) {
              r = !0, o = t
          } finally {
              try {
                  s || null == i.return || i.return()
              } finally {
                  if (r) throw o
              }
          }
          return a
      }(t, e) || g(t, e) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
      }()
  }

  function p(t) {
      return function(t) {
          if (Array.isArray(t)) return m(t)
      }(t) || function(t) {
          if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
      }(t) || g(t) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
      }()
  }

  function g(t, e) {
      if (t) {
          if ("string" == typeof t) return m(t, e);
          var i = Object.prototype.toString.call(t).slice(8, -1);
          return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? m(t, e) : void 0
      }
  }

  function m(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i];
      return n
  }

  function y(t, e) {
      var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
      if (!i) {
          if (Array.isArray(t) || (i = g(t)) || e && t && "number" == typeof t.length) {
              i && (t = i);
              var n = 0,
                  o = function() {};
              return {
                  s: o,
                  n: function() {
                      return n >= t.length ? {
                          done: !0
                      } : {
                          done: !1,
                          value: t[n++]
                      }
                  },
                  e: function(t) {
                      throw t
                  },
                  f: o
              }
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
      }
      var a, s = !0,
          r = !1;
      return {
          s: function() {
              i = i.call(t)
          },
          n: function() {
              var t = i.next();
              return s = t.done, t
          },
          e: function(t) {
              r = !0, a = t
          },
          f: function() {
              try {
                  s || null == i.return || i.return()
              } finally {
                  if (r) throw a
              }
          }
      }
  }
  var b = function(t) {
          return "object" === n(t) && null !== t && t.constructor === Object && "[object Object]" === Object.prototype.toString.call(t)
      },
      x = function t() {
          for (var e = !1, i = arguments.length, o = new Array(i), a = 0; a < i; a++) o[a] = arguments[a];
          "boolean" == typeof o[0] && (e = o.shift());
          var s = o[0];
          if (!s || "object" !== n(s)) throw new Error("extendee must be an object");
          for (var r = o.slice(1), l = r.length, c = 0; c < l; c++) {
              var h = r[c];
              for (var d in h)
                  if (h.hasOwnProperty(d)) {
                      var u = h[d];
                      if (e && (Array.isArray(u) || b(u))) {
                          var f = Array.isArray(u) ? [] : {};
                          s[d] = t(!0, s.hasOwnProperty(d) ? s[d] : f, u)
                      } else s[d] = u
                  }
          }
          return s
      },
      w = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e4;
          return t = parseFloat(t) || 0, Math.round((t + Number.EPSILON) * e) / e
      },
      k = "undefined" != typeof window && window.ResizeObserver || function() {
          function t(e) {
              o(this, t), this.observables = [], this.boundCheck = this.check.bind(this), this.boundCheck(), this.callback = e
          }
          return s(t, [{
              key: "observe",
              value: function(t) {
                  if (!this.observables.some((function(e) {
                          return e.el === t
                      }))) {
                      var e = {
                          el: t,
                          size: {
                              height: t.clientHeight,
                              width: t.clientWidth
                          }
                      };
                      this.observables.push(e)
                  }
              }
          }, {
              key: "unobserve",
              value: function(t) {
                  this.observables = this.observables.filter((function(e) {
                      return e.el !== t
                  }))
              }
          }, {
              key: "disconnect",
              value: function() {
                  this.observables = []
              }
          }, {
              key: "check",
              value: function() {
                  var t = this.observables.filter((function(t) {
                      var e = t.el.clientHeight,
                          i = t.el.clientWidth;
                      if (t.size.height !== e || t.size.width !== i) return t.size.height = e, t.size.width = i, !0
                  })).map((function(t) {
                      return t.el
                  }));
                  t.length > 0 && this.callback(t), window.requestAnimationFrame(this.boundCheck)
              }
          }]), t
      }(),
      S = function() {
          var t = window.getSelection ? window.getSelection() : document.selection;
          t && t.rangeCount && t.getRangeAt(0).getClientRects().length && (t.removeAllRanges ? t.removeAllRanges() : t.empty && t.empty())
      },
      $ = function t(e) {
          o(this, t), this.id = -1, this.id = e.pointerId || e.identifier || -1, this.pageX = e.pageX, this.pageY = e.pageY, this.clientX = e.clientX, this.clientY = e.clientY, this.nativePointer = e
      };

  function C(t, e) {
      return e ? Math.sqrt(Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)) : 0
  }

  function E(t, e) {
      return e ? {
          clientX: (t.clientX + e.clientX) / 2,
          clientY: (t.clientY + e.clientY) / 2
      } : t
  }
  var P = function() {
          function t(e) {
              var i = this,
                  n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                  a = n.start,
                  s = void 0 === a ? function() {
                      return !0
                  } : a,
                  r = n.move,
                  l = void 0 === r ? function() {} : r,
                  c = n.end,
                  h = void 0 === c ? function() {} : c;
              o(this, t), this.element = e, this.startPointers = [], this.currentPointers = [], this.startCallback = s, this.moveCallback = l, this.endCallback = h, this.onStart = function(t) {
                  if (!t.button || 0 === t.button) {
                      var e = new $(t);
                      if (!1 === i.startCallback(e, t)) return !1;
                      t.preventDefault(), S(), i.currentPointers.push(e), i.startPointers.push(e), (t.target && "setPointerCapture" in t.target ? t.target : i.element).setPointerCapture(t.pointerId), i.element.addEventListener("pointermove", i.onMove), i.element.addEventListener("pointerup", i.onEnd), i.element.addEventListener("pointercancel", i.onEnd)
                  }
              }, this.onMove = function(t) {
                  for (var e = i.currentPointers.slice(), n = [], o = function() {
                          var t = s[a],
                              e = i.currentPointers.findIndex((function(e) {
                                  return e.id === t.id
                              }));
                          if (e < 0) return "continue";
                          n.push(t), i.currentPointers[e] = t
                      }, a = 0, s = [new $(t)]; a < s.length; a++) o();
                  n.length && i.moveCallback(e, i.currentPointers, t)
              }, this.onEnd = function(t) {
                  var e = new $(t),
                      n = i.currentPointers.findIndex((function(t) {
                          return t.id === e.id
                      }));
                  if (-1 === n) return !1;
                  i.currentPointers.splice(n, 1), i.startPointers.splice(n, 1), i.endCallback(e, t), i.currentPointers.length || (i.element.removeEventListener("pointermove", i.onMove), i.element.removeEventListener("pointerup", i.onEnd), i.element.removeEventListener("pointercancel", i.onEnd))
              }, this.element.addEventListener("pointerdown", this.onStart)
          }
          return s(t, [{
              key: "stop",
              value: function() {
                  this.element.removeEventListener("pointerdown", this.onStart), this.element.removeEventListener("pointermove", this.onMove), this.element.removeEventListener("pointerup", this.onEnd), this.element.removeEventListener("pointercancel", this.onEnd)
              }
          }]), t
      }(),
      T = function t(e) {
          return !(!e || e === document.body) && (function(t) {
              var e = window.getComputedStyle(t)["overflow-y"],
                  i = window.getComputedStyle(t)["overflow-x"],
                  n = ("scroll" === e || "auto" === e) && Math.abs(t.scrollHeight - t.clientHeight) > 1,
                  o = ("scroll" === i || "auto" === i) && Math.abs(t.scrollWidth - t.clientWidth) > 1;
              return n || o
          }(e) ? e : t(e.parentNode))
      },
      L = function() {
          function t() {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              o(this, t), this.options = x(!0, {}, e), this.plugins = [], this.events = {};
              for (var i = 0, n = ["on", "once"]; i < n.length; i++)
                  for (var a = n[i], s = 0, r = Object.entries(this.options[a] || {}); s < r.length; s++) {
                      var l = r[s];
                      this[a].apply(this, p(l))
                  }
          }
          return s(t, [{
              key: "option",
              value: function(t, e) {
                  t = String(t);
                  var i, n, o = (i = t, n = this.options, i.split(".").reduce((function(t, e) {
                      return t && t[e]
                  }), n));
                  return "function" == typeof o && (o = o.call(this, t)), void 0 === o ? e : o
              }
          }, {
              key: "localize",
              value: function(t) {
                  var e = this,
                      i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                  return String(t).replace(/\{\{(\w+).?(\w+)?\}\}/g, (function(t, n, o) {
                      var a = !1;
                      if (!(a = o ? e.option("".concat(n[0] + n.toLowerCase().substring(1), ".l10n.").concat(o)) : e.option("l10n.".concat(n)))) return n;
                      for (var s = 0; s < i.length; s++) a = a.split(i[s][0]).join(i[s][1]);
                      return a
                  }))
              }
          }, {
              key: "on",
              value: function(t, e) {
                  var i = this;
                  if (b(t)) {
                      for (var n = 0, o = Object.entries(t); n < o.length; n++) {
                          var a = o[n];
                          this.on.apply(this, p(a))
                      }
                      return this
                  }
                  return String(t).split(" ").forEach((function(t) {
                      var n = i.events[t] = i.events[t] || []; - 1 == n.indexOf(e) && n.push(e)
                  })), this
              }
          }, {
              key: "once",
              value: function(t, e) {
                  var i = this;
                  if (b(t)) {
                      for (var n = 0, o = Object.entries(t); n < o.length; n++) {
                          var a = o[n];
                          this.once.apply(this, p(a))
                      }
                      return this
                  }
                  return String(t).split(" ").forEach((function(t) {
                      var n = function n() {
                          i.off(t, n);
                          for (var o = arguments.length, a = new Array(o), s = 0; s < o; s++) a[s] = arguments[s];
                          e.call.apply(e, [i, i].concat(a))
                      };
                      n._ = e, i.on(t, n)
                  })), this
              }
          }, {
              key: "off",
              value: function(t, e) {
                  var i = this;
                  if (!b(t)) return t.split(" ").forEach((function(t) {
                      var n = i.events[t];
                      if (!n || !n.length) return i;
                      for (var o = -1, a = 0, s = n.length; a < s; a++) {
                          var r = n[a];
                          if (r && (r === e || r._ === e)) {
                              o = a;
                              break
                          }
                      } - 1 != o && n.splice(o, 1)
                  })), this;
                  for (var n = 0, o = Object.entries(t); n < o.length; n++) {
                      var a = o[n];
                      this.off.apply(this, p(a))
                  }
              }
          }, {
              key: "trigger",
              value: function(t) {
                  for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) i[n - 1] = arguments[n];
                  var o, a = y(p(this.events[t] || []).slice());
                  try {
                      for (a.s(); !(o = a.n()).done;) {
                          var s = o.value;
                          if (s && !1 === s.call.apply(s, [this, this].concat(i))) return !1
                      }
                  } catch (t) {
                      a.e(t)
                  } finally {
                      a.f()
                  }
                  var r, l = y(p(this.events["*"] || []).slice());
                  try {
                      for (l.s(); !(r = l.n()).done;) {
                          var c = r.value;
                          if (c && !1 === c.call.apply(c, [this, t, this].concat(i))) return !1
                      }
                  } catch (t) {
                      l.e(t)
                  } finally {
                      l.f()
                  }
                  return !0
              }
          }, {
              key: "attachPlugins",
              value: function(t) {
                  for (var e = {}, i = 0, n = Object.entries(t || {}); i < n.length; i++) {
                      var o = v(n[i], 2),
                          a = o[0],
                          s = o[1];
                      !1 === this.options[a] || this.plugins[a] || (this.options[a] = x({}, s.defaults || {}, this.options[a]), e[a] = new s(this))
                  }
                  for (var r = 0, l = Object.entries(e); r < l.length; r++) {
                      var c = v(l[r], 2);
                      c[0], c[1].attach(this)
                  }
                  return this.plugins = Object.assign({}, this.plugins, e), this
              }
          }, {
              key: "detachPlugins",
              value: function() {
                  for (var t in this.plugins) {
                      var e = void 0;
                      (e = this.plugins[t]) && "function" == typeof e.detach && e.detach(this)
                  }
                  return this.plugins = {}, this
              }
          }]), t
      }(),
      A = {
          touch: !0,
          zoom: !0,
          pinchToZoom: !0,
          panOnlyZoomed: !1,
          lockAxis: !1,
          friction: .64,
          decelFriction: .88,
          zoomFriction: .74,
          bounceForce: .2,
          baseScale: 1,
          minScale: 1,
          maxScale: 2,
          step: .5,
          textSelection: !1,
          click: "toggleZoom",
          wheel: "zoom",
          wheelFactor: 42,
          wheelLimit: 5,
          draggableClass: "is-draggable",
          draggingClass: "is-dragging",
          ratio: 1
      },
      O = function(t) {
          l(n, t);
          var e = f(n);

          function n(t) {
              var i, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              o(this, n), (i = e.call(this, x(!0, {}, A, a))).state = "init", i.$container = t;
              for (var s = 0, r = ["onLoad", "onWheel", "onClick"]; s < r.length; s++) {
                  var l = r[s];
                  i[l] = i[l].bind(d(i))
              }
              return i.initLayout(), i.resetValues(), i.attachPlugins(n.Plugins), i.trigger("init"), i.updateMetrics(), i.attachEvents(), i.trigger("ready"), !1 === i.option("centerOnStart") ? (i.handleCursor(), i.state = "ready") : i.panTo({
                  friction: 0
              }), i
          }
          return s(n, [{
              key: "initLayout",
              value: function() {
                  var t = this.$container;
                  if (!(t instanceof HTMLElement)) throw new Error("Panzoom: Container not found");
                  var e = this.option("content") || t.querySelector(".panzoom__content");
                  if (!e) throw new Error("Panzoom: Content not found");
                  this.$content = e;
                  var i, n = this.option("viewport") || t.querySelector(".panzoom__viewport");
                  n || !1 === this.option("wrapInner") || ((n = document.createElement("div")).classList.add("panzoom__viewport"), (i = n).append.apply(i, p(t.childNodes)), t.appendChild(n));
                  this.$viewport = n || e.parentNode
              }
          }, {
              key: "resetValues",
              value: function() {
                  this.updateRate = this.option("updateRate", /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 250 : 24), this.container = {
                      width: 0,
                      height: 0
                  }, this.viewport = {
                      width: 0,
                      height: 0
                  }, this.content = {
                      origHeight: 0,
                      origWidth: 0,
                      width: 0,
                      height: 0,
                      x: this.option("x", 0),
                      y: this.option("y", 0),
                      scale: this.option("baseScale")
                  }, this.transform = {
                      x: 0,
                      y: 0,
                      scale: 1
                  }, this.resetDragPosition()
              }
          }, {
              key: "onLoad",
              value: function(t) {
                  this.updateMetrics(), this.panTo({
                      scale: this.option("baseScale"),
                      friction: 0
                  }), this.trigger("load", t)
              }
          }, {
              key: "onClick",
              value: function(t) {
                  if (!t.defaultPrevented)
                      if (this.option("textSelection") && window.getSelection().toString().length) t.stopPropagation();
                      else {
                          var e = this.$content.getClientRects()[0];
                          if ("ready" !== this.state && (this.dragPosition.midPoint || Math.abs(e.top - this.dragStart.rect.top) > 1 || Math.abs(e.left - this.dragStart.rect.left) > 1)) return t.preventDefault(), void t.stopPropagation();
                          !1 !== this.trigger("click", t) && this.option("zoom") && "toggleZoom" === this.option("click") && (t.preventDefault(), t.stopPropagation(), this.zoomWithClick(t))
                      }
              }
          }, {
              key: "onWheel",
              value: function(t) {
                  !1 !== this.trigger("wheel", t) && this.option("zoom") && this.option("wheel") && this.zoomWithWheel(t)
              }
          }, {
              key: "zoomWithWheel",
              value: function(t) {
                  void 0 === this.changedDelta && (this.changedDelta = 0);
                  var e = Math.max(-1, Math.min(1, -t.deltaY || -t.deltaX || t.wheelDelta || -t.detail)),
                      i = this.content.scale,
                      n = i * (100 + e * this.option("wheelFactor")) / 100;
                  if (e < 0 && Math.abs(i - this.option("minScale")) < .01 || e > 0 && Math.abs(i - this.option("maxScale")) < .01 ? (this.changedDelta += Math.abs(e), n = i) : (this.changedDelta = 0, n = Math.max(Math.min(n, this.option("maxScale")), this.option("minScale"))), !(this.changedDelta > this.option("wheelLimit")) && (t.preventDefault(), n !== i)) {
                      var o = this.$content.getBoundingClientRect(),
                          a = t.clientX - o.left,
                          s = t.clientY - o.top;
                      this.zoomTo(n, {
                          x: a,
                          y: s
                      })
                  }
              }
          }, {
              key: "zoomWithClick",
              value: function(t) {
                  var e = this.$content.getClientRects()[0],
                      i = t.clientX - e.left,
                      n = t.clientY - e.top;
                  this.toggleZoom({
                      x: i,
                      y: n
                  })
              }
          }, {
              key: "attachEvents",
              value: function() {
                  var t = this;
                  this.$content.addEventListener("load", this.onLoad), this.$container.addEventListener("wheel", this.onWheel, {
                      passive: !1
                  }), this.$container.addEventListener("click", this.onClick, {
                      passive: !1
                  }), this.initObserver();
                  var e = new P(this.$container, {
                      start: function(i, n) {
                          if (!t.option("touch")) return !1;
                          if (!(t.velocity.scale < 0)) {
                              if (!e.currentPointers.length) {
                                  if (-1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(n.target.nodeName)) return !1;
                                  if (t.option("textSelection") && function(t, e, i) {
                                          for (var n = t.childNodes, o = document.createRange(), a = 0; a < n.length; a++) {
                                              var s = n[a];
                                              if (s.nodeType === Node.TEXT_NODE) {
                                                  o.selectNodeContents(s);
                                                  var r = o.getBoundingClientRect();
                                                  if (e >= r.left && i >= r.top && e <= r.right && i <= r.bottom) return s
                                              }
                                          }
                                          return !1
                                      }(n.target, n.clientX, n.clientY)) return !1;
                                  if (T(n.target)) return !1
                              }
                              return !1 !== t.trigger("touchStart", n) && (t.state = "pointerdown", t.resetDragPosition(), t.dragPosition.midPoint = null, t.dragPosition.time = Date.now(), !0)
                          }
                      },
                      move: function(i, n, o) {
                          if ("pointerdown" === t.state)
                              if (0 != t.trigger("touchMove", o)) {
                                  if (!(n.length < 2 && t.transform.scale === t.option("baseScale") && 1 == t.option("panOnlyZoomed")) && (!(n.length > 1) || t.option("zoom") && !1 !== t.option("pinchToZoom"))) {
                                      o.preventDefault(), o.stopPropagation();
                                      var a = E(i[0], i[1]),
                                          s = E(n[0], n[1]),
                                          r = s.clientX - a.clientX,
                                          l = s.clientY - a.clientY,
                                          c = C(i[0], i[1]),
                                          h = C(n[0], n[1]),
                                          d = c ? h / c : 1;
                                      t.dragOffset.x += r, t.dragOffset.y += l, t.dragOffset.scale *= d, t.dragOffset.time = Date.now() - t.dragPosition.time;
                                      var u = 1 === t.dragStart.scale && t.option("lockAxis");
                                      if (u && !t.lockAxis) {
                                          if (Math.abs(t.dragOffset.x) < 6 && Math.abs(t.dragOffset.y) < 6) return;
                                          if ("xy" === u) {
                                              var f = Math.abs(180 * Math.atan2(t.dragOffset.y, t.dragOffset.x) / Math.PI);
                                              t.lockAxis = f > 45 && f < 135 ? "y" : "x"
                                          } else t.lockAxis = u
                                      }
                                      if (t.lockAxis && (t.dragOffset["x" === t.lockAxis ? "y" : "x"] = 0), t.$container.classList.add(t.option("draggingClass")), t.transform.scale === t.option("baseScale") && "y" === t.lockAxis || (t.dragPosition.x = t.dragStart.x + t.dragOffset.x), t.transform.scale === t.option("baseScale") && "x" === t.lockAxis || (t.dragPosition.y = t.dragStart.y + t.dragOffset.y), t.dragPosition.scale = t.dragStart.scale * t.dragOffset.scale, n.length > 1) {
                                          var v = E(e.startPointers[0], e.startPointers[1]),
                                              p = v.clientX - t.dragStart.rect.x,
                                              g = v.clientY - t.dragStart.rect.y,
                                              m = t.getZoomDelta(t.content.scale * t.dragOffset.scale, p, g),
                                              y = m.deltaX,
                                              b = m.deltaY;
                                          t.dragPosition.x -= y, t.dragPosition.y -= b, t.dragPosition.midPoint = s
                                      }
                                      t.setDragResistance(), t.transform = {
                                          x: t.dragPosition.x,
                                          y: t.dragPosition.y,
                                          scale: t.dragPosition.scale
                                      }, t.startAnimation()
                                  }
                              } else o.preventDefault()
                      },
                      end: function(n, o) {
                          if ("pointerdown" === t.state)
                              if (t._dragOffset = i({}, t.dragOffset), e.currentPointers.length) t.resetDragPosition();
                              else if (t.state = "decel", t.friction = t.option("decelFriction"), t.recalculateTransform(), t.$container.classList.remove(t.option("draggingClass")), !1 !== t.trigger("touchEnd", o) && "decel" === t.state) {
                              var a = t.option("minScale");
                              if (t.transform.scale < a) t.zoomTo(a, {
                                  friction: .64
                              });
                              else {
                                  var s = t.option("maxScale");
                                  if (t.transform.scale - s > .01) {
                                      var r = t.dragPosition.midPoint || n,
                                          l = t.$content.getClientRects()[0];
                                      t.zoomTo(s, {
                                          friction: .64,
                                          x: r.clientX - l.left,
                                          y: r.clientY - l.top
                                      })
                                  } else;
                              }
                          }
                      }
                  });
                  this.pointerTracker = e
              }
          }, {
              key: "initObserver",
              value: function() {
                  var t = this;
                  this.resizeObserver || (this.resizeObserver = new k((function() {
                      t.updateTimer || (t.updateTimer = setTimeout((function() {
                          var e = t.$container.getBoundingClientRect();
                          e.width && e.height ? ((Math.abs(e.width - t.container.width) > 1 || Math.abs(e.height - t.container.height) > 1) && (t.isAnimating() && t.endAnimation(), t.updateMetrics(), t.panTo({
                              x: t.content.x,
                              y: t.content.y,
                              scale: t.option("baseScale"),
                              friction: 0
                          })), t.updateTimer = null) : t.updateTimer = null
                      }), t.updateRate))
                  })), this.resizeObserver.observe(this.$container))
              }
          }, {
              key: "resetDragPosition",
              value: function() {
                  this.lockAxis = null, this.friction = this.option("friction"), this.velocity = {
                      x: 0,
                      y: 0,
                      scale: 0
                  };
                  var t = this.content,
                      e = t.x,
                      n = t.y,
                      o = t.scale;
                  this.dragStart = {
                      rect: this.$content.getBoundingClientRect(),
                      x: e,
                      y: n,
                      scale: o
                  }, this.dragPosition = i(i({}, this.dragPosition), {}, {
                      x: e,
                      y: n,
                      scale: o
                  }), this.dragOffset = {
                      x: 0,
                      y: 0,
                      scale: 1,
                      time: 0
                  }
              }
          }, {
              key: "updateMetrics",
              value: function(t) {
                  !0 !== t && this.trigger("beforeUpdate");
                  var e, n = this.$container,
                      o = this.$content,
                      a = this.$viewport,
                      s = this.$content instanceof HTMLImageElement,
                      r = this.option("zoom"),
                      l = this.option("resizeParent", r),
                      c = (e = this.$content, Math.max(parseFloat(e.naturalWidth || 0), parseFloat(e.width && e.width.baseVal && e.width.baseVal.value || 0), parseFloat(e.offsetWidth || 0), parseFloat(e.scrollWidth || 0))),
                      h = function(t) {
                          return Math.max(parseFloat(t.naturalHeight || 0), parseFloat(t.height && t.height.baseVal && t.height.baseVal.value || 0), parseFloat(t.offsetHeight || 0), parseFloat(t.scrollHeight || 0))
                      }(this.$content);
                  Object.assign(o.style, {
                      width: "",
                      height: "",
                      maxWidth: "",
                      maxHeight: ""
                  }), l && Object.assign(a.style, {
                      width: "",
                      height: ""
                  });
                  var d = this.option("ratio"),
                      u = c = w(c * d),
                      f = h = w(h * d),
                      v = o.getBoundingClientRect(),
                      p = a.getBoundingClientRect(),
                      g = a == n ? p : n.getBoundingClientRect();
                  this.viewport = i(i({}, this.viewport), {}, {
                      width: p.width,
                      height: p.height
                  });
                  var m = window.getComputedStyle(a);
                  if (this.viewport.width -= parseFloat(m.paddingLeft) + parseFloat(m.paddingRight), this.viewport.height -= parseFloat(m.paddingTop) + parseFloat(m.paddingBottom), r) {
                      if (Math.abs(c - v.width) > .1 || Math.abs(h - v.height) > .1) {
                          var y = function(t, e, i, n) {
                              var o = Math.min(i / t || 0, n / e);
                              return {
                                  width: t * o || 0,
                                  height: e * o || 0
                              }
                          }(c, h, Math.min(c, v.width), Math.min(h, v.height));
                          u = w(y.width), f = w(y.height)
                      }
                      Object.assign(o.style, {
                          width: "".concat(u, "px"),
                          height: "".concat(f, "px"),
                          transform: ""
                      })
                  }
                  if (l && (Object.assign(a.style, {
                          width: "".concat(u, "px"),
                          height: "".concat(f, "px")
                      }), this.viewport = i(i({}, this.viewport), {}, {
                          width: u,
                          height: f
                      })), s && r && "function" != typeof this.options.maxScale) {
                      var b = this.option("maxScale");
                      this.options.maxScale = function() {
                          return this.content.origWidth > 0 && this.content.fitWidth > 0 ? this.content.origWidth / this.content.fitWidth : b
                      }
                  }
                  this.content = i(i({}, this.content), {}, {
                      origWidth: c,
                      origHeight: h,
                      fitWidth: u,
                      fitHeight: f,
                      width: u,
                      height: f,
                      scale: 1,
                      isZoomable: r
                  }), this.container = {
                      width: g.width,
                      height: g.height
                  }, !0 !== t && this.trigger("afterUpdate")
              }
          }, {
              key: "zoomIn",
              value: function(t) {
                  this.zoomTo(this.content.scale + (t || this.option("step")))
              }
          }, {
              key: "zoomOut",
              value: function(t) {
                  this.zoomTo(this.content.scale - (t || this.option("step")))
              }
          }, {
              key: "toggleZoom",
              value: function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                      e = this.option("maxScale"),
                      i = this.option("baseScale"),
                      n = this.content.scale > i + .5 * (e - i) ? i : e;
                  this.zoomTo(n, t)
              }
          }, {
              key: "zoomTo",
              value: function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("baseScale"),
                      e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      i = e.x,
                      n = void 0 === i ? null : i,
                      o = e.y,
                      a = void 0 === o ? null : o;
                  t = Math.max(Math.min(t, this.option("maxScale")), this.option("minScale"));
                  var s = w(this.content.scale / (this.content.width / this.content.fitWidth), 1e7);
                  null === n && (n = this.content.width * s * .5), null === a && (a = this.content.height * s * .5);
                  var r = this.getZoomDelta(t, n, a),
                      l = r.deltaX,
                      c = r.deltaY;
                  n = this.content.x - l, a = this.content.y - c, this.panTo({
                      x: n,
                      y: a,
                      scale: t,
                      friction: this.option("zoomFriction")
                  })
              }
          }, {
              key: "getZoomDelta",
              value: function(t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                      n = this.content.fitWidth * this.content.scale,
                      o = this.content.fitHeight * this.content.scale,
                      a = e > 0 && n ? e / n : 0,
                      s = i > 0 && o ? i / o : 0,
                      r = this.content.fitWidth * t,
                      l = this.content.fitHeight * t,
                      c = (r - n) * a,
                      h = (l - o) * s;
                  return {
                      deltaX: c,
                      deltaY: h
                  }
              }
          }, {
              key: "panTo",
              value: function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                      e = t.x,
                      i = void 0 === e ? this.content.x : e,
                      n = t.y,
                      o = void 0 === n ? this.content.y : n,
                      a = t.scale,
                      s = t.friction,
                      r = void 0 === s ? this.option("friction") : s,
                      l = t.ignoreBounds,
                      c = void 0 !== l && l;
                  if (a = a || this.content.scale || 1, !c) {
                      var h = this.getBounds(a),
                          d = h.boundX,
                          u = h.boundY;
                      d && (i = Math.max(Math.min(i, d.to), d.from)), u && (o = Math.max(Math.min(o, u.to), u.from))
                  }
                  this.friction = r, this.transform = {
                      x: i,
                      y: o,
                      scale: a
                  }, r ? (this.state = "panning", this.velocity = {
                      x: (1 / this.friction - 1) * (i - this.content.x),
                      y: (1 / this.friction - 1) * (o - this.content.y),
                      scale: (1 / this.friction - 1) * (a - this.content.scale)
                  }, this.startAnimation()) : this.endAnimation()
              }
          }, {
              key: "startAnimation",
              value: function() {
                  var t = this;
                  this.rAF ? cancelAnimationFrame(this.rAF) : this.trigger("startAnimation"), this.rAF = requestAnimationFrame((function() {
                      return t.animate()
                  }))
              }
          }, {
              key: "animate",
              value: function() {
                  var t = this;
                  if (this.setEdgeForce(), this.setDragForce(), this.velocity.x *= this.friction, this.velocity.y *= this.friction, this.velocity.scale *= this.friction, this.content.x += this.velocity.x, this.content.y += this.velocity.y, this.content.scale += this.velocity.scale, this.isAnimating()) this.setTransform();
                  else if ("pointerdown" !== this.state) return this.endAnimation(), void this.trigger("endAnimation");
                  this.rAF = requestAnimationFrame((function() {
                      return t.animate()
                  }))
              }
          }, {
              key: "getBounds",
              value: function(t) {
                  var e = this.boundX,
                      i = this.boundY;
                  if (void 0 !== e && void 0 !== i) return {
                      boundX: e,
                      boundY: i
                  };
                  e = {
                      from: 0,
                      to: 0
                  }, i = {
                      from: 0,
                      to: 0
                  }, t = t || this.transform.scale;
                  var n = this.content.fitWidth,
                      o = this.content.fitHeight,
                      a = n * t,
                      s = o * t,
                      r = this.viewport.width,
                      l = this.viewport.height;
                  if (n <= r) {
                      var c = .5 * (r - a),
                          h = .5 * (a - n);
                      e.from = w(c - h), e.to = w(c + h)
                  } else e.from = w(r - a);
                  if (o <= l) {
                      var d = .5 * (l - s),
                          u = .5 * (s - o);
                      i.from = w(d - u), i.to = w(d + u)
                  } else i.from = w(l - a);
                  return {
                      boundX: e,
                      boundY: i
                  }
              }
          }, {
              key: "setEdgeForce",
              value: function() {
                  if ("decel" === this.state) {
                      var t, e, i, n, o = this.option("bounceForce"),
                          a = this.getBounds(Math.max(this.transform.scale, this.content.scale)),
                          s = a.boundX,
                          r = a.boundY;
                      if (s && (t = this.content.x < s.from, e = this.content.x > s.to), r && (i = this.content.y < r.from, n = this.content.y > r.to), t || e) {
                          var l = ((t ? s.from : s.to) - this.content.x) * o,
                              c = this.content.x + (this.velocity.x + l) / this.friction;
                          c >= s.from && c <= s.to && (l += this.velocity.x), this.velocity.x = l, this.recalculateTransform()
                      }
                      if (i || n) {
                          var h = ((i ? r.from : r.to) - this.content.y) * o,
                              d = this.content.y + (h + this.velocity.y) / this.friction;
                          d >= r.from && d <= r.to && (h += this.velocity.y), this.velocity.y = h, this.recalculateTransform()
                      }
                  }
              }
          }, {
              key: "setDragResistance",
              value: function() {
                  if ("pointerdown" === this.state) {
                      var t, e, i, n, o = this.getBounds(this.dragPosition.scale),
                          a = o.boundX,
                          s = o.boundY;
                      if (a && (t = this.dragPosition.x < a.from, e = this.dragPosition.x > a.to), s && (i = this.dragPosition.y < s.from, n = this.dragPosition.y > s.to), (t || e) && (!t || !e)) {
                          var r = t ? a.from : a.to,
                              l = r - this.dragPosition.x;
                          this.dragPosition.x = r - .3 * l
                      }
                      if ((i || n) && (!i || !n)) {
                          var c = i ? s.from : s.to,
                              h = c - this.dragPosition.y;
                          this.dragPosition.y = c - .3 * h
                      }
                  }
              }
          }, {
              key: "setDragForce",
              value: function() {
                  "pointerdown" === this.state && (this.velocity.x = this.dragPosition.x - this.content.x, this.velocity.y = this.dragPosition.y - this.content.y, this.velocity.scale = this.dragPosition.scale - this.content.scale)
              }
          }, {
              key: "recalculateTransform",
              value: function() {
                  this.transform.x = this.content.x + this.velocity.x / (1 / this.friction - 1), this.transform.y = this.content.y + this.velocity.y / (1 / this.friction - 1), this.transform.scale = this.content.scale + this.velocity.scale / (1 / this.friction - 1)
              }
          }, {
              key: "isAnimating",
              value: function() {
                  return !(!this.friction || !(Math.abs(this.velocity.x) > .05 || Math.abs(this.velocity.y) > .05 || Math.abs(this.velocity.scale) > .05))
              }
          }, {
              key: "setTransform",
              value: function(t) {
                  var e, n, o, a, s;
                  (t ? (e = w(this.transform.x), n = w(this.transform.y), o = this.transform.scale, this.content = i(i({}, this.content), {}, {
                      x: e,
                      y: n,
                      scale: o
                  })) : (e = w(this.content.x), n = w(this.content.y), o = this.content.scale / (this.content.width / this.content.fitWidth), this.content = i(i({}, this.content), {}, {
                      x: e,
                      y: n
                  })), this.trigger("beforeTransform"), e = w(this.content.x), n = w(this.content.y), t && this.option("zoom")) ? (a = w(this.content.fitWidth * o), s = w(this.content.fitHeight * o), this.content.width = a, this.content.height = s, this.transform = i(i({}, this.transform), {}, {
                      width: a,
                      height: s,
                      scale: o
                  }), Object.assign(this.$content.style, {
                      width: "".concat(a, "px"),
                      height: "".concat(s, "px"),
                      maxWidth: "none",
                      maxHeight: "none",
                      transform: "translate3d(".concat(e, "px, ").concat(n, "px, 0) scale(1)")
                  })) : this.$content.style.transform = "translate3d(".concat(e, "px, ").concat(n, "px, 0) scale(").concat(o, ")");
                  this.trigger("afterTransform")
              }
          }, {
              key: "endAnimation",
              value: function() {
                  cancelAnimationFrame(this.rAF), this.rAF = null, this.velocity = {
                      x: 0,
                      y: 0,
                      scale: 0
                  }, this.setTransform(!0), this.state = "ready", this.handleCursor()
              }
          }, {
              key: "handleCursor",
              value: function() {
                  var t = this.option("draggableClass");
                  t && this.option("touch") && (1 == this.option("panOnlyZoomed") && this.content.width <= this.content.fitWidth && this.transform.scale <= this.option("baseScale") ? this.$container.classList.remove(t) : this.$container.classList.add(t))
              }
          }, {
              key: "detachEvents",
              value: function() {
                  this.$content.removeEventListener("load", this.onLoad), this.$container.removeEventListener("wheel", this.onWheel, {
                      passive: !1
                  }), this.$container.removeEventListener("click", this.onClick, {
                      passive: !1
                  }), this.pointerTracker && (this.pointerTracker.stop(), this.pointerTracker = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null)
              }
          }, {
              key: "destroy",
              value: function() {
                  "destroy" !== this.state && (this.state = "destroy", clearTimeout(this.updateTimer), this.updateTimer = null, cancelAnimationFrame(this.rAF), this.rAF = null, this.detachEvents(), this.detachPlugins(), this.resetDragPosition())
              }
          }]), n
      }(L);
  O.version = "4.0.0-beta.1", O.Plugins = {};
  var z = function(t, e) {
          var i = 0;
          return function() {
              var n = (new Date).getTime();
              if (!(n - i < e)) return i = n, t.apply(void 0, arguments)
          }
      },
      _ = function() {
          function t(e) {
              o(this, t), this.$container = null, this.$prev = null, this.$next = null, this.carousel = e, this.onRefresh = this.onRefresh.bind(this)
          }
          return s(t, [{
              key: "option",
              value: function(t) {
                  return this.carousel.option("Navigation.".concat(t))
              }
          }, {
              key: "createButton",
              value: function(t) {
                  var e, i = this,
                      n = document.createElement("button");
                  n.setAttribute("title", this.carousel.localize("{{".concat(t.toUpperCase(), "}}")));
                  var o = this.option("classNames.button") + " " + this.option("classNames.".concat(t));
                  return (e = n.classList).add.apply(e, p(o.split(" "))), n.setAttribute("tabindex", "0"), n.innerHTML = this.carousel.localize(this.option("".concat(t, "Tpl"))), n.addEventListener("click", (function(e) {
                      e.preventDefault(), e.stopPropagation(), i.carousel["slide".concat("next" === t ? "Next" : "Prev")]()
                  })), n
              }
          }, {
              key: "build",
              value: function() {
                  this.$container || (this.$container = document.createElement("div"), this.$container.classList.add(this.option("classNames.main")), this.carousel.$container.appendChild(this.$container)), this.$next || (this.$next = this.createButton("next"), this.$container.appendChild(this.$next)), this.$prev || (this.$prev = this.createButton("prev"), this.$container.appendChild(this.$prev))
              }
          }, {
              key: "onRefresh",
              value: function() {
                  var t = this.carousel.pages.length;
                  t <= 1 || t > 1 && this.carousel.elemDimWidth < this.carousel.wrapDimWidth && !Number.isInteger(this.carousel.option("slidesPerPage")) ? this.cleanup() : (this.build(), this.$prev.removeAttribute("disabled"), this.$next.removeAttribute("disabled"), this.carousel.option("infiniteX", this.carousel.option("infinite")) || (this.carousel.page <= 0 && this.$prev.setAttribute("disabled", ""), this.carousel.page >= t - 1 && this.$next.setAttribute("disabled", "")))
              }
          }, {
              key: "cleanup",
              value: function() {
                  this.$prev && this.$prev.remove(), this.$prev = null, this.$next && this.$next.remove(), this.$next = null, this.$container && this.$container.remove(), this.$container = null
              }
          }, {
              key: "attach",
              value: function() {
                  this.carousel.on("refresh change", this.onRefresh)
              }
          }, {
              key: "detach",
              value: function() {
                  this.carousel.off("refresh change", this.onRefresh), this.cleanup()
              }
          }]), t
      }();
  _.defaults = {
      prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>',
      nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',
      classNames: {
          main: "carousel__nav",
          button: "carousel__button",
          next: "is-next",
          prev: "is-prev"
      }
  };
  var I = function() {
          function t(e) {
              o(this, t), this.carousel = e, this.$list = null, this.events = {
                  change: this.onChange.bind(this),
                  refresh: this.onRefresh.bind(this)
              }
          }
          return s(t, [{
              key: "buildList",
              value: function() {
                  var t = this;
                  if (!(this.carousel.pages.length < 2)) {
                      var e = document.createElement("ol");
                      return e.classList.add("carousel__dots"), e.addEventListener("click", (function(e) {
                          if ("page" in e.target.dataset) {
                              e.preventDefault(), e.stopPropagation();
                              var i = parseInt(e.target.dataset.page, 10),
                                  n = t.carousel;
                              i !== n.page && (n.pages.length < 3 && n.option("infinite") ? n[0 == i ? "slidePrev" : "slideNext"]() : n.slideTo(i))
                          }
                      })), this.$list = e, this.carousel.$container.appendChild(e), this.carousel.$container.classList.add("has-dots"), e
                  }
              }
          }, {
              key: "removeList",
              value: function() {
                  this.$list && (this.$list.parentNode.removeChild(this.$list), this.$list = null), this.carousel.$container.classList.remove("has-dots")
              }
          }, {
              key: "rebuildDots",
              value: function() {
                  var t = this,
                      e = this.$list,
                      i = !!e,
                      n = this.carousel.pages.length;
                  if (n < 2) i && this.removeList();
                  else {
                      i || (e = this.buildList());
                      var o = this.$list.children.length;
                      if (o > n)
                          for (var a = n; a < o; a++) this.$list.removeChild(this.$list.lastChild);
                      else {
                          for (var s = function(e) {
                                  var i = document.createElement("li");
                                  i.classList.add("carousel__dot"), i.dataset.page = e, i.setAttribute("role", "button"), i.setAttribute("tabindex", "0"), i.setAttribute("title", t.carousel.localize("{{GOTO}}", [
                                      ["%d", e + 1]
                                  ])), i.addEventListener("keydown", (function(t) {
                                      var e, n = t.code;
                                      "Enter" === n || "NumpadEnter" === n ? e = i : "ArrowRight" === n ? e = i.nextSibling : "ArrowLeft" === n && (e = i.previousSibling), e && e.click()
                                  })), t.$list.appendChild(i)
                              }, r = o; r < n; r++) s(r);
                          this.setActiveDot()
                      }
                  }
              }
          }, {
              key: "setActiveDot",
              value: function() {
                  if (this.$list) {
                      this.$list.childNodes.forEach((function(t) {
                          t.classList.remove("is-selected")
                      }));
                      var t = this.$list.childNodes[this.carousel.page];
                      t && t.classList.add("is-selected")
                  }
              }
          }, {
              key: "onChange",
              value: function() {
                  this.setActiveDot()
              }
          }, {
              key: "onRefresh",
              value: function() {
                  this.rebuildDots()
              }
          }, {
              key: "attach",
              value: function() {
                  this.carousel.on(this.events)
              }
          }, {
              key: "detach",
              value: function() {
                  this.removeList(), this.carousel.off(this.events), this.carousel = null
              }
          }]), t
      }(),
      M = function() {
          function t(e) {
              o(this, t), this.carousel = e, this.selectedIndex = null, this.friction = 0, this.onNavReady = this.onNavReady.bind(this), this.onNavClick = this.onNavClick.bind(this), this.onNavCreateSlide = this.onNavCreateSlide.bind(this), this.onTargetChange = this.onTargetChange.bind(this)
          }
          return s(t, [{
              key: "addAsTargetFor",
              value: function(t) {
                  this.target = this.carousel, this.nav = t, this.attachEvents()
              }
          }, {
              key: "addAsNavFor",
              value: function(t) {
                  this.target = t, this.nav = this.carousel, this.attachEvents()
              }
          }, {
              key: "attachEvents",
              value: function() {
                  this.nav.options.initialSlide = this.target.options.initialPage, this.nav.on("ready", this.onNavReady), this.nav.on("createSlide", this.onNavCreateSlide), this.nav.on("Panzoom.click", this.onNavClick), this.target.on("change", this.onTargetChange), this.target.on("Panzoom.afterUpdate", this.onTargetChange)
              }
          }, {
              key: "onNavReady",
              value: function() {
                  this.onTargetChange(!0)
              }
          }, {
              key: "onNavClick",
              value: function(t, e, i) {
                  var n = i.target.closest(".carousel__slide");
                  if (n) {
                      i.stopPropagation();
                      var o = parseInt(n.dataset.index, 10),
                          a = this.target.findPageForSlide(o);
                      this.target.page !== a && this.target.slideTo(a, {
                          friction: this.friction
                      }), this.markSelectedSlide(o)
                  }
              }
          }, {
              key: "onNavCreateSlide",
              value: function(t, e) {
                  e.index === this.selectedIndex && this.markSelectedSlide(e.index)
              }
          }, {
              key: "onTargetChange",
              value: function() {
                  var t = this.target.pages[this.target.page].indexes[0],
                      e = this.nav.findPageForSlide(t);
                  this.nav.slideTo(e), this.markSelectedSlide(t)
              }
          }, {
              key: "markSelectedSlide",
              value: function(t) {
                  this.selectedIndex = t, p(this.nav.slides).filter((function(t) {
                      return t.$el && t.$el.classList.remove("is-nav-selected")
                  }));
                  var e = this.nav.slides[t];
                  e && e.$el && e.$el.classList.add("is-nav-selected")
              }
          }, {
              key: "attach",
              value: function(t) {
                  var e = t.options.Sync;
                  (e.target || e.nav) && (e.target ? this.addAsNavFor(e.target) : e.nav && this.addAsTargetFor(e.nav), this.friction = e.friction)
              }
          }, {
              key: "detach",
              value: function() {
                  this.nav && (this.nav.off("ready", this.onNavReady), this.nav.off("Panzoom.click", this.onNavClick), this.nav.off("createSlide", this.onNavCreateSlide)), this.target && (this.target.off("Panzoom.afterUpdate", this.onTargetChange), this.target.off("change", this.onTargetChange))
              }
          }]), t
      }();
  M.defaults = {
      friction: .92
  };
  var R = {
          Navigation: _,
          Dots: I,
          Sync: M
      },
      F = {
          slides: [],
          preload: 0,
          slidesPerPage: "auto",
          initialPage: null,
          initialSlide: null,
          friction: .92,
          center: !0,
          infinite: !0,
          fill: !0,
          dragFree: !1,
          classNames: {
              viewport: "carousel__viewport",
              track: "carousel__track",
              slide: "carousel__slide",
              slideSelected: "is-selected"
          },
          l10n: {
              NEXT: "Next slide",
              PREV: "Previous slide",
              GOTO: "Go to slide %d"
          }
      },
      N = function(t) {
          l(n, t);
          var e = f(n);

          function n(t) {
              var i, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              if (o(this, n), a = x(!0, {}, F, a), (i = e.call(this, a)).state = "init", i.$container = t, !(i.$container instanceof HTMLElement)) throw new Error("No root element provided");
              return i.slideNext = z(i.slideNext.bind(d(i)), 250), i.slidePrev = z(i.slidePrev.bind(d(i)), 250), i.init(), i
          }
          return s(n, [{
              key: "init",
              value: function() {
                  this.pages = [], this.page = this.pageIndex = null, this.prevPage = this.prevPageIndex = null, this.attachPlugins(n.Plugins), this.trigger("init"), this.initLayout(), this.initSlides(), this.updateMetrics(), this.$track.style.transform = "translate3d(".concat(-1 * this.pages[this.page].left, "px, 0px, 0) scale(1)"), this.manageSlideVisiblity(), this.initPanzoom(), this.state = "ready", this.trigger("ready")
              }
          }, {
              key: "initLayout",
              value: function() {
                  var t, e, i = this.option("classNames");
                  (this.$viewport = this.option("viewport") || this.$container.querySelector("." + i.viewport), this.$viewport) || (this.$viewport = document.createElement("div"), this.$viewport.classList.add(i.viewport), (t = this.$viewport).append.apply(t, p(this.$container.childNodes)), this.$container.appendChild(this.$viewport));
                  (this.$track = this.option("track") || this.$container.querySelector("." + i.track), this.$track) || (this.$track = document.createElement("div"), this.$track.classList.add(i.track), (e = this.$track).append.apply(e, p(this.$viewport.childNodes)), this.$viewport.appendChild(this.$track))
              }
          }, {
              key: "initSlides",
              value: function() {
                  var t = this;
                  this.slides = [], this.$viewport.querySelectorAll("." + this.option("classNames.slide")).forEach((function(e) {
                      var i = {
                          $el: e,
                          isDom: !0
                      };
                      t.slides.push(i), t.trigger("createSlide", i, t.slides.length)
                  })), Array.isArray(this.options.slides) && (this.slides = x(!0, p(this.slides), this.options.slides))
              }
          }, {
              key: "updateMetrics",
              value: function() {
                  var t, e = this,
                      n = 0,
                      o = [];
                  this.slides.forEach((function(i, a) {
                      var s = i.$el,
                          r = i.isDom || !t ? e.getSlideMetrics(s) : t;
                      i.index = a, i.width = r, i.left = n, t = r, n += r, o.push(a)
                  }));
                  var a = Math.max(this.$track.offsetWidth, w(this.$track.getBoundingClientRect().width)),
                      s = window.getComputedStyle(this.$track);
                  a -= parseFloat(s.paddingLeft) + parseFloat(s.paddingRight), this.contentWidth = n, this.viewportWidth = a;
                  var r = [],
                      l = this.option("slidesPerPage");
                  if (Number.isInteger(l) && n > a)
                      for (var c = 0; c < this.slides.length; c += l) r.push({
                          indexes: o.slice(c, c + l),
                          slides: this.slides.slice(c, c + l)
                      });
                  else
                      for (var h = 0, d = 0, u = 0; u < this.slides.length; u += 1) {
                          var f = this.slides[u];
                          (!r.length || d + f.width > a) && (r.push({
                              indexes: [],
                              slides: []
                          }), h = r.length - 1, d = 0), d += f.width, r[h].indexes.push(u), r[h].slides.push(f)
                      }
                  var v = this.option("center"),
                      g = this.option("fill");
                  r.forEach((function(t, i) {
                      t.index = i, t.width = t.slides.reduce((function(t, e) {
                          return t + e.width
                      }), 0), t.left = t.slides[0].left, v && (t.left += .5 * (a - t.width) * -1), g && !e.option("infiniteX", e.option("infinite")) && n > a && (t.left = Math.max(t.left, 0), t.left = Math.min(t.left, n - a))
                  }));
                  var m, y = [];
                  r.forEach((function(t) {
                      var e = i({}, t);
                      m && e.left === m.left ? (m.width += e.width, m.slides = [].concat(p(m.slides), p(e.slides)), m.indexes = [].concat(p(m.indexes), p(e.indexes))) : (e.index = y.length, m = e, y.push(e))
                  })), this.pages = y;
                  var b = this.page;
                  if (null === b) {
                      var x = this.option("initialSlide");
                      b = null !== x ? this.findPageForSlide(x) : this.option("initialPage", 0), y[b] || (b = y.length && b > y.length ? y[y.length - 1].index : 0), this.page = b, this.pageIndex = b
                  }
                  this.updatePanzoom(), this.trigger("refresh")
              }
          }, {
              key: "getSlideMetrics",
              value: function(t) {
                  if (!t) {
                      var e, i = this.slides[0];
                      if ((t = document.createElement("div")).dataset.isTestEl = 1, t.style.visibility = "hidden", t.classList.add(this.option("classNames.slide")), i.customClass)(e = t.classList).add.apply(e, p(i.customClass.split(" ")));
                      this.$track.prepend(t)
                  }
                  var n = Math.max(t.offsetWidth, w(t.getBoundingClientRect().width)),
                      o = t.currentStyle || window.getComputedStyle(t);
                  return n = n + (parseFloat(o.marginLeft) || 0) + (parseFloat(o.marginRight) || 0), t.dataset.isTestEl && t.remove(), n
              }
          }, {
              key: "findPageForSlide",
              value: function(t) {
                  var e = this.pages.find((function(e) {
                      return e.indexes.indexOf(t) > -1
                  }));
                  return e ? e.index : null
              }
          }, {
              key: "slideNext",
              value: function() {
                  this.slideTo(this.pageIndex + 1)
              }
          }, {
              key: "slidePrev",
              value: function() {
                  this.slideTo(this.pageIndex - 1)
              }
          }, {
              key: "slideTo",
              value: function(t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      i = e.x,
                      n = void 0 === i ? -1 * this.setPage(t, !0) : i,
                      o = e.y,
                      a = void 0 === o ? 0 : o,
                      s = e.friction,
                      r = void 0 === s ? this.option("friction") : s;
                  this.Panzoom.content.x === n && !this.Panzoom.velocity.x && r || (this.Panzoom.panTo({
                      x: n,
                      y: a,
                      friction: r,
                      ignoreBounds: !0
                  }), "ready" === this.state && "ready" === this.Panzoom.state && this.trigger("settle"))
              }
          }, {
              key: "initPanzoom",
              value: function() {
                  var t = this;
                  this.Panzoom && this.Panzoom.destroy();
                  var e = x(!0, {}, {
                      content: this.$track,
                      wrapInner: !1,
                      resizeParent: !1,
                      zoom: !1,
                      click: !1,
                      lockAxis: "x",
                      x: -1 * this.pages[this.page].left,
                      centerOnStart: !1,
                      textSelection: function() {
                          return t.option("textSelection", !1)
                      },
                      panOnlyZoomed: function() {
                          return this.content.width < this.viewport.width
                      }
                  }, this.option("Panzoom"));
                  this.Panzoom = new O(this.$container, e), this.Panzoom.on({
                      "*": function(e) {
                          for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) n[o - 1] = arguments[o];
                          return t.trigger.apply(t, ["Panzoom.".concat(e)].concat(n))
                      },
                      afterUpdate: function() {
                          t.updatePage()
                      },
                      beforeTransform: this.onBeforeTransform.bind(this),
                      touchEnd: this.onTouchEnd.bind(this),
                      endAnimation: function() {
                          t.trigger("settle")
                      }
                  }), this.updateMetrics(), this.manageSlideVisiblity()
              }
          }, {
              key: "updatePanzoom",
              value: function() {
                  this.Panzoom && (this.Panzoom.content = i(i({}, this.Panzoom.content), {}, {
                      fitWidth: this.contentWidth,
                      origWidth: this.contentWidth,
                      width: this.contentWidth
                  }), this.pages.length > 1 && this.option("infiniteX", this.option("infinite")) ? this.Panzoom.boundX = null : this.Panzoom.boundX = {
                      from: -1 * this.pages[this.pages.length - 1].left,
                      to: -1 * this.pages[0].left
                  }, this.option("infiniteY", this.option("infinite")) ? this.Panzoom.boundY = null : this.Panzoom.boundY = {
                      from: 0,
                      to: 0
                  })
              }
          }, {
              key: "manageSlideVisiblity",
              value: function() {
                  var t = this,
                      e = this.contentWidth,
                      i = this.viewportWidth,
                      n = this.Panzoom ? -1 * this.Panzoom.content.x : this.pages[this.page].left,
                      o = this.option("preload"),
                      a = this.option("infiniteX", this.option("infinite")),
                      s = parseFloat(window.getComputedStyle(this.$viewport, null).getPropertyValue("padding-left")),
                      r = parseFloat(window.getComputedStyle(this.$viewport, null).getPropertyValue("padding-right"));
                  this.slides.forEach((function(l) {
                      var c, h, d = 0;
                      c = n - s, h = n + i + r, c -= o * (i + s + r), h += o * (i + s + r);
                      var u = l.left + l.width > c && l.left < h;
                      c = n + e - s, h = n + e + i + r, c -= o * (i + s + r);
                      var f = a && l.left + l.width > c && l.left < h;
                      c = n - e - s, h = n - e + i + r, c -= o * (i + s + r);
                      var v = a && l.left + l.width > c && l.left < h;
                      f || u || v ? (t.createSlideEl(l), u && (d = 0), f && (d = -1), v && (d = 1), l.left + l.width > n && l.left <= n + i + r && (d = 0)) : t.removeSlideEl(l), l.hasDiff = d
                  }));
                  var l = 0,
                      c = 0;
                  this.slides.forEach((function(t, i) {
                      var n = 0;
                      t.$el ? (i !== l || t.hasDiff ? n = c + t.hasDiff * e : c = 0, t.$el.style.left = Math.abs(n) > .1 ? "".concat(c + t.hasDiff * e, "px") : "", l++) : c += t.width
                  })), this.markSelectedSlides()
              }
          }, {
              key: "createSlideEl",
              value: function(t) {
                  if (t) {
                      if (!t.$el) {
                          var e, i = document.createElement("div");
                          if (i.dataset.index = t.index, i.classList.add(this.option("classNames.slide")), t.customClass)(e = i.classList).add.apply(e, p(t.customClass.split(" ")));
                          t.html && (i.innerHTML = t.html);
                          var n = [];
                          this.slides.forEach((function(t, e) {
                              t.$el && n.push(e)
                          }));
                          var o = t.index,
                              a = null;
                          if (n.length) {
                              var s = n.reduce((function(t, e) {
                                  return Math.abs(e - o) < Math.abs(t - o) ? e : t
                              }));
                              a = this.slides[s]
                          }
                          return this.$track.insertBefore(i, a && a.$el ? a.index < t.index ? a.$el.nextSibling : a.$el : null), t.$el = i, this.trigger("createSlide", t, o), t
                      }
                      var r;
                      parseInt(t.$el.dataset.index, 10) !== t.index && (t.$el.dataset.index = t.index, t.$el.querySelectorAll("[data-lazy-src]").forEach((function(t) {
                          var e = t.dataset.lazySrc;
                          t instanceof HTMLImageElement ? t.src = e : t.style.backgroundImage = "url('".concat(e, "')")
                      })), (r = t.$el.dataset.lazySrc) && (t.$el.style.backgroundImage = "url('".concat(r, "')")), t.state = "ready")
                  }
              }
          }, {
              key: "removeSlideEl",
              value: function(t) {
                  t.$el && !t.isDom && (this.trigger("removeSlide", t), t.$el.remove(), t.$el = null)
              }
          }, {
              key: "markSelectedSlides",
              value: function() {
                  var t = this,
                      e = this.option("classNames.slideSelected"),
                      i = "aria-hidden";
                  this.slides.forEach((function(n, o) {
                      var a = n.$el;
                      if (a) {
                          var s = t.pages[t.page];
                          s && s.indexes && s.indexes.indexOf(o) > -1 ? (e && !a.classList.contains(e) && (a.classList.add(e), t.trigger("selectSlide", n)), a.removeAttribute(i)) : (e && a.classList.contains(e) && (a.classList.remove(e), t.trigger("unselectSlide", n)), a.setAttribute(i, !0))
                      }
                  }))
              }
          }, {
              key: "updatePage",
              value: function() {
                  this.updateMetrics(), this.slideTo(this.page, {
                      friction: 0
                  })
              }
          }, {
              key: "onBeforeTransform",
              value: function() {
                  this.option("infiniteX", this.option("infinite")) && this.manageInfiniteTrack(), this.manageSlideVisiblity()
              }
          }, {
              key: "manageInfiniteTrack",
              value: function() {
                  var t = this.contentWidth,
                      e = this.viewportWidth;
                  if (!(!this.option("infiniteX", this.option("infinite")) || this.pages.length < 2 || t < e)) {
                      var i = this.Panzoom,
                          n = !1;
                      return i.content.x < -1 * (t - e) && (i.content.x += t, this.pageIndex = this.pageIndex - this.pages.length, n = !0), i.content.x > e && (i.content.x -= t, this.pageIndex = this.pageIndex + this.pages.length, n = !0), n && "pointerdown" === i.state && i.resetDragPosition(), n
                  }
              }
          }, {
              key: "onTouchEnd",
              value: function(t, e) {
                  var i = this.option("dragFree");
                  if (!i && this.pages.length > 1 && t.dragOffset.time < 350 && Math.abs(t.dragOffset.y) < 1 && Math.abs(t.dragOffset.x) > 5) this[t.dragOffset.x < 0 ? "slideNext" : "slidePrev"]();
                  else if (i) {
                      var n = v(this.getPageFromPosition(-1 * t.transform.x), 2)[1];
                      this.setPage(n)
                  } else this.slideToClosest()
              }
          }, {
              key: "slideToClosest",
              value: function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                      e = this.getPageFromPosition(-1 * this.Panzoom.content.x),
                      i = v(e, 2),
                      n = i[1];
                  this.slideTo(n, t)
              }
          }, {
              key: "getPageFromPosition",
              value: function(t) {
                  var e = this.pages.length;
                  this.option("center") && (t += .5 * this.viewportWidth);
                  var i = Math.floor(t / this.contentWidth);
                  t -= i * this.contentWidth;
                  var n = this.slides.find((function(e) {
                      return e.left <= t && e.left + e.width > t
                  }));
                  if (n) {
                      var o = this.findPageForSlide(n.index);
                      return [o, o + i * e]
                  }
                  return [0, 0]
              }
          }, {
              key: "setPage",
              value: function(t, e) {
                  var i = 0,
                      n = parseInt(t, 10) || 0,
                      o = this.page,
                      a = this.pageIndex,
                      s = this.pages.length,
                      r = this.contentWidth,
                      l = this.viewportWidth;
                  if (t = (n % s + s) % s, this.option("infiniteX", this.option("infinite")) && r > l) {
                      var c = Math.floor(n / s) || 0,
                          h = r;
                      if (i = this.pages[t].left + c * h, !0 === e && s > 2) {
                          var d = -1 * this.Panzoom.content.x,
                              u = i - h,
                              f = i + h,
                              v = Math.abs(d - i),
                              p = Math.abs(d - u),
                              g = Math.abs(d - f);
                          g < v && g <= p ? (i = f, n += s) : p < v && p < g && (i = u, n -= s)
                      }
                  } else t = n = Math.max(0, Math.min(n, s - 1)), i = this.pages[t].left;
                  return this.page = t, this.pageIndex = n, null !== o && t !== o && (this.prevPage = o, this.prevPageIndex = a, this.trigger("change", t, o)), i
              }
          }, {
              key: "destroy",
              value: function() {
                  var t = this;
                  this.state = "destroy", this.slides.forEach((function(e) {
                      t.removeSlideEl(e)
                  })), this.slides = [], this.Panzoom.destroy(), this.detachPlugins()
              }
          }]), n
      }(L);
  N.version = "4.0.0-beta.1", N.Plugins = R;
  var D = !!("undefined" != typeof window && window.document && window.document.createElement && window.document.body),
      B = function() {
          function t(e) {
              o(this, t), this.fancybox = e, this.viewport = null, this.pendingUpdate = null;
              for (var i = 0, n = ["onReady", "onResize", "onTouchstart", "onTouchmove"]; i < n.length; i++) {
                  var a = n[i];
                  this[a] = this[a].bind(this)
              }
          }
          return s(t, [{
              key: "onReady",
              value: function() {
                  var t = window.visualViewport;
                  t && (this.viewport = t, this.startY = 0, t.addEventListener("resize", this.onResize), this.updateViewport()), window.addEventListener("touchstart", this.onTouchstart, {
                      passive: !1
                  }), window.addEventListener("touchmove", this.onTouchmove, {
                      passive: !1
                  })
              }
          }, {
              key: "onResize",
              value: function() {
                  this.updateViewport()
              }
          }, {
              key: "updateViewport",
              value: function() {
                  var t = this.fancybox,
                      e = this.viewport,
                      i = e.scale || 1,
                      n = t.$container;
                  if (n) {
                      var o = "",
                          a = "",
                          s = "";
                      i - 1 > .1 && (o = "".concat(e.width * i, "px"), a = "".concat(e.height * i, "px"), s = "translate3d(".concat(e.offsetLeft, "px, ").concat(e.offsetTop, "px, 0) scale(").concat(1 / i, ")")), n.style.width = o, n.style.height = a, n.style.transform = s
                  }
              }
          }, {
              key: "onTouchstart",
              value: function(t) {
                  this.startY = t.touches ? t.touches[0].screenY : t.screenY
              }
          }, {
              key: "onTouchmove",
              value: function(t) {
                  var e = this.startY,
                      i = window.innerWidth / window.document.documentElement.clientWidth;
                  if (!(t.touches.length > 1 || 1 !== i)) {
                      var n = t.target,
                          o = T(n);
                      if (o) {
                          var a = window.getComputedStyle(o),
                              s = parseInt(a.getPropertyValue("height"), 10),
                              r = t.touches ? t.touches[0].screenY : t.screenY,
                              l = e <= r && 0 === o.scrollTop,
                              c = e >= r && o.scrollHeight - o.scrollTop === s;
                          (l || c) && t.preventDefault()
                      } else t.preventDefault()
                  }
              }
          }, {
              key: "cleanup",
              value: function() {
                  this.pendingUpdate && (cancelAnimationFrame(this.pendingUpdate), this.pendingUpdate = null);
                  var t = this.viewport;
                  t && (t.removeEventListener("resize", this.onResize), this.viewport = null), window.removeEventListener("touchstart", this.onTouchstart, !1), window.removeEventListener("touchmove", this.onTouchmove, !1)
              }
          }, {
              key: "attach",
              value: function() {
                  this.fancybox.on("initLayout", this.onReady)
              }
          }, {
              key: "detach",
              value: function() {
                  this.fancybox.off("initLayout", this.onReady), this.cleanup()
              }
          }]), t
      }(),
      H = function() {
          function t(e) {
              o(this, t), this.fancybox = e, this.$container = null, this.state = "init";
              for (var i = 0, n = ["onPrepare", "onClosing", "onKeydown"]; i < n.length; i++) {
                  var a = n[i];
                  this[a] = this[a].bind(this)
              }
              this.events = {
                  prepare: this.onPrepare,
                  closing: this.onClosing,
                  keydown: this.onKeydown
              }
          }
          return s(t, [{
              key: "onPrepare",
              value: function() {
                  this.getSlides().length < this.fancybox.option("Thumbs.minSlideCount") ? this.state = "disabled" : !0 === this.fancybox.option("Thumbs.autoStart") && this.fancybox.Carousel.Panzoom.content.height >= this.fancybox.option("Thumbs.minScreenHeight") && this.build()
              }
          }, {
              key: "onClosing",
              value: function() {
                  this.Carousel && this.Carousel.Panzoom.detachEvents()
              }
          }, {
              key: "onKeydown",
              value: function(t, e) {
                  e === t.option("Thumbs.key") && this.toggle()
              }
          }, {
              key: "build",
              value: function() {
                  var t = this;
                  if (!this.$container) {
                      var e = document.createElement("div");
                      e.classList.add("fancybox__thumbs"), this.fancybox.$carousel.parentNode.insertBefore(e, this.fancybox.$carousel.nextSibling), this.Carousel = new N(e, x(!0, {
                          Dots: !1,
                          Navigation: !1,
                          Sync: {
                              friction: 0
                          },
                          infinite: !1,
                          center: !0,
                          fill: !0,
                          dragFree: !0,
                          slidesPerPage: 1,
                          preload: 1
                      }, this.fancybox.option("Thumbs.Carousel"), {
                          Sync: {
                              target: this.fancybox.Carousel
                          },
                          slides: this.getSlides()
                      })), this.Carousel.Panzoom.on("wheel", (function(e, i) {
                          i.preventDefault(), t.fancybox[i.deltaY < 0 ? "prev" : "next"]()
                      })), this.$container = e, this.state = "visible"
                  }
              }
          }, {
              key: "getSlides",
              value: function() {
                  var t, e = [],
                      i = y(this.fancybox.items);
                  try {
                      for (i.s(); !(t = i.n()).done;) {
                          var n = t.value,
                              o = n.thumb;
                          o && e.push({
                              html: '<div class="fancybox__thumb" style="background-image:url(\''.concat(o, "')\"></div>"),
                              customClass: "has-thumb has-".concat(n.type || "image")
                          })
                      }
                  } catch (t) {
                      i.e(t)
                  } finally {
                      i.f()
                  }
                  return e
              }
          }, {
              key: "toggle",
              value: function() {
                  return "visible" === this.state ? (this.Carousel.Panzoom.detachEvents(), this.$container.style.display = "none", void(this.state = "hidden")) : "hidden" === this.state ? (this.$container.style.display = "", this.Carousel.Panzoom.attachEvents(), void(this.state = "visible")) : void this.build()
              }
          }, {
              key: "cleanup",
              value: function() {
                  this.Carousel && (this.Carousel.destroy(), this.Carousel = null), this.$container && (this.$container.remove(), this.$container = null), this.state = "init"
              }
          }, {
              key: "attach",
              value: function() {
                  this.fancybox.on(this.events)
              }
          }, {
              key: "detach",
              value: function() {
                  this.fancybox.off(this.events), this.cleanup()
              }
          }]), t
      }();
  H.defaults = {
      minSlideCount: 2,
      minScreenHeight: 500,
      autoStart: !0,
      key: "t"
  };
  var W = function(t) {
          return Object.entries(t).map((function(t) {
              return t.map(encodeURIComponent).join("=")
          })).join("&")
      },
      j = function() {
          function t(e) {
              o(this, t), this.fancybox = e;
              for (var i = 0, n = ["onInit", "onReady", "onCreateSlide", "onRemoveSlide", "onSelectSlide", "onUnselectSlide", "onRefresh", "onMessage"]; i < n.length; i++) {
                  var a = n[i];
                  this[a] = this[a].bind(this)
              }
              this.events = {
                  init: this.onInit,
                  ready: this.onReady,
                  "Carousel.createSlide": this.onCreateSlide,
                  "Carousel.removeSlide": this.onRemoveSlide,
                  "Carousel.selectSlide": this.onSelectSlide,
                  "Carousel.unselectSlide": this.onUnselectSlide,
                  "Carousel.refresh": this.onRefresh
              }
          }
          return s(t, [{
              key: "onInit",
              value: function() {
                  var t, e = y(this.fancybox.items);
                  try {
                      for (e.s(); !(t = e.n()).done;) {
                          var i = t.value;
                          this.processType(i)
                      }
                  } catch (t) {
                      e.e(t)
                  } finally {
                      e.f()
                  }
              }
          }, {
              key: "processType",
              value: function(t) {
                  if (t.html) return t.src = t.html, t.type = "html", void delete t.html;
                  var e = t.src || "",
                      i = t.type || this.fancybox.options.type,
                      n = null;
                  if (!e || "string" == typeof e) {
                      if (n = e.match(/(?:youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
                          var o = W(this.fancybox.option("Html.youtube")),
                              a = encodeURIComponent(n[1]);
                          t.videoId = a, t.src = "https://www.youtube-nocookie.com/embed/".concat(a, "?").concat(o), t.thumb = t.thumb || "https://i.ytimg.com/vi/".concat(a, "/mqdefault.jpg"), t.vendor = "youtube", i = "video"
                      } else if (n = e.match(/^.+vimeo.com\/(?:\/)?([\d]+)(.*)?/)) {
                          var s = W(this.fancybox.option("Html.vimeo")),
                              r = encodeURIComponent(n[1]);
                          t.videoId = r, t.src = "https://player.vimeo.com/video/".concat(r, "?").concat(s), t.vendor = "vimeo", i = "video"
                      } else(n = e.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t.src = "//maps.google.".concat(n[1], "/?ll=").concat((n[2] ? n[2] + "&z=" + Math.floor(n[3]) + (n[4] ? n[4].replace(/^\//, "&") : "") : n[4] + "").replace(/\?/, "&"), "&output=").concat(n[4] && n[4].indexOf("layer=c") > 0 ? "svembed" : "embed"), i = "map") : (n = e.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t.src = "//maps.google.".concat(n[1], "/maps?q=").concat(n[2].replace("query=", "q=").replace("api=1", ""), "&output=embed"), i = "map");
                      i || ("#" === e.charAt(0) ? i = "inline" : (n = e.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (i = "html5video", t.format = t.format || "video/" + ("ogv" === n[1] ? "ogg" : n[1])) : e.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? i = "image" : e.match(/\.(pdf)((\?|#).*)?$/i) && (i = "pdf")), t.type = i || this.fancybox.option("defaultType", "image"), "html5video" !== i && "video" !== i || (t.video = x({}, this.fancybox.option("Html.video"), t.video), t.width && t.height ? t.ratio = parseFloat(t.width) / parseFloat(t.height) : t.ratio = t.ratio || t.video.ratio)
                  }
              }
          }, {
              key: "onReady",
              value: function() {
                  var t = this;
                  this.fancybox.Carousel.slides.forEach((function(e) {
                      e.$el && (t.setContent(e), e.index === t.fancybox.getSlide().index && t.playVideo(e))
                  }))
              }
          }, {
              key: "onCreateSlide",
              value: function(t, e, i) {
                  "ready" === this.fancybox.state && this.setContent(i)
              }
          }, {
              key: "loadInlineContent",
              value: function(t) {
                  var e;
                  if (t.src instanceof HTMLElement) e = t.src;
                  else if ("string" == typeof t.src) {
                      var i = t.src.split("#", 2),
                          n = 2 === i.length && "" === i[0] ? i[1] : i[0];
                      e = document.getElementById(n)
                  }
                  if (e) {
                      if ("clone" === t.type || e.$placeHolder) {
                          var o = (e = e.cloneNode(!0)).getAttribute("id");
                          o = o ? "".concat(o, "--clone") : "clone-".concat(this.fancybox.id, "-").concat(t.index), e.setAttribute("id", o)
                      } else {
                          var a = document.createElement("div");
                          a.classList.add("fancybox-placeholder"), e.parentNode.insertBefore(a, e), e.$placeHolder = a
                      }
                      this.fancybox.setContent(t, e)
                  } else this.fancybox.setError(t, "{{ELEMENT_NOT_FOUND}}")
              }
          }, {
              key: "loadAjaxContent",
              value: function(t) {
                  var e = this.fancybox,
                      i = new XMLHttpRequest;
                  e.showLoading(t), i.onreadystatechange = function() {
                      i.readyState === XMLHttpRequest.DONE && "ready" === e.state && (e.hideLoading(t), 200 === i.status ? e.setContent(t, i.responseText) : e.setError(t, 404 === i.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"))
                  }, i.open("GET", t.src), i.send(t.ajax || null), t.xhr = i
              }
          }, {
              key: "loadIframeContent",
              value: function(t) {
                  var e = this,
                      i = this.fancybox,
                      n = document.createElement("iframe");
                  if (n.className = "fancybox__iframe", n.setAttribute("id", "fancybox__iframe_".concat(i.id, "_").concat(t.index)), n.setAttribute("allow", "autoplay; fullscreen"), n.setAttribute("scrolling", "auto"), t.$iframe = n, "iframe" !== t.type || !1 === t.preload) return n.setAttribute("src", t.src), void this.fancybox.setContent(t, n);
                  i.showLoading(t);
                  var o = document.createElement("div");
                  o.style.visibility = "hidden", this.fancybox.setContent(t, o), o.appendChild(n), n.onerror = function() {
                      i.setError(t, "{{IFRAME_ERROR}}")
                  }, n.onload = function() {
                      i.hideLoading(t);
                      var o = !1;
                      "yes" !== n.dataset.ready && (n.dataset.ready = "yes", o = !0), n.src.length && (n.parentNode.style.visibility = "", !1 !== t.autoSize && e.autoSizeIframe(n), o && i.revealContent(t))
                  }, n.setAttribute("src", t.src)
              }
          }, {
              key: "setAspectRatio",
              value: function(t) {
                  var e = t.ratio;
                  if (e && t.$content) {
                      t.$content.style.maxWidth = "", t.$content.style.maxHeight = "";
                      var i = t.$content.offsetWidth,
                          n = t.$content.offsetHeight,
                          o = t.width,
                          a = t.height;
                      if (o && a && (i > o || n > a)) {
                          var s = Math.min(o / i, a / n);
                          i *= s, n *= s
                      }
                      e < i / n ? i = n * e : n = i / e, t.$content.style.maxWidth = "".concat(i, "px"), t.$content.style.maxHeight = "".concat(n, "px")
                  }
              }
          }, {
              key: "autoSizeIframe",
              value: function(t) {
                  if (t.dataset && "yes" === t.dataset.ready) {
                      var e = t.parentNode.style;
                      e.flex = "1 1 auto", e.width = "", e.height = "";
                      try {
                          var i = t.contentWindow.document,
                              n = i.getElementsByTagName("html")[0],
                              o = i.body,
                              a = window.getComputedStyle(t.parentNode),
                              s = parseFloat(a.paddingLeft) + parseFloat(a.paddingRight),
                              r = parseFloat(a.paddingTop) + parseFloat(a.paddingBottom);
                          o.style.overflow = "hidden";
                          var l = n.scrollWidth;
                          e.width = "".concat(l + s, "px"), o.style.overflow = "", e.flex = "", e.flexShrink = "0", e.height = "".concat(o.scrollHeight, "px");
                          var c = n.scrollHeight;
                          e.height = "".concat(c + r, "px")
                      } catch (t) {
                          e = ""
                      }
                  }
              }
          }, {
              key: "onRefresh",
              value: function(t, e) {
                  var i = this;
                  e.slides.forEach((function(t) {
                      t.$el && (t.$iframe && !1 !== t.autoSize && i.autoSizeIframe(t.$iframe), t.ratio && i.setAspectRatio(t))
                  }))
              }
          }, {
              key: "setContent",
              value: function(t) {
                  if (t && !t.isDom) {
                      switch (t.type) {
                          case "html":
                              this.fancybox.setContent(t, t.src);
                              break;
                          case "html5video":
                              this.fancybox.setContent(t, this.fancybox.option("Html.html5video.tpl").replace(/\{\{src\}\}/gi, t.src).replace("{{format}}", t.format || t.html5video && t.html5video.format || "").replace("{{poster}}", t.thumb || ""));
                              break;
                          case "inline":
                          case "clone":
                              this.loadInlineContent(t);
                              break;
                          case "ajax":
                              this.loadAjaxContent(t);
                              break;
                          case "iframe":
                          case "pdf":
                          case "video":
                          case "map":
                              this.loadIframeContent(t)
                      }
                      t.ratio && this.setAspectRatio(t)
                  }
              }
          }, {
              key: "onSelectSlide",
              value: function(t, e, i) {
                  "ready" === t.state && this.playVideo(i)
              }
          }, {
              key: "playVideo",
              value: function(t) {
                  if ("html5video" === t.type) {
                      var e = t.$el.querySelector("video");
                      if (e) try {
                          e.play()
                      } catch (t) {}
                  }
                  if ("video" === t.type && t.$iframe && t.$iframe.contentWindow) {
                      ! function e() {
                          if ("done" === t.state && t.$iframe && t.$iframe.contentWindow) {
                              var i;
                              if (t.$iframe.isReady) return t.video && t.video.autoplay && (i = "youtube" == t.vendor ? {
                                  event: "command",
                                  func: "playVideo"
                              } : {
                                  method: "play",
                                  value: "true"
                              }), void(i && t.$iframe.contentWindow.postMessage(JSON.stringify(i), "*"));
                              "youtube" === t.vendor && (i = {
                                  event: "listening",
                                  id: t.$iframe.getAttribute("id")
                              }, t.$iframe.contentWindow.postMessage(JSON.stringify(i), "*")), t.poller = setTimeout(e, 250)
                          }
                      }()
                  }
              }
          }, {
              key: "onUnselectSlide",
              value: function(t, e, i) {
                  if ("html5video" !== i.type) {
                      var n = !1;
                      "vimeo" == i.vendor ? n = {
                          method: "pause",
                          value: "true"
                      } : "youtube" === i.vendor && (n = {
                          event: "command",
                          func: "pauseVideo"
                      }), n && i.$iframe && i.$iframe.contentWindow && i.$iframe.contentWindow.postMessage(JSON.stringify(n), "*"), clearTimeout(i.poller)
                  } else try {
                      i.$el.querySelector("video").pause()
                  } catch (t) {}
              }
          }, {
              key: "onRemoveSlide",
              value: function(t, e, i) {
                  i.xhr && (i.xhr.abort(), i.xhr = null), i.$iframe && (i.$iframe.onload = i.$iframe.onerror = null, i.$iframe.src = "//about:blank", i.$iframe = null);
                  var n = i.$content;
                  "inline" === i.type && n && (n.classList.remove("fancybox__content"), "none" !== n.style.display && (n.style.display = "none"), i.$closeButton && (i.$closeButton.remove(), i.$closeButton = null));
                  var o = n && n.$placeHolder;
                  o && (o.parentNode.insertBefore(n, o), o.remove(), n.$placeHolder = null)
              }
          }, {
              key: "onMessage",
              value: function(t) {
                  try {
                      var e = JSON.parse(t.data);
                      if ("https://player.vimeo.com" === t.origin) {
                          if ("ready" === e.event) {
                              var i, n = y(document.getElementsByClassName("fancybox__iframe"));
                              try {
                                  for (n.s(); !(i = n.n()).done;) {
                                      var o = i.value;
                                      o.contentWindow === t.source && (o.isReady = 1)
                                  }
                              } catch (t) {
                                  n.e(t)
                              } finally {
                                  n.f()
                              }
                          }
                      } else "https://www.youtube-nocookie.com" === t.origin && "onReady" === e.event && (document.getElementById(e.id).isReady = 1)
                  } catch (t) {}
              }
          }, {
              key: "attach",
              value: function() {
                  this.fancybox.on(this.events), window.addEventListener("message", this.onMessage, !1)
              }
          }, {
              key: "detach",
              value: function() {
                  this.fancybox.off(this.events), window.removeEventListener("message", this.onMessage, !1)
              }
          }]), t
      }();
  j.defaults = {
      video: {
          autoplay: !0,
          ratio: 16 / 9
      },
      youtube: {
          autohide: 1,
          fs: 1,
          rel: 0,
          hd: 1,
          wmode: "transparent",
          enablejsapi: 1,
          html5: 1
      },
      vimeo: {
          hd: 1,
          show_title: 1,
          show_byline: 1,
          show_portrait: 0,
          fullscreen: 1
      },
      html5video: {
          tpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />\n  Sorry, your browser doesn\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!\n</video>',
          format: ""
      }
  };
  var X = function() {
      function t(e) {
          o(this, t), this.fancybox = e;
          for (var i = 0, n = ["onReady", "onClosing", "onDone", "onPageChange", "onCreateSlide", "onRemoveSlide", "onImageStatusChange"]; i < n.length; i++) {
              var a = n[i];
              this[a] = this[a].bind(this)
          }
          this.events = {
              ready: this.onReady,
              closing: this.onClosing,
              done: this.onDone,
              "Carousel.change": this.onPageChange,
              "Carousel.createSlide": this.onCreateSlide,
              "Carousel.removeSlide": this.onRemoveSlide
          }
      }
      return s(t, [{
          key: "onReady",
          value: function() {
              var t = this;
              this.fancybox.Carousel.slides.forEach((function(e) {
                  e.$el && t.setContent(e)
              }))
          }
      }, {
          key: "onDone",
          value: function(t, e) {
              this.handleCursor(e)
          }
      }, {
          key: "onClosing",
          value: function(t) {
              clearTimeout(this.clickTimer), t.Carousel.slides.forEach((function(t) {
                  t.$image && (t.state = "destroy"), t.Panzoom && t.Panzoom.detachEvents()
              })), "closing" === this.fancybox.state && this.canZoom(t.getSlide()) && this.zoomOut()
          }
      }, {
          key: "onCreateSlide",
          value: function(t, e, i) {
              "ready" === this.fancybox.state && this.setContent(i)
          }
      }, {
          key: "onRemoveSlide",
          value: function(t, e, i) {
              i.$image && (i.$el.classList.remove(t.option("Image.canZoomInClass")), i.$image.remove(), i.$image = null), i.Panzoom && (i.Panzoom.destroy(), i.Panzoom = null), i.$el && i.$el.dataset && delete i.$el.dataset.imageFit
          }
      }, {
          key: "setContent",
          value: function(t) {
              var e = this;
              if (!(t.isDom || t.html || t.type && "image" !== t.type || t.$image)) {
                  t.type = "image", t.state = "loading";
                  var i = document.createElement("div");
                  i.style.visibility = "hidden";
                  var n = document.createElement("img");
                  n.addEventListener("load", (function(i) {
                      i.stopImmediatePropagation(), e.onImageStatusChange(t)
                  })), n.addEventListener("error", (function() {
                      e.onImageStatusChange(t)
                  })), n.src = t.src, n.alt = "", n.draggable = !1, n.classList.add("fancybox__image"), t.srcset && n.setAttribute("srcset", t.srcset), t.sizes && n.setAttribute("sizes", t.sizes), t.$image = n;
                  var o = this.fancybox.option("Image.wrap");
                  if (o) {
                      var a = document.createElement("div");
                      a.classList.add("string" == typeof o ? o : "fancybox__image-wrap"), a.appendChild(n), i.appendChild(a), t.$wrap = a
                  } else i.appendChild(n);
                  t.$el.dataset.imageFit = this.fancybox.option("Image.fit"), this.fancybox.setContent(t, i), n.complete || n.error ? this.onImageStatusChange(t) : this.fancybox.showLoading(t)
              }
          }
      }, {
          key: "onImageStatusChange",
          value: function(t) {
              var e = this,
                  i = t.$image;
              i && "loading" === t.state && (i.complete && i.naturalWidth && i.naturalHeight ? (this.fancybox.hideLoading(t), "contain" === this.fancybox.option("Image.fit") && this.initSlidePanzoom(t), t.$el.addEventListener("wheel", (function(i) {
                  return e.onWheel(t, i)
              }), {
                  passive: !1
              }), t.$content.addEventListener("click", (function(i) {
                  return e.onClick(t, i)
              }), {
                  passive: !1
              }), this.revealContent(t)) : this.fancybox.setError(t, "{{IMAGE_ERROR}}"))
          }
      }, {
          key: "initSlidePanzoom",
          value: function(t) {
              var e = this;
              t.Panzoom || (t.Panzoom = new O(t.$el, x(!0, this.fancybox.option("Image.Panzoom", {}), {
                  viewport: t.$wrap,
                  content: t.$image,
                  wrapInner: !1,
                  textSelection: !0,
                  touch: this.fancybox.option("Image.touch"),
                  panOnlyZoomed: !0,
                  click: !1,
                  wheel: !1
              })), t.Panzoom.on("startAnimation", (function() {
                  e.fancybox.trigger("Image.startAnimation", t)
              })), t.Panzoom.on("endAnimation", (function() {
                  "zoomIn" === t.state && e.fancybox.done(t), e.handleCursor(t), e.fancybox.trigger("Image.endAnimation", t)
              })), t.Panzoom.on("afterUpdate", (function() {
                  e.handleCursor(t), e.fancybox.trigger("Image.afterUpdate", t)
              })))
          }
      }, {
          key: "revealContent",
          value: function(t) {
              null === this.fancybox.Carousel.prevPage && t.index === this.fancybox.options.startIndex && this.canZoom(t) ? this.zoomIn() : this.fancybox.revealContent(t)
          }
      }, {
          key: "getZoomInfo",
          value: function(t) {
              var e = t.$thumb.getBoundingClientRect(),
                  i = e.width,
                  n = e.height,
                  o = t.$content.getBoundingClientRect(),
                  a = o.width,
                  s = o.height,
                  r = o.top - e.top,
                  l = o.left - e.left,
                  c = this.fancybox.option("Image.zoomOpacity");
              return "auto" === c && (c = Math.abs(i / n - a / s) > .1), {
                  top: r,
                  left: l,
                  scale: e.width / a,
                  opacity: c
              }
          }
      }, {
          key: "canZoom",
          value: function(t) {
              var e = this.fancybox,
                  i = e.$container;
              if (window.visualViewport && 1 !== window.visualViewport.scale) return !1;
              if (!e.option("Image.zoom") || "contain" !== e.option("Image.fit")) return !1;
              var n = t.$thumb;
              if (!n || "loading" === t.state) return !1;
              i.classList.add("fancybox__no-click");
              var o, a = n.getBoundingClientRect();
              if (this.fancybox.option("Image.ignoreCoveredThumbnail")) {
                  var s = document.elementFromPoint(a.left + 1, a.top + 1) === n,
                      r = document.elementFromPoint(a.right - 1, a.bottom - 1) === n;
                  o = s && r
              } else o = document.elementFromPoint(a.left + .5 * a.width, a.top + .5 * a.height) === n;
              return i.classList.remove("fancybox__no-click"), o
          }
      }, {
          key: "zoomIn",
          value: function() {
              var t = this.fancybox,
                  e = t.getSlide(),
                  i = e.Panzoom,
                  n = this.getZoomInfo(e),
                  o = n.top,
                  a = n.left,
                  s = n.scale,
                  r = n.opacity;
              e.state = "zoomIn", t.trigger("reveal", e), i.panTo({
                  x: -1 * a,
                  y: -1 * o,
                  scale: s,
                  friction: 0,
                  ignoreBounds: !0
              }), e.$content.style.visibility = "", !0 === r && i.on("afterTransform", (function(t) {
                  "zoomIn" !== e.state && "zoomOut" !== e.state || (t.$content.style.opacity = Math.min(1, 1 - (1 - t.content.scale) / (1 - s)))
              })), i.panTo({
                  x: 0,
                  y: 0,
                  scale: 1,
                  friction: this.fancybox.option("Image.zoomFriction")
              })
          }
      }, {
          key: "zoomOut",
          value: function() {
              var t = this,
                  e = this.fancybox,
                  i = e.getSlide(),
                  n = i.Panzoom;
              if (n) {
                  i.state = "zoomOut", e.state = "customClosing", i.$caption && (i.$caption.style.visibility = "hidden");
                  var o = this.fancybox.option("Image.zoomFriction"),
                      a = function(e) {
                          var a = t.getZoomInfo(i),
                              s = a.top,
                              r = a.left,
                              l = a.scale,
                              c = a.opacity;
                          e || c || (o *= .82), n.panTo({
                              x: -1 * r,
                              y: -1 * s,
                              scale: l,
                              friction: o,
                              ignoreBounds: !0
                          }), o *= .98
                      };
                  window.addEventListener("scroll", a), n.on("endAnimation", (function() {
                      window.removeEventListener("scroll", a), e.destroy()
                  })), a()
              }
          }
      }, {
          key: "handleCursor",
          value: function(t) {
              if ("image" === t.type) {
                  var e = t.Panzoom,
                      i = this.fancybox.option("Image.click"),
                      n = t.$el.classList;
                  if (e && "toggleZoom" === i) n[e && 1 === e.content.scale && e.option("maxScale") - e.content.scale > .01 ? "add" : "remove"](this.fancybox.option("Image.canZoomInClass"));
                  else "close" === i && n.add(this.fancybox.option("Image.canZoomOutClass"))
              }
          }
      }, {
          key: "onWheel",
          value: function(t, e) {
              if ("ready" === this.fancybox.state && !1 !== this.fancybox.trigger("Image.wheel", e)) switch (this.fancybox.option("Image.wheel")) {
                  case "zoom":
                      t.Panzoom && t.Panzoom.zoomWithWheel(e);
                      break;
                  case "close":
                      this.fancybox.close();
                      break;
                  case "slide":
                      this.fancybox[e.deltaY < 0 ? "prev" : "next"]()
              }
          }
      }, {
          key: "onClick",
          value: function(t, e) {
              var i = this;
              if ("ready" === this.fancybox.state) {
                  var n = t.Panzoom;
                  if (!n || !n.dragPosition.midPoint && 0 === n.dragOffset.x && 0 === n.dragOffset.y && 1 === n.dragOffset.scale) {
                      if (this.fancybox.Carousel.Panzoom.lockAxis) return !1;
                      var o = function(n) {
                          if (!1 !== i.fancybox.trigger("Image.click", e)) switch (n) {
                              case "toggleZoom":
                                  e.stopPropagation(), t.Panzoom && t.Panzoom.zoomWithClick(e);
                                  break;
                              case "close":
                                  i.fancybox.close();
                                  break;
                              case "next":
                                  e.stopPropagation(), i.fancybox.next()
                          }
                      };
                      this.clickTimer && (clearTimeout(this.clickTimer), this.clickTimer = null);
                      var a = this.fancybox.option("Image.click"),
                          s = this.fancybox.option("Image.doubleClick");
                      s ? 1 === e.detail ? this.clickTimer = setTimeout((function() {
                          o(a)
                      }), 300) : 2 === e.detail && o(s) : o(a)
                  }
              }
          }
      }, {
          key: "onPageChange",
          value: function(t, e) {
              var i = t.getSlide();
              e.slides.forEach((function(t) {
                  t.Panzoom && "done" === t.state && t.index !== i.index && t.Panzoom.panTo({
                      x: 0,
                      y: 0,
                      scale: 1,
                      friction: .8
                  })
              }))
          }
      }, {
          key: "attach",
          value: function() {
              this.fancybox.on(this.events)
          }
      }, {
          key: "detach",
          value: function() {
              this.fancybox.off(this.events)
          }
      }]), t
  }();
  X.defaults = {
      canZoomInClass: "can-zoom_in",
      canZoomOutClass: "can-zoom_out",
      zoom: !0,
      zoomOpacity: "auto",
      zoomFriction: .82,
      ignoreCoveredThumbnail: !1,
      touch: !0,
      click: "toggleZoom",
      doubleClick: null,
      wheel: "zoom",
      fit: "contain",
      wrap: !1,
      Panzoom: {
          ratio: 1
      }
  };
  var q = function() {
          var t = window.location.hash.substr(1),
              e = t.split("-"),
              i = e.length > 1 && /^\+?\d+$/.test(e[e.length - 1]) && parseInt(e.pop(-1), 10) || null;
          return {
              hash: t,
              slug: e.join("-"),
              index: i
          }
      },
      Y = function() {
          function t(e) {
              o(this, t), this.fancybox = e;
              for (var i = 0, n = ["onChange", "onClosing"]; i < n.length; i++) {
                  var a = n[i];
                  this[a] = this[a].bind(this)
              }
              this.events = {
                  initCarousel: this.onChange,
                  "Carousel.change": this.onChange,
                  closing: this.onClosing
              }, this.hasCreatedHistory = !1, this.origHash = "", this.timer = null
          }
          return s(t, [{
              key: "onChange",
              value: function() {
                  var t = this,
                      e = this.fancybox,
                      i = e.Carousel;
                  this.timer && clearTimeout(this.timer);
                  var n = null === i.prevPage,
                      o = e.getSlide(),
                      a = o.$trigger && o.$trigger.dataset,
                      s = window.location.hash.substr(1),
                      r = !1;
                  if (o.slug) r = o.slug;
                  else {
                      var l = a && a.fancybox;
                      l && l.length && "true" !== l && (r = l + (i.slides.length > 1 ? "-" + (o.index + 1) : ""))
                  }
                  n && (this.origHash = s !== r ? this.origHash : ""), r && s !== r && (this.timer = setTimeout((function() {
                      try {
                          window.history[n ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + "#" + r), n && (t.hasCreatedHistory = !0)
                      } catch (t) {}
                  }), 300))
              }
          }, {
              key: "onClosing",
              value: function() {
                  if (this.timer && clearTimeout(this.timer), !0 !== this.hasSilentClose) {
                      if (!this.hasCreatedHistory) try {
                          return void window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash ? "#" + this.origHash : ""))
                      } catch (t) {}
                      window.history.back()
                  }
              }
          }, {
              key: "attach",
              value: function(t) {
                  t.on(this.events)
              }
          }, {
              key: "detach",
              value: function(t) {
                  t.off(this.events)
              }
          }], [{
              key: "startFromUrl",
              value: function() {
                  if (!t.Fancybox.getInstance()) {
                      var e = q(),
                          i = e.hash,
                          n = e.slug,
                          o = e.index;
                      if (n) {
                          var a = document.querySelector('[data-slug="'.concat(i, '"]'));
                          if (a && a.dispatchEvent(new CustomEvent("click", {
                                  bubbles: !0,
                                  cancelable: !0
                              })), !t.Fancybox.getInstance()) {
                              var s = document.querySelectorAll('[data-fancybox="'.concat(n, '"]'));
                              s.length && (null === o && 1 === s.length ? a = s[0] : o && (a = s[o - 1]), a && a.dispatchEvent(new CustomEvent("click", {
                                  bubbles: !0,
                                  cancelable: !0
                              })))
                          }
                      }
                  }
              }
          }, {
              key: "onHashChange",
              value: function() {
                  var e = q(),
                      i = e.slug,
                      n = e.index,
                      o = t.Fancybox.getInstance();
                  if (o) {
                      if (i) {
                          var a, s = o.Carousel,
                              r = y(s.slides);
                          try {
                              for (r.s(); !(a = r.n()).done;) {
                                  var l = a.value;
                                  if (l.slug && l.slug === i) return s.slideTo(l.index)
                              }
                          } catch (t) {
                              r.e(t)
                          } finally {
                              r.f()
                          }
                          var c = o.getSlide(),
                              h = c.$trigger && c.$trigger.dataset;
                          if (h && h.fancybox === i) return s.slideTo(n - 1)
                      }
                      o.plugins.Hash.hasSilentClose = !0, o.close()
                  }
                  t.startFromUrl()
              }
          }, {
              key: "onReady",
              value: function() {
                  window.addEventListener("hashchange", t.onHashChange, !1), t.startFromUrl()
              }
          }, {
              key: "create",
              value: function() {
                  D && window.requestAnimationFrame((function() {
                      t.onReady()
                  }))
              }
          }, {
              key: "destroy",
              value: function() {
                  window.removeEventListener("hashchange", t.onHashChange, !1)
              }
          }]), t
      }(),
      U = {
          pageXOffset: 0,
          pageYOffset: 0,
          element: function() {
              return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement
          },
          activate: function(t) {
              U.pageXOffset = window.pageXOffset, U.pageYOffset = window.pageYOffset, t.requestFullscreen ? t.requestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.msRequestFullscreen && t.msRequestFullscreen()
          },
          deactivate: function() {
              document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen()
          }
      },
      V = function() {
          function t(e) {
              o(this, t), this.fancybox = e, this.active = !1, this.handleVisibilityChange = this.handleVisibilityChange.bind(this)
          }
          return s(t, [{
              key: "isActive",
              value: function() {
                  return this.active
              }
          }, {
              key: "setTimer",
              value: function() {
                  var t = this;
                  if (this.active && !this.timer) {
                      var e = this.fancybox.option("slideshow.delay", 3e3);
                      this.timer = setTimeout((function() {
                          t.timer = null, t.fancybox.option("infinite") || t.fancybox.getSlide().index !== t.fancybox.Carousel.slides.length - 1 ? t.fancybox.next() : t.fancybox.jumpTo(0, {
                              friction: 0
                          })
                      }), e);
                      var i = this.$progress;
                      i || ((i = document.createElement("div")).classList.add("fancybox__progress"), this.fancybox.$carousel.parentNode.insertBefore(i, this.fancybox.$carousel), this.$progress = i, i.offsetHeight), i.style.transitionDuration = "".concat(e, "ms"), i.style.transform = "scaleX(1)"
                  }
              }
          }, {
              key: "clearTimer",
              value: function() {
                  clearTimeout(this.timer), this.timer = null, this.$progress && (this.$progress.style.transitionDuration = "", this.$progress.style.transform = "", this.$progress.offsetHeight)
              }
          }, {
              key: "activate",
              value: function() {
                  this.active || (this.active = !0, this.fancybox.$container.classList.add("has-slideshow"), "done" === this.fancybox.getSlide().state && this.setTimer(), document.addEventListener("visibilitychange", this.handleVisibilityChange, !1))
              }
          }, {
              key: "handleVisibilityChange",
              value: function() {
                  this.deactivate()
              }
          }, {
              key: "deactivate",
              value: function() {
                  this.active = !1, this.clearTimer(), this.fancybox.$container.classList.remove("has-slideshow"), document.removeEventListener("visibilitychange", this.handleVisibilityChange, !1)
              }
          }, {
              key: "toggle",
              value: function() {
                  this.active ? this.deactivate() : this.fancybox.Carousel.slides.length > 1 && this.activate()
              }
          }]), t
      }(),
      Z = {
          items: {
              counter: {
                  type: "div",
                  class: "fancybox__counter",
                  html: '<span data-fancybox-index=""></span>&nbsp;/&nbsp;<span data-fancybox-count=""></span>',
                  tabindex: -1,
                  position: "left"
              },
              prev: {
                  type: "button",
                  class: "fancybox__button--prev",
                  label: "PREV",
                  html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 4l-8 8 8 8"/></svg>',
                  click: function(t) {
                      t.preventDefault(), this.fancybox.prev()
                  }
              },
              next: {
                  type: "button",
                  class: "fancybox__button--next",
                  label: "NEXT",
                  html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M8 4l8 8-8 8"/></svg>',
                  click: function(t) {
                      t.preventDefault(), this.fancybox.next()
                  }
              },
              fullscreen: {
                  type: "button",
                  class: "fancybox__button--fullscreen",
                  label: "TOGGLE_FULLSCREEN",
                  html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1">\n                <g><path d="M3 8 V3h5"></path><path d="M21 8V3h-5"></path><path d="M8 21H3v-5"></path><path d="M16 21h5v-5"></path></g>\n                <g><path d="M7 2v5H2M17 2v5h5M2 17h5v5M22 17h-5v5"/></g>\n            </svg>',
                  click: function(t) {
                      t.preventDefault(), U.element() ? U.deactivate() : U.activate(this.fancybox.$container)
                  }
              },
              slideshow: {
                  type: "button",
                  class: "fancybox__button--slideshow",
                  label: "TOGGLE_SLIDESHOW",
                  html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1">\n                <g><path d="M6 4v16"/><path d="M20 12L6 20"/><path d="M20 12L6 4"/></g>\n                <g><path d="M7 4v15M17 4v15"/></g>\n            </svg>',
                  click: function(t) {
                      t.preventDefault(), this.Slideshow.toggle()
                  }
              },
              zoom: {
                  type: "button",
                  class: "fancybox__button--zoom",
                  label: "TOGGLE_ZOOM",
                  html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><circle cx="10" cy="10" r="7"></circle><path d="M16 16 L21 21"></svg>',
                  click: function(t) {
                      t.preventDefault();
                      var e = this.fancybox.getSlide().Panzoom;
                      e && e.toggleZoom()
                  }
              },
              download: {
                  type: "link",
                  label: "DOWNLOAD",
                  class: "fancybox__button--download",
                  html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.62 2.48A2 2 0 004.56 21h14.88a2 2 0 001.94-1.51L22 17"/></svg>',
                  click: function(t) {
                      t.stopPropagation()
                  }
              },
              thumbs: {
                  type: "button",
                  label: "TOGGLE_THUMBS",
                  class: "fancybox__button--thumbs",
                  html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><circle cx="4" cy="4" r="1" /><circle cx="12" cy="4" r="1" transform="rotate(90 12 4)"/><circle cx="20" cy="4" r="1" transform="rotate(90 20 4)"/><circle cx="4" cy="12" r="1" transform="rotate(90 4 12)"/><circle cx="12" cy="12" r="1" transform="rotate(90 12 12)"/><circle cx="20" cy="12" r="1" transform="rotate(90 20 12)"/><circle cx="4" cy="20" r="1" transform="rotate(90 4 20)"/><circle cx="12" cy="20" r="1" transform="rotate(90 12 20)"/><circle cx="20" cy="20" r="1" transform="rotate(90 20 20)"/></svg>',
                  click: function(t) {
                      t.stopPropagation();
                      var e = this.fancybox.plugins.Thumbs;
                      e && e.toggle()
                  }
              },
              close: {
                  type: "button",
                  label: "CLOSE",
                  class: "fancybox__button--close",
                  html: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"></path></svg>',
                  tabindex: 1,
                  click: function(t) {
                      t.stopPropagation(), t.preventDefault(), this.fancybox.close()
                  }
              }
          },
          display: ["counter", "zoom", "slideshow", "fullscreen", "thumbs", "close"],
          autoEnable: !0
      },
      G = function() {
          function t(e) {
              var i = this;
              o(this, t), this.fancybox = e, this.$container = null, this.state = "init";
              for (var n = 0, a = ["onInit", "onPrepare", "onDone", "onKeydown", "onClosing", "onChange", "onSettle", "onRefresh"]; n < a.length; n++) {
                  var s = a[n];
                  this[s] = this[s].bind(this)
              }
              this.events = {
                  init: this.onInit,
                  prepare: this.onPrepare,
                  done: this.onDone,
                  keydown: this.onKeydown,
                  closing: this.onClosing,
                  "Carousel.change": this.onChange,
                  "Carousel.settle": this.onSettle,
                  "Carousel.Panzoom.touchStart": function() {
                      return i.onRefresh()
                  },
                  "Image.startAnimation": function(t, e) {
                      return i.onRefresh(e)
                  },
                  "Image.afterUpdate": function(t, e) {
                      return i.onRefresh(e)
                  }
              }
          }
          return s(t, [{
              key: "onInit",
              value: function() {
                  if (this.fancybox.option("Toolbar.autoEnable")) {
                      var t, e = !1,
                          i = y(this.fancybox.items);
                      try {
                          for (i.s(); !(t = i.n()).done;) {
                              if ("image" === t.value.type) {
                                  e = !0;
                                  break
                              }
                          }
                      } catch (t) {
                          i.e(t)
                      } finally {
                          i.f()
                      }
                      if (!e) return void(this.state = "disabled")
                  }
                  var n, o = y(this.fancybox.option("Toolbar.display"));
                  try {
                      for (o.s(); !(n = o.n()).done;) {
                          var a = n.value;
                          if ("close" === (b(a) ? a.id : a)) {
                              this.fancybox.options.closeButton = !1;
                              break
                          }
                      }
                  } catch (t) {
                      o.e(t)
                  } finally {
                      o.f()
                  }
              }
          }, {
              key: "onPrepare",
              value: function() {
                  if ("init" === this.state && (this.build(), this.update(), this.Slideshow = new V(this.fancybox), !this.fancybox.Carousel.prevPage && (this.fancybox.option("slideshow.autoStart") && this.Slideshow.activate(), this.fancybox.option("fullscreen.autoStart") && !U.element()))) try {
                      U.activate(this.fancybox.$container)
                  } catch (t) {}
              }
          }, {
              key: "onFsChange",
              value: function() {
                  window.scrollTo(U.pageXOffset, U.pageYOffset)
              }
          }, {
              key: "onSettle",
              value: function() {
                  this.Slideshow && this.Slideshow.isActive() && (this.fancybox.getSlide().index !== this.fancybox.Carousel.slides.length - 1 || this.fancybox.option("infinite") ? "done" === this.fancybox.getSlide().state && this.Slideshow.setTimer() : this.Slideshow.deactivate())
              }
          }, {
              key: "onChange",
              value: function() {
                  this.update(), this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer()
              }
          }, {
              key: "onDone",
              value: function(t, e) {
                  e.index === t.getSlide().index && (this.update(), this.Slideshow && this.Slideshow.isActive() && (this.fancybox.option("infinite") || e.index !== this.fancybox.Carousel.slides.length - 1 ? this.Slideshow.setTimer() : this.Slideshow.deactivate()))
              }
          }, {
              key: "onRefresh",
              value: function(t) {
                  t && t.index !== this.fancybox.getSlide().index || (this.update(), !this.Slideshow || !this.Slideshow.isActive() || t && "done" !== t.state || this.Slideshow.deactivate())
              }
          }, {
              key: "onKeydown",
              value: function(t, e, i) {
                  " " === e && (this.Slideshow.toggle(), i.preventDefault())
              }
          }, {
              key: "onClosing",
              value: function() {
                  this.Slideshow && this.Slideshow.deactivate(), document.removeEventListener("fullscreenchange", this.onFsChange)
              }
          }, {
              key: "createElement",
              value: function(t) {
                  var e, i;
                  ("div" === t.type ? e = document.createElement("div") : (e = document.createElement("link" === t.type ? "a" : "button")).classList.add("carousel__button"), e.innerHTML = t.html, e.setAttribute("tabindex", t.tabindex || 0), t.class) && (i = e.classList).add.apply(i, p(t.class.split(" ")));
                  return t.label && e.setAttribute("title", this.fancybox.localize("{{".concat(t.label, "}}"))), t.click && e.addEventListener("click", t.click.bind(this)), "prev" === t.id && e.setAttribute("data-fancybox-prev", ""), "next" === t.id && e.setAttribute("data-fancybox-next", ""), e
              }
          }, {
              key: "build",
              value: function() {
                  var t = this;
                  this.cleanup();
                  var e, i = this.fancybox.option("Toolbar.items"),
                      n = [{
                          position: "left",
                          items: []
                      }, {
                          position: "center",
                          items: []
                      }, {
                          position: "right",
                          items: []
                      }],
                      o = this.fancybox.plugins.Thumbs,
                      a = y(this.fancybox.option("Toolbar.display"));
                  try {
                      var s = function() {
                          var a = e.value,
                              s = void 0,
                              r = void 0;
                          if (b(a) ? (s = a.id, r = x({}, i[s], a)) : r = i[s = a], ["counter", "next", "prev", "slideshow"].includes(s) && t.fancybox.items.length < 2) return "continue";
                          if ("fullscreen" === s) {
                              if (!document.fullscreenEnabled || window.fullScreen) return "continue";
                              document.addEventListener("fullscreenchange", t.onFsChange)
                          }
                          if ("thumbs" === s && (!o || "disabled" === o.state)) return "continue";
                          if (!r) return "continue";
                          var l = r.position || "right",
                              c = n.find((function(t) {
                                  return t.position === l
                              }));
                          c && c.items.push(r)
                      };
                      for (a.s(); !(e = a.n()).done;) s()
                  } catch (t) {
                      a.e(t)
                  } finally {
                      a.f()
                  }
                  var r = document.createElement("div");
                  r.classList.add("fancybox__toolbar");
                  for (var l = 0, c = n; l < c.length; l++) {
                      var h = c[l];
                      if (h.items.length) {
                          var d = document.createElement("div");
                          d.classList.add("fancybox__toolbar__items"), d.classList.add("fancybox__toolbar__items--".concat(h.position));
                          var u, f = y(h.items);
                          try {
                              for (f.s(); !(u = f.n()).done;) {
                                  var v = u.value;
                                  d.appendChild(this.createElement(v))
                              }
                          } catch (t) {
                              f.e(t)
                          } finally {
                              f.f()
                          }
                          r.appendChild(d)
                      }
                  }
                  this.fancybox.$carousel.parentNode.insertBefore(r, this.fancybox.$carousel), this.$container = r
              }
          }, {
              key: "update",
              value: function() {
                  var t, e = this.fancybox.getSlide(),
                      i = e.index,
                      n = this.fancybox.items.length,
                      o = e.downloadSrc || ("image" !== e.type || e.error ? null : e.src),
                      a = y(this.fancybox.$container.querySelectorAll("a.fancybox__button--download"));
                  try {
                      for (a.s(); !(t = a.n()).done;) {
                          var s = t.value;
                          o ? (s.removeAttribute("disabled"), s.setAttribute("href", o), s.setAttribute("download", o), s.setAttribute("target", "_blank")) : (s.setAttribute("disabled", ""), s.removeAttribute("href"), s.removeAttribute("download"))
                      }
                  } catch (t) {
                      a.e(t)
                  } finally {
                      a.f()
                  }
                  var r, l = e.Panzoom,
                      c = l && l.option("maxScale") > l.option("baseScale"),
                      h = y(this.fancybox.$container.querySelectorAll(".fancybox__button--zoom"));
                  try {
                      for (h.s(); !(r = h.n()).done;) {
                          var d = r.value;
                          c ? d.removeAttribute("disabled") : d.setAttribute("disabled", "")
                      }
                  } catch (t) {
                      h.e(t)
                  } finally {
                      h.f()
                  }
                  var u, f = y(this.fancybox.$container.querySelectorAll("[data-fancybox-index]"));
                  try {
                      for (f.s(); !(u = f.n()).done;) {
                          u.value.innerHTML = e.index + 1
                      }
                  } catch (t) {
                      f.e(t)
                  } finally {
                      f.f()
                  }
                  var v, p = y(this.fancybox.$container.querySelectorAll("[data-fancybox-count]"));
                  try {
                      for (p.s(); !(v = p.n()).done;) {
                          v.value.innerHTML = n
                      }
                  } catch (t) {
                      p.e(t)
                  } finally {
                      p.f()
                  }
                  if (!this.fancybox.option("infinite")) {
                      var g, m = y(this.fancybox.$container.querySelectorAll("[data-fancybox-prev]"));
                      try {
                          for (m.s(); !(g = m.n()).done;) {
                              var b = g.value;
                              0 === i ? b.setAttribute("disabled", "") : b.removeAttribute("disabled")
                          }
                      } catch (t) {
                          m.e(t)
                      } finally {
                          m.f()
                      }
                      var x, w = y(this.fancybox.$container.querySelectorAll("[data-fancybox-next]"));
                      try {
                          for (w.s(); !(x = w.n()).done;) {
                              var k = x.value;
                              i === n - 1 ? k.setAttribute("disabled", "") : k.removeAttribute("disabled")
                          }
                      } catch (t) {
                          w.e(t)
                      } finally {
                          w.f()
                      }
                  }
              }
          }, {
              key: "cleanup",
              value: function() {
                  this.Slideshow && this.Slideshow.isActive() && this.Slideshow.clearTimer(), this.$container && this.$container.remove(), this.$container = null
              }
          }, {
              key: "attach",
              value: function() {
                  this.fancybox.on(this.events)
              }
          }, {
              key: "detach",
              value: function() {
                  this.fancybox.off(this.events), this.cleanup()
              }
          }]), t
      }();
  G.defaults = Z;
  var K = {
          ScrollLock: B,
          Thumbs: H,
          Html: j,
          Toolbar: G,
          Image: X,
          Hash: Y
      },
      J = {
          startIndex: 0,
          preload: 1,
          infinite: !0,
          showClass: "fancybox-zoomInUp",
          hideClass: "fancybox-fadeOut",
          animated: !0,
          hideScrollbar: !0,
          parentEl: null,
          mainClass: null,
          autoFocus: !0,
          trapFocus: !0,
          placeFocusBack: !0,
          click: "close",
          closeButton: "inside",
          dragToClose: !0,
          keyboard: {
              Escape: "close",
              Delete: "close",
              Backspace: "close",
              PageUp: "next",
              PageDown: "prev",
              ArrowUp: "next",
              ArrowDown: "prev",
              ArrowRight: "next",
              ArrowLeft: "prev"
          },
          template: {
              closeButton: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg>',
              spinner: '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="25 25 50 50" tabindex="-1"><circle cx="50" cy="50" r="20"/></svg>',
              main: null
          },
          l10n: {
              CLOSE: "Close",
              NEXT: "Next",
              PREV: "Previous",
              MODAL: "You can close this modal content with the ESC key",
              ERROR: "Something Went Wrong, Please Try Again Later",
              IMAGE_ERROR: "Image Not Found",
              ELEMENT_NOT_FOUND: "HTML Element Not Found",
              AJAX_NOT_FOUND: "Error Loading AJAX : Not Found",
              AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden",
              IFRAME_ERROR: "Error Loading Page",
              TOGGLE_ZOOM: "Toggle zoom level",
              TOGGLE_THUMBS: "Toggle thumbnails",
              TOGGLE_SLIDESHOW: "Toggle slideshow",
              TOGGLE_FULLSCREEN: "Toggle full-screen mode",
              DOWNLOAD: "Download"
          }
      },
      Q = 0,
      tt = function(t) {
          l(i, t);
          var e = f(i);

          function i(t) {
              var n, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              return o(this, i), (n = e.call(this, x(!0, {}, J, a))).bindHandlers(), n.state = "init", n.setItems(t), n.attachPlugins(i.Plugins), n.trigger("init"), !0 === n.option("hideScrollbar") && n.hideScrollbar(), n.initLayout(), n.initCarousel(), n.attachEvents(), n.trigger("prepare"), n.state = "ready", n.trigger("ready"), n.$container.setAttribute("aria-hidden", "false"), n.focus(), n
          }
          return s(i, [{
              key: "bindHandlers",
              value: function() {
                  for (var t = 0, e = ["onMousedown", "onKeydown", "onClick", "onCreateSlide", "onTouchMove", "onTouchEnd", "onTransform"]; t < e.length; t++) {
                      var i = e[t];
                      this[i] = this[i].bind(this)
                  }
              }
          }, {
              key: "attachEvents",
              value: function() {
                  document.addEventListener("mousedown", this.onMousedown), document.addEventListener("keydown", this.onKeydown), this.$container.addEventListener("click", this.onClick)
              }
          }, {
              key: "detachEvents",
              value: function() {
                  document.removeEventListener("mousedown", this.onMousedown), document.removeEventListener("keydown", this.onKeydown), this.$container.removeEventListener("click", this.onClick)
              }
          }, {
              key: "initLayout",
              value: function() {
                  var t = this;
                  this.$root = this.option("parentEl") || document.body;
                  var e = this.option("template.main");
                  e && (this.$root.insertAdjacentHTML("beforeend", this.localize(e)), this.$container = this.$root.querySelector(".fancybox__container")), this.$container || (this.$container = document.createElement("div"), this.$root.appendChild(this.$container)), this.$container.onscroll = function() {
                      return t.$container.scrollLeft = 0, !1
                  }, Object.entries({
                      class: "fancybox__container",
                      role: "dialog",
                      "aria-modal": "true",
                      "aria-hidden": "true",
                      "aria-label": this.localize("{{MODAL}}")
                  }).forEach((function(e) {
                      var i;
                      return (i = t.$container).setAttribute.apply(i, p(e))
                  })), this.option("animated") && this.$container.classList.add("is-animated"), this.$backdrop = this.$container.querySelector(".fancybox__backdrop"), this.$backdrop || (this.$backdrop = document.createElement("div"), this.$backdrop.classList.add("fancybox__backdrop"), this.$container.appendChild(this.$backdrop)), this.$carousel = this.$container.querySelector(".fancybox__carousel"), this.$carousel || (this.$carousel = document.createElement("div"), this.$carousel.classList.add("fancybox__carousel"), this.$container.appendChild(this.$carousel)), this.$container.Fancybox = this, this.id = this.$container.getAttribute("id"), this.id || (this.id = this.options.id || ++Q, this.$container.setAttribute("id", "fancybox-" + this.id));
                  var i, n = this.options.mainClass;
                  n && (i = this.$container.classList).add.apply(i, p(n.split(" ")));
                  return document.documentElement.classList.add("with-fancybox"), this.trigger("initLayout"), this
              }
          }, {
              key: "setItems",
              value: function(t) {
                  var e, i = [],
                      n = y(t);
                  try {
                      for (n.s(); !(e = n.n()).done;) {
                          var o = e.value,
                              a = o.$trigger;
                          if (a) {
                              var s = a.dataset || {};
                              o.src = s.src || a.getAttribute("href") || o.src, o.type = s.type || o.type, !o.src && a instanceof HTMLImageElement && (o.src = a.currentSrc || o.$trigger.src)
                          }
                          var r = o.$thumb;
                          if (!r) {
                              var l = o.$trigger && o.$trigger.origTarget;
                              l && (r = l instanceof HTMLImageElement ? l : l.querySelector("img")), !r && o.$trigger && (r = o.$trigger instanceof HTMLImageElement ? o.$trigger : o.$trigger.querySelector("img"))
                          }
                          o.$thumb = r || null;
                          var c = o.thumb;
                          !c && o.$thumb && (c = r.currentSrc || r.src), c || "image" !== o.type || (c = o.src), o.thumb = c || null, o.caption = o.caption || "", i.push(o)
                      }
                  } catch (t) {
                      n.e(t)
                  } finally {
                      n.f()
                  }
                  this.items = i
              }
          }, {
              key: "initCarousel",
              value: function() {
                  var t = this;
                  return this.Carousel = new N(this.$carousel, x(!0, {}, {
                      classNames: {
                          viewport: "fancybox__viewport",
                          track: "fancybox__track",
                          slide: "fancybox__slide"
                      },
                      textSelection: !0,
                      preload: this.option("preload"),
                      friction: .88,
                      slides: this.items,
                      initialPage: this.options.startIndex,
                      slidesPerPage: 1,
                      infiniteX: this.option("infinite"),
                      infiniteY: !0,
                      l10n: this.option("l10n"),
                      Dots: !1,
                      Navigation: {
                          classNames: {
                              main: "fancybox__nav",
                              button: "carousel__button",
                              next: "is-next",
                              prev: "is-prev"
                          }
                      },
                      Panzoom: {
                          textSelection: !0,
                          panOnlyZoomed: function() {
                              return t.Carousel && t.Carousel.pages && t.Carousel.pages.length < 2 && !t.options.dragToClose
                          },
                          lockAxis: function() {
                              if (t.Carousel) {
                                  var e = "x";
                                  return t.options.dragToClose && (e += "y"), e
                              }
                          }
                      },
                      on: {
                          "*": function(e) {
                              for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) n[o - 1] = arguments[o];
                              return t.trigger.apply(t, ["Carousel.".concat(e)].concat(n))
                          },
                          init: function(e) {
                              return t.Carousel = e
                          },
                          createSlide: this.onCreateSlide
                      }
                  }, this.option("Carousel"))), this.option("dragToClose") && this.Carousel.Panzoom.on({
                      touchMove: this.onTouchMove,
                      afterTransform: this.onTransform,
                      touchEnd: this.onTouchEnd
                  }), this.trigger("initCarousel"), this
              }
          }, {
              key: "onCreateSlide",
              value: function(t, e) {
                  var i = e.caption || "";
                  if ("function" == typeof this.options.caption && (i = this.options.caption.call(this, this, this.Carousel, e)), "string" == typeof i && i.length) {
                      var n = document.createElement("div"),
                          o = "fancybox__caption_".concat(this.id, "_").concat(e.index);
                      n.className = "fancybox__caption", n.innerHTML = i, n.setAttribute("id", o), e.$caption = e.$el.appendChild(n), e.$el.classList.add("has-caption"), e.$el.setAttribute("aria-labelledby", o)
                  }
              }
          }, {
              key: "onClick",
              value: function(t) {
                  if (!t.defaultPrevented && (!t.target.closest(".fancybox__content") && !window.getSelection().toString().length && !1 !== this.trigger("click", t))) switch (this.option("click")) {
                      case "close":
                          this.close();
                          break;
                      case "next":
                          this.next()
                  }
              }
          }, {
              key: "onTouchMove",
              value: function() {
                  var t = this.getSlide().Panzoom;
                  return !t || 1 === t.content.scale
              }
          }, {
              key: "onTouchEnd",
              value: function(t) {
                  var e = t.dragOffset.y;
                  Math.abs(e) >= 150 || Math.abs(e) >= 35 && t.dragOffset.time < 350 ? (this.option("hideClass") && (this.getSlide().hideClass = "fancybox-throwOut".concat(t.content.y < 0 ? "Up" : "Down")), this.close()) : "y" === t.lockAxis && t.panTo({
                      y: 0
                  })
              }
          }, {
              key: "onTransform",
              value: function(t) {
                  if (this.$backdrop) {
                      var e = Math.abs(t.content.y),
                          i = e < 1 ? "" : Math.max(.33, Math.min(1, 1 - e / t.content.fitHeight * 1.5));
                      this.$container.style.setProperty("--fancybox-ts", i ? "0s" : ""), this.$container.style.setProperty("--fancybox-opacity", i)
                  }
              }
          }, {
              key: "onMousedown",
              value: function() {
                  document.body.classList.add("is-using-mouse")
              }
          }, {
              key: "onKeydown",
              value: function(t) {
                  if (i.getInstance().id === this.id) {
                      document.body.classList.remove("is-using-mouse");
                      var e = t.key;
                      if ("Tab" === e && this.option("trapFocus")) this.focus(t);
                      else {
                          var n = this.option("keyboard");
                          if (n && !t.ctrlKey && !t.altKey && !t.shiftKey) {
                              var o = document.activeElement && document.activeElement.classList,
                                  a = o && o.contains("carousel__button");
                              if ("Escape" !== e && !a)
                                  if (t.target.isContentEditable || -1 !== ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(t.target.nodeName)) return;
                              if (!1 !== this.trigger("keydown", e, t)) {
                                  var s = n[e];
                                  "function" == typeof this[s] && this[s]()
                              }
                          }
                      }
                  }
              }
          }, {
              key: "getSlide",
              value: function() {
                  var t = this.Carousel;
                  if (!t) return null;
                  var e = null === t.page ? t.option("initialPage") : t.page,
                      i = t.pages || [];
                  return i.length && i[e] ? i[e].slides[0] : null
              }
          }, {
              key: "focus",
              value: function(t) {
                  var e;
                  void 0 === i.preventScrollSupported && (i.preventScrollSupported = (e = !1, document.createElement("div").focus({
                      get preventScroll() {
                          return e = !0, !1
                      }
                  }), e));
                  var n = function(t) {
                      t.setActive ? t.setActive() : i.preventScrollSupported ? t.focus({
                          preventScroll: !0
                      }) : t.focus()
                  };
                  if (!(["init", "closing", "customClosing", "destroy"].indexOf(this.state) > -1)) {
                      t && t.preventDefault();
                      var o = this.getSlide().$el;
                      if (o) {
                          o.tabIndex = 0;
                          var a, s = [],
                              r = y([].slice.call(this.$container.querySelectorAll(["a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden])", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])'])));
                          try {
                              for (r.s(); !(a = r.n()).done;) {
                                  var l = a.value;
                                  if (!l.classList || !l.classList.contains("fancybox__slide")) {
                                      var c = l.closest(".fancybox__slide");
                                      c ? c === o && s[l.hasAttribute("autofocus") ? "unshift" : "push"](l) : s.push(l)
                                  }
                              }
                          } catch (t) {
                              r.e(t)
                          } finally {
                              r.f()
                          }
                          if (s.length) {
                              this.Carousel.pages.length > 1 && s.push(o), s.sort((function(t, e) {
                                  return t.tabIndex > e.tabIndex ? -1 : t.tabIndex < e.tabIndex ? 1 : 0
                              }));
                              var h = s.indexOf(document.activeElement),
                                  d = t && !t.shiftKey,
                                  u = t && t.shiftKey;
                              return d ? h === s.length - 1 ? n(s[0]) : n(s[h + 1]) : u ? n(0 === h ? s[s.length - 1] : s[h - 1]) : h < 0 ? n(s[0]) : void 0
                          }
                      }
                  }
              }
          }, {
              key: "hideScrollbar",
              value: function() {
                  if (D) {
                      var t = window.innerWidth - document.documentElement.getBoundingClientRect().width,
                          e = "fancybox-style-noscroll",
                          i = document.getElementById(e);
                      i || t > 0 && ((i = document.createElement("style")).id = e, i.type = "text/css", i.innerHTML = ".compensate-for-scrollbar {padding-right: ".concat(t, "px;}"), document.getElementsByTagName("head")[0].appendChild(i), document.body.classList.add("compensate-for-scrollbar"))
                  }
              }
          }, {
              key: "revealScrollbar",
              value: function() {
                  document.body.classList.remove("compensate-for-scrollbar");
                  var t = document.getElementById("fancybox-style-noscroll");
                  t && t.remove()
              }
          }, {
              key: "clearContent",
              value: function(t) {
                  this.Carousel.trigger("removeSlide", t), t.$content && (t.$content.remove(), t.$content = null), t._className && t.$el.classList.remove(t._className)
              }
          }, {
              key: "setContent",
              value: function(t, e) {
                  var i, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                      o = t.$el;
                  if (e instanceof HTMLElement ? ["img", "iframe", "video", "audio"].indexOf(e.nodeName.toLowerCase()) > -1 ? (i = document.createElement("div")).appendChild(e) : i = e : (i = document.createElement("div")).innerHTML = e, !(i instanceof Element)) throw new Error("Element expected");
                  return t._className = "has-".concat(n.suffix || t.type || "unknown"), o.classList.add(t._className), i.classList.add("fancybox__content"), "none" !== i.style.display && "none" !== window.getComputedStyle(i).getPropertyValue("display") || (i.style.display = "flex"), t.id && i.setAttribute("id", t.id), t.$content = i, o.prepend(i), this.manageCloseButton(t), "loading" !== t.state && this.revealContent(t), i
              }
          }, {
              key: "manageCloseButton",
              value: function(t) {
                  var e = this,
                      i = void 0 === t.closeButton ? this.option("closeButton") : t.closeButton;
                  if (i && ("top" !== i || !this.$closeButton)) {
                      var n = document.createElement("button");
                      n.classList.add("carousel__button", "is-close"), n.setAttribute("title", this.options.l10n.CLOSE), n.innerHTML = this.option("template.closeButton"), n.addEventListener("click", (function(t) {
                          return e.close(t)
                      })), "inside" === i ? (t.$closeButton && t.$closeButton.remove(), t.$closeButton = t.$content.appendChild(n)) : this.$closeButton = this.$container.insertBefore(n, this.$container.firstChild)
                  }
              }
          }, {
              key: "revealContent",
              value: function(t) {
                  var e = this;
                  this.trigger("reveal", t), t.$content.style.visibility = "";
                  var i = !1;
                  t.error || "loading" === t.state || null !== this.Carousel.prevPage || t.index !== this.options.startIndex || (i = void 0 === t.showClass ? this.option("showClass") : t.showClass), i ? (t.state = "animating", this.animateCSS(t.$content, i, (function() {
                      e.done(t)
                  }))) : this.done(t)
              }
          }, {
              key: "animateCSS",
              value: function(t, e, i) {
                  if (t && t.dispatchEvent(new CustomEvent("animationend", {
                          bubbles: !0,
                          cancelable: !0
                      })), t && e) {
                      t.addEventListener("animationend", (function n(o) {
                          o.currentTarget === this && (t.removeEventListener("animationend", n), i && i(), t.classList.remove(e))
                      })), t.classList.add(e)
                  } else "function" == typeof i && i()
              }
          }, {
              key: "done",
              value: function(t) {
                  t.state = "done", this.trigger("done", t);
                  var e = this.getSlide();
                  e && t.index === e.index && this.option("autoFocus") && this.focus()
              }
          }, {
              key: "setError",
              value: function(t, e) {
                  t.error = e, this.hideLoading(t), this.clearContent(t);
                  var i = document.createElement("div");
                  i.classList.add("fancybox-error"), i.innerHTML = this.localize(e || "<p>{{ERROR}}</p>"), this.setContent(t, i, {
                      suffix: "error"
                  })
              }
          }, {
              key: "showLoading",
              value: function(t) {
                  var e = this;
                  t.state = "loading", t.$el.classList.add("is-loading");
                  var i = t.$el.querySelector(".fancybox__spinner");
                  i || ((i = document.createElement("div")).classList.add("fancybox__spinner"), i.innerHTML = this.option("template.spinner"), i.addEventListener("click", (function() {
                      e.Carousel.Panzoom.velocity || e.close()
                  })), t.$el.prepend(i))
              }
          }, {
              key: "hideLoading",
              value: function(t) {
                  var e = t.$el && t.$el.querySelector(".fancybox__spinner");
                  e && (e.remove(), t.$el.classList.remove("is-loading")), "loading" === t.state && (this.trigger("load", t), t.state = "ready")
              }
          }, {
              key: "next",
              value: function() {
                  var t = this.Carousel;
                  t && t.pages.length > 1 && t.slideNext()
              }
          }, {
              key: "prev",
              value: function() {
                  var t = this.Carousel;
                  t && t.pages.length > 1 && t.slidePrev()
              }
          }, {
              key: "jumpTo",
              value: function() {
                  var t;
                  this.Carousel && (t = this.Carousel).slideTo.apply(t, arguments)
              }
          }, {
              key: "close",
              value: function(t) {
                  var e = this;
                  if (t && t.preventDefault(), !(["closing", "customClosing", "destroy"].indexOf(this.state) > -1) && !1 !== this.trigger("shouldClose", t) && (this.state = "closing", this.Carousel.Panzoom.destroy(), this.detachEvents(), this.trigger("closing", t), "destroy" !== this.state)) {
                      this.$container.setAttribute("aria-hidden", "true"), this.$container.classList.add("is-closing");
                      var i = this.getSlide();
                      if (this.Carousel.slides.forEach((function(t) {
                              t.$content && t.index !== i.index && e.Carousel.trigger("removeSlide", t)
                          })), "closing" === this.state) {
                          var n = void 0 === i.hideClass ? this.option("hideClass") : i.hideClass;
                          this.animateCSS(i.$content, n, (function() {
                              e.destroy()
                          }), !0)
                      }
                  }
              }
          }, {
              key: "destroy",
              value: function() {
                  this.state = "destroy", this.trigger("destroy");
                  var t = this.option("placeFocusBack") ? this.getSlide().$trigger : null;
                  if (this.Carousel.destroy(), this.detachPlugins(), this.Carousel = null, this.options = {}, this.events = {}, this.$container.remove(), this.$container = this.$backdrop = this.$carousel = null, t)
                      if (i.preventScrollSupported) t.focus({
                          preventScroll: !0
                      });
                      else {
                          var e = document.body.scrollTop;
                          t.focus(), document.body.scrollTop = e
                      } var n = i.getInstance();
                  n ? n.focus() : (document.documentElement.classList.remove("with-fancybox"), document.body.classList.remove("is-using-mouse"), this.revealScrollbar())
              }
          }], [{
              key: "show",
              value: function(t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                  return new i(t, e)
              }
          }, {
              key: "fromEvent",
              value: function(t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                  if (!t.defaultPrevented && !(t.button && 0 !== t.button || t.ctrlKey || t.metaKey || t.shiftKey)) {
                      var n, o, a, s = t.target;
                      if ((s.matches("[data-fancybox-trigger]") || (s = s.closest("[data-fancybox-trigger]"))) && (n = s && s.dataset && s.dataset.fancyboxTrigger), n) {
                          var r = document.querySelectorAll('[data-fancybox="'.concat(n, '"]')),
                              l = parseInt(s.dataset.fancyboxIndex, 10) || 0;
                          s = r.length ? r[l] : s
                      }
                      s || (s = t.target), Array.from(i.openers.keys()).reverse().some((function(e) {
                          if ((a = s).matches(e) || (a = a.closest(e))) return t.preventDefault(), o = e, !0
                      }));
                      var c = !1;
                      if (o) {
                          e.event = t, e.target = a, a.origTarget = t.target, c = i.fromOpener(o, e);
                          var h = i.getInstance();
                          h && "ready" === h.state && t.detail && document.body.classList.add("is-using-mouse")
                      }
                      return c
                  }
              }
          }, {
              key: "fromOpener",
              value: function(t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      n = function(t) {
                          for (var e = ["false", "0", "no", "null", "undefined"], i = ["true", "1", "yes"], n = Object.assign({}, t.dataset), o = 0, a = Object.entries(n); o < a.length; o++) {
                              var s = v(a[o], 2),
                                  r = s[0],
                                  l = s[1];
                              if ("string" == typeof l || l instanceof String)
                                  if (e.indexOf(l) > -1) n[r] = !1;
                                  else if (i.indexOf(n[r]) > -1) n[r] = !0;
                              else try {
                                  n[r] = JSON.parse(l)
                              } catch (t) {
                                  n[r] = l
                              }
                          }
                          return delete n.fancybox, delete n.type, t instanceof Element && (n.$trigger = t), n
                      },
                      o = [],
                      a = e.startIndex || 0,
                      s = e.target || null,
                      r = void 0 === (e = x({}, e, i.openers.get(t))).groupAttr ? "data-fancybox" : e.groupAttr,
                      l = r && s && s.getAttribute("".concat(r)),
                      c = void 0 !== e.groupAll && e.groupAll;
                  if (c || l ? (o = [].slice.call(document.querySelectorAll(t)), c || (o = o.filter((function(t) {
                          return t.getAttribute("".concat(r)) === l
                      })))) : o = [s], !o.length) return !1;
                  var h = i.getInstance();
                  return !(h && o.indexOf(h.options.$trigger) > -1) && (a = s ? o.indexOf(s) : a, new i(o = o.map(n), x({}, e, {
                      startIndex: a,
                      $trigger: s
                  })))
              }
          }, {
              key: "bind",
              value: function(t) {
                  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                  if (D) {
                      if (!i.openers.size) {
                          document.body.addEventListener("click", i.fromEvent, !1);
                          for (var n = 0, o = Object.entries(i.Plugins || {}); n < o.length; n++) {
                              var a = v(o[n], 2);
                              a[0];
                              var s = a[1];
                              s.Fancybox = this, "function" == typeof s.create && s.create()
                          }
                      }
                      i.openers.set(t, e)
                  }
              }
          }, {
              key: "unbind",
              value: function(t) {
                  i.openers.delete(t), i.openers.size || i.destroy()
              }
          }, {
              key: "destroy",
              value: function() {
                  for (var t; t = i.getInstance();) t.destroy();
                  i.openers = new Map, document.body.removeEventListener("click", i.fromEvent, !1)
              }
          }, {
              key: "getInstance",
              value: function(t) {
                  var e, i = y(t ? [document.getElementById("fancybox-".concat(t))] : Array.from(document.querySelectorAll(".fancybox__container")).reverse());
                  try {
                      for (i.s(); !(e = i.n()).done;) {
                          var n = e.value,
                              o = n && n.Fancybox;
                          if (o && "closing" !== o.state && "customClosing" !== o.state) return o
                      }
                  } catch (t) {
                      i.e(t)
                  } finally {
                      i.f()
                  }
                  return null
              }
          }, {
              key: "close",
              value: function() {
                  for (var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e = null; e = i.getInstance();)
                      if (e.close(), !t) return
              }
          }]), i
      }(L);
  tt.version = "4.0.0-beta.1", tt.defaults = J, tt.openers = new Map, tt.Plugins = K, tt.bind("[data-fancybox]"), t.Carousel = N, t.Fancybox = tt, t.Panzoom = O
}));

/*!
* dist/jquery.inputmask.min
* https://github.com/RobinHerbots/Inputmask
* Copyright (c) 2010 - 2020 Robin Herbots
* Licensed under the MIT license
* Version: 5.0.6-beta.19
*/
! function webpackUniversalModuleDefinition(root, factory) {
  if ("object" == typeof exports && "object" == typeof module) module.exports = factory(require("jquery"));
  else if ("function" == typeof define && define.amd) define(["jquery"], factory);
  else {
      var a = "object" == typeof exports ? factory(require("jquery")) : factory(root.jQuery);
      for (var i in a)("object" == typeof exports ? exports : root)[i] = a[i]
  }
}(this, function(__WEBPACK_EXTERNAL_MODULE__10__) {
  return modules = [function(module) {
      module.exports = JSON.parse('{"BACKSPACE":8,"BACKSPACE_SAFARI":127,"DELETE":46,"DOWN":40,"END":35,"ENTER":13,"ESCAPE":27,"HOME":36,"INSERT":45,"LEFT":37,"PAGE_DOWN":34,"PAGE_UP":33,"RIGHT":39,"SPACE":32,"TAB":9,"UP":38,"X":88,"CONTROL":17,"KEY_229":229}')
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = void 0, __webpack_require__(17), __webpack_require__(18);
      var _mask = __webpack_require__(11),
          _inputmask = _interopRequireDefault(__webpack_require__(13)),
          _window = _interopRequireDefault(__webpack_require__(8)),
          _maskLexer = __webpack_require__(19),
          _validationTests = __webpack_require__(3),
          _positioning = __webpack_require__(2),
          _validation = __webpack_require__(4),
          _inputHandling = __webpack_require__(5),
          _eventruler = __webpack_require__(12),
          _definitions = _interopRequireDefault(__webpack_require__(20)),
          _defaults = _interopRequireDefault(__webpack_require__(21)),
          _canUseDOM = _interopRequireDefault(__webpack_require__(9));

      function _typeof(obj) {
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
              return typeof obj
          } : function _typeof(obj) {
              return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
          }, _typeof(obj)
      }

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var document = _window.default.document,
          dataKey = "_inputmask_opts";

      function Inputmask(alias, options, internal) {
          if (_canUseDOM.default) {
              if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);
              this.dependencyLib = _inputmask.default, this.el = void 0, this.events = {}, this.maskset = void 0, !0 !== internal && ("[object Object]" === Object.prototype.toString.call(alias) ? options = alias : (options = options || {}, alias && (options.alias = alias)), this.opts = _inputmask.default.extend(!0, {}, this.defaults, options), this.noMasksCache = options && void 0 !== options.definitions, this.userOptions = options || {}, resolveAlias(this.opts.alias, options, this.opts)), this.refreshValue = !1, this.undoValue = void 0, this.$el = void 0, this.skipKeyPressEvent = !1, this.skipInputEvent = !1, this.validationEvent = !1, this.ignorable = !1, this.maxLength, this.mouseEnter = !1, this.originalPlaceholder = void 0, this.isComposing = !1
          }
      }

      function resolveAlias(aliasStr, options, opts) {
          var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
          return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts), _inputmask.default.extend(!0, opts, aliasDefinition), _inputmask.default.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), !1)
      }

      function importAttributeOptions(npt, opts, userOptions, dataAttribute) {
          function importOption(option, optionData) {
              var attrOption = "" === dataAttribute ? option : dataAttribute + "-" + option;
              optionData = void 0 !== optionData ? optionData : npt.getAttribute(attrOption), null !== optionData && ("string" == typeof optionData && (0 === option.indexOf("on") ? optionData = _window.default[optionData] : "false" === optionData ? optionData = !1 : "true" === optionData && (optionData = !0)), userOptions[option] = optionData)
          }
          if (!0 === opts.importDataAttributes) {
              var attrOptions = npt.getAttribute(dataAttribute),
                  option, dataoptions, optionData, p;
              if (attrOptions && "" !== attrOptions && (attrOptions = attrOptions.replace(/'/g, '"'), dataoptions = JSON.parse("{" + attrOptions + "}")), dataoptions)
                  for (p in optionData = void 0, dataoptions)
                      if ("alias" === p.toLowerCase()) {
                          optionData = dataoptions[p];
                          break
                      } for (option in importOption("alias", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts), opts) {
                  if (dataoptions)
                      for (p in optionData = void 0, dataoptions)
                          if (p.toLowerCase() === option.toLowerCase()) {
                              optionData = dataoptions[p];
                              break
                          } importOption(option, optionData)
              }
          }
          return _inputmask.default.extend(!0, opts, userOptions), "rtl" !== npt.dir && !opts.rightAlign || (npt.style.textAlign = "right"), "rtl" !== npt.dir && !opts.numericInput || (npt.dir = "ltr", npt.removeAttribute("dir"), opts.isRTL = !0), Object.keys(userOptions).length
      }
      Inputmask.prototype = {
          dataAttribute: "data-inputmask",
          defaults: _defaults.default,
          definitions: _definitions.default,
          aliases: {},
          masksCache: {},
          get isRTL() {
              return this.opts.isRTL || this.opts.numericInput
          },
          mask: function mask(elems) {
              var that = this;
              return "string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : Array.isArray(elems) ? elems : Array.from(elems), elems.forEach(function(el, ndx) {
                  var scopedOpts = _inputmask.default.extend(!0, {}, that.opts);
                  if (importAttributeOptions(el, scopedOpts, _inputmask.default.extend(!0, {}, that.userOptions), that.dataAttribute)) {
                      var maskset = (0, _maskLexer.generateMaskSet)(scopedOpts, that.noMasksCache);
                      void 0 !== maskset && (void 0 !== el.inputmask && (el.inputmask.opts.autoUnmask = !0, el.inputmask.remove()), el.inputmask = new Inputmask(void 0, void 0, !0), el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = _inputmask.default.extend(!0, {}, that.userOptions), el.inputmask.el = el, el.inputmask.$el = (0, _inputmask.default)(el), el.inputmask.maskset = maskset, _inputmask.default.data(el, dataKey, that.userOptions), _mask.mask.call(el.inputmask))
                  }
              }), elems && elems[0] && elems[0].inputmask || this
          },
          option: function option(options, noremask) {
              return "string" == typeof options ? this.opts[options] : "object" === _typeof(options) ? (_inputmask.default.extend(this.userOptions, options), this.el && !0 !== noremask && this.mask(this.el), this) : void 0
          },
          unmaskedvalue: function unmaskedvalue(value) {
              if (this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), void 0 === this.el || void 0 !== value) {
                  var valueBuffer = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, value, this.opts) || value).split("");
                  _inputHandling.checkVal.call(this, void 0, !1, !1, valueBuffer), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, _positioning.getBuffer.call(this), 0, this.opts)
              }
              return _inputHandling.unmaskedvalue.call(this, this.el)
          },
          remove: function remove() {
              if (this.el) {
                  _inputmask.default.data(this.el, dataKey, null);
                  var cv = this.opts.autoUnmask ? (0, _inputHandling.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask),
                      valueProperty;
                  cv !== _positioning.getBufferTemplate.call(this).join("") ? this._valueSet(cv, this.opts.autoUnmask) : this._valueSet(""), _eventruler.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? (valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value"), valueProperty && this.__valueGet && Object.defineProperty(this.el, "value", {
                      get: this.__valueGet,
                      set: this.__valueSet,
                      configurable: !0
                  })) : document.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0
              }
              return this.el
          },
          getemptymask: function getemptymask() {
              return this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), _positioning.getBufferTemplate.call(this).join("")
          },
          hasMaskedValue: function hasMaskedValue() {
              return !this.opts.autoUnmask
          },
          isComplete: function isComplete() {
              return this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), _validation.isComplete.call(this, _positioning.getBuffer.call(this))
          },
          getmetadata: function getmetadata() {
              if (this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), Array.isArray(this.maskset.metadata)) {
                  var maskTarget = _validationTests.getMaskTemplate.call(this, !0, 0, !1).join("");
                  return this.maskset.metadata.forEach(function(mtdt) {
                      return mtdt.mask !== maskTarget || (maskTarget = mtdt, !1)
                  }), maskTarget
              }
              return this.maskset.metadata
          },
          isValid: function isValid(value) {
              if (this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), value) {
                  var valueBuffer = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, value, this.opts) || value).split("");
                  _inputHandling.checkVal.call(this, void 0, !0, !1, valueBuffer)
              } else value = this.isRTL ? _positioning.getBuffer.call(this).slice().reverse().join("") : _positioning.getBuffer.call(this).join("");
              for (var buffer = _positioning.getBuffer.call(this), rl = _positioning.determineLastRequiredPosition.call(this), lmib = buffer.length - 1; rl < lmib && !_positioning.isMask.call(this, lmib); lmib--);
              return buffer.splice(rl, lmib + 1 - rl), _validation.isComplete.call(this, buffer) && value === (this.isRTL ? _positioning.getBuffer.call(this).slice().reverse().join("") : _positioning.getBuffer.call(this).join(""))
          },
          format: function format(value, metadata) {
              this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache);
              var valueBuffer = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, value, this.opts) || value).split("");
              _inputHandling.checkVal.call(this, void 0, !0, !1, valueBuffer);
              var formattedValue = this.isRTL ? _positioning.getBuffer.call(this).slice().reverse().join("") : _positioning.getBuffer.call(this).join("");
              return metadata ? {
                  value: formattedValue,
                  metadata: this.getmetadata()
              } : formattedValue
          },
          setValue: function setValue(value) {
              this.el && (0, _inputmask.default)(this.el).trigger("setvalue", [value])
          },
          analyseMask: _maskLexer.analyseMask
      }, Inputmask.extendDefaults = function(options) {
          _inputmask.default.extend(!0, Inputmask.prototype.defaults, options)
      }, Inputmask.extendDefinitions = function(definition) {
          _inputmask.default.extend(!0, Inputmask.prototype.definitions, definition)
      }, Inputmask.extendAliases = function(alias) {
          _inputmask.default.extend(!0, Inputmask.prototype.aliases, alias)
      }, Inputmask.format = function(value, options, metadata) {
          return Inputmask(options).format(value, metadata)
      }, Inputmask.unmask = function(value, options) {
          return Inputmask(options).unmaskedvalue(value)
      }, Inputmask.isValid = function(value, options) {
          return Inputmask(options).isValid(value)
      }, Inputmask.remove = function(elems) {
          "string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, elems.forEach(function(el) {
              el.inputmask && el.inputmask.remove()
          })
      }, Inputmask.setValue = function(elems, value) {
          "string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, elems.forEach(function(el) {
              el.inputmask ? el.inputmask.setValue(value) : (0, _inputmask.default)(el).trigger("setvalue", [value])
          })
      }, Inputmask.dependencyLib = _inputmask.default, _window.default.Inputmask = Inputmask;
      var _default = Inputmask;
      exports.default = _default
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.caret = caret, exports.determineLastRequiredPosition = determineLastRequiredPosition, exports.determineNewCaretPosition = determineNewCaretPosition, exports.getBuffer = getBuffer, exports.getBufferTemplate = getBufferTemplate, exports.getLastValidPosition = getLastValidPosition, exports.isMask = isMask, exports.resetMaskSet = resetMaskSet, exports.seekNext = seekNext, exports.seekPrevious = seekPrevious, exports.translatePosition = translatePosition;
      var _validationTests = __webpack_require__(3),
          _validation = __webpack_require__(4),
          _mask = __webpack_require__(11);

      function caret(input, begin, end, notranslate, isDelete) {
          var inputmask = this,
              opts = this.opts,
              range;
          if (void 0 === begin) return "selectionStart" in input && "selectionEnd" in input ? (begin = input.selectionStart, end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0), range.commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, end = range.endOffset)) : document.selection && document.selection.createRange && (range = document.selection.createRange(), begin = 0 - range.duplicate().moveStart("character", -input.inputmask._valueGet().length), end = begin + range.text.length), {
              begin: notranslate ? begin : translatePosition.call(this, begin),
              end: notranslate ? end : translatePosition.call(this, end)
          };
          if (Array.isArray(begin) && (end = this.isRTL ? begin[0] : begin[1], begin = this.isRTL ? begin[1] : begin[0]), void 0 !== begin.begin && (end = this.isRTL ? begin.begin : begin.end, begin = this.isRTL ? begin.end : begin.begin), "number" == typeof begin) {
              begin = notranslate ? begin : translatePosition.call(this, begin), end = notranslate ? end : translatePosition.call(this, end), end = "number" == typeof end ? end : begin;
              var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
              if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, input.inputmask.caretPos = {
                      begin: begin,
                      end: end
                  }, opts.insertModeVisual && !1 === opts.insertMode && begin === end && (isDelete || end++), input === (input.inputmask.shadowRoot || document).activeElement)
                  if ("setSelectionRange" in input) input.setSelectionRange(begin, end);
                  else if (window.getSelection) {
                  if (range = document.createRange(), void 0 === input.firstChild || null === input.firstChild) {
                      var textNode = document.createTextNode("");
                      input.appendChild(textNode)
                  }
                  range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), range.collapse(!0);
                  var sel = window.getSelection();
                  sel.removeAllRanges(), sel.addRange(range)
              } else input.createTextRange && (range = input.createTextRange(), range.collapse(!0), range.moveEnd("character", end), range.moveStart("character", begin), range.select())
          }
      }

      function determineLastRequiredPosition(returnDefinition) {
          var inputmask = this,
              maskset = this.maskset,
              $ = this.dependencyLib,
              buffer = _validationTests.getMaskTemplate.call(this, !0, getLastValidPosition.call(this), !0, !0),
              bl = buffer.length,
              pos, lvp = getLastValidPosition.call(this),
              positions = {},
              lvTest = maskset.validPositions[lvp],
              ndxIntlzr = void 0 !== lvTest ? lvTest.locator.slice() : void 0,
              testPos;
          for (pos = lvp + 1; pos < buffer.length; pos++) testPos = _validationTests.getTestTemplate.call(this, pos, ndxIntlzr, pos - 1), ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos);
          var lvTestAlt = lvTest && void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0;
          for (pos = bl - 1; lvp < pos && (testPos = positions[pos], (testPos.match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && 1 != testPos.match.static || !0 === testPos.match.static && testPos.locator[lvTest.alternation] && _validation.checkAlternationMatch.call(this, testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && "" !== _validationTests.getTests.call(this, pos)[0].def)) && buffer[pos] === _validationTests.getPlaceholder.call(this, pos, testPos.match)); pos--) bl--;
          return returnDefinition ? {
              l: bl,
              def: positions[bl] ? positions[bl].match : void 0
          } : bl
      }

      function determineNewCaretPosition(selectedCaret, tabbed) {
          var inputmask = this,
              maskset = this.maskset,
              opts = this.opts;

          function doRadixFocus(clickPos) {
              if ("" !== opts.radixPoint && 0 !== opts.digits) {
                  var vps = maskset.validPositions;
                  if (void 0 === vps[clickPos] || vps[clickPos].input === _validationTests.getPlaceholder.call(inputmask, clickPos)) {
                      if (clickPos < seekNext.call(inputmask, -1)) return !0;
                      var radixPos = getBuffer.call(inputmask).indexOf(opts.radixPoint);
                      if (-1 !== radixPos) {
                          for (var vp in vps)
                              if (vps[vp] && radixPos < vp && vps[vp].input !== _validationTests.getPlaceholder.call(inputmask, vp)) return !1;
                          return !0
                      }
                  }
              }
              return !1
          }
          if (tabbed && (inputmask.isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end), selectedCaret.begin === selectedCaret.end) {
              switch (opts.positionCaretOnClick) {
                  case "none":
                      break;
                  case "select":
                      selectedCaret = {
                          begin: 0,
                          end: getBuffer.call(inputmask).length
                      };
                      break;
                  case "ignore":
                      selectedCaret.end = selectedCaret.begin = seekNext.call(inputmask, getLastValidPosition.call(inputmask));
                      break;
                  case "radixFocus":
                      if (doRadixFocus(selectedCaret.begin)) {
                          var radixPos = getBuffer.call(inputmask).join("").indexOf(opts.radixPoint);
                          selectedCaret.end = selectedCaret.begin = opts.numericInput ? seekNext.call(inputmask, radixPos) : radixPos;
                          break
                      }
                  default:
                      var clickPosition = selectedCaret.begin,
                          lvclickPosition = getLastValidPosition.call(inputmask, clickPosition, !0),
                          lastPosition = seekNext.call(inputmask, -1 !== lvclickPosition || isMask.call(inputmask, 0) ? lvclickPosition : -1);
                      if (clickPosition <= lastPosition) selectedCaret.end = selectedCaret.begin = isMask.call(inputmask, clickPosition, !1, !0) ? clickPosition : seekNext.call(inputmask, clickPosition);
                      else {
                          var lvp = maskset.validPositions[lvclickPosition],
                              tt = _validationTests.getTestTemplate.call(inputmask, lastPosition, lvp ? lvp.match.locator : void 0, lvp),
                              placeholder = _validationTests.getPlaceholder.call(inputmask, lastPosition, tt.match);
                          if ("" !== placeholder && getBuffer.call(inputmask)[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask.call(inputmask, lastPosition, opts.keepStatic, !0) && tt.match.def === placeholder) {
                              var newPos = seekNext.call(inputmask, lastPosition);
                              (newPos <= clickPosition || clickPosition === lastPosition) && (lastPosition = newPos)
                          }
                          selectedCaret.end = selectedCaret.begin = lastPosition
                      }
              }
              return selectedCaret
          }
      }

      function getBuffer(noCache) {
          var inputmask = this,
              maskset = this.maskset;
          return void 0 !== maskset.buffer && !0 !== noCache || (maskset.buffer = _validationTests.getMaskTemplate.call(this, !0, getLastValidPosition.call(this), !0), void 0 === maskset._buffer && (maskset._buffer = maskset.buffer.slice())), maskset.buffer
      }

      function getBufferTemplate() {
          var inputmask = this,
              maskset = this.maskset;
          return void 0 === maskset._buffer && (maskset._buffer = _validationTests.getMaskTemplate.call(this, !1, 1), void 0 === maskset.buffer && (maskset.buffer = maskset._buffer.slice())), maskset._buffer
      }

      function getLastValidPosition(closestTo, strict, validPositions) {
          var maskset = this.maskset,
              before = -1,
              after = -1,
              valids = validPositions || maskset.validPositions;
          for (var posNdx in void 0 === closestTo && (closestTo = -1), valids) {
              var psNdx = parseInt(posNdx);
              valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx), closestTo <= psNdx && (after = psNdx))
          }
          return -1 === before || before == closestTo ? after : -1 == after ? before : closestTo - before < after - closestTo ? before : after
      }

      function isMask(pos, strict, fuzzy) {
          var inputmask = this,
              maskset = this.maskset,
              test = _validationTests.getTestTemplate.call(this, pos).match;
          if ("" === test.def && (test = _validationTests.getTest.call(this, pos).match), !0 !== test.static) return test.fn;
          if (!0 === fuzzy && void 0 !== maskset.validPositions[pos] && !0 !== maskset.validPositions[pos].generatedInput) return !0;
          if (!0 !== strict && -1 < pos) {
              if (fuzzy) {
                  var tests = _validationTests.getTests.call(this, pos);
                  return tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0)
              }
              var testTemplate = _validationTests.determineTestTemplate.call(this, pos, _validationTests.getTests.call(this, pos)),
                  testPlaceHolder = _validationTests.getPlaceholder.call(this, pos, testTemplate.match);
              return testTemplate.match.def !== testPlaceHolder
          }
          return !1
      }

      function resetMaskSet(soft) {
          var maskset = this.maskset;
          maskset.buffer = void 0, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0)
      }

      function seekNext(pos, newBlock, fuzzy) {
          var inputmask = this;
          void 0 === fuzzy && (fuzzy = !0);
          for (var position = pos + 1;
              "" !== _validationTests.getTest.call(this, position).match.def && (!0 === newBlock && (!0 !== _validationTests.getTest.call(this, position).match.newBlockMarker || !isMask.call(this, position, void 0, !0)) || !0 !== newBlock && !isMask.call(this, position, void 0, fuzzy));) position++;
          return position
      }

      function seekPrevious(pos, newBlock) {
          var inputmask = this,
              position = pos - 1;
          if (pos <= 0) return 0;
          for (; 0 < position && (!0 === newBlock && (!0 !== _validationTests.getTest.call(this, position).match.newBlockMarker || !isMask.call(this, position, void 0, !0)) || !0 !== newBlock && !isMask.call(this, position, void 0, !0));) position--;
          return position
      }

      function translatePosition(pos) {
          var inputmask = this,
              opts = this.opts,
              el = this.el;
          return !this.isRTL || "number" != typeof pos || opts.greedy && "" === opts.placeholder || !el || (pos = Math.abs(this._valueGet().length - pos)), pos
      }
  }, function(module, exports, __webpack_require__) {
      "use strict";

      function getLocator(tst, align) {
          var locator = (null != tst.alternation ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join("");
          if ("" !== locator)
              for (; locator.length < align;) locator += "0";
          return locator
      }

      function getDecisionTaker(tst) {
          var decisionTaker = tst.locator[tst.alternation];
          return "string" == typeof decisionTaker && 0 < decisionTaker.length && (decisionTaker = decisionTaker.split(",")[0]), void 0 !== decisionTaker ? decisionTaker.toString() : ""
      }

      function getPlaceholder(pos, test, returnPL) {
          var inputmask = this,
              opts = this.opts,
              maskset = this.maskset;
          if (test = test || getTest.call(this, pos).match, void 0 !== test.placeholder || !0 === returnPL) return "function" == typeof test.placeholder ? test.placeholder(opts) : test.placeholder;
          if (!0 !== test.static) return opts.placeholder.charAt(pos % opts.placeholder.length);
          if (-1 < pos && void 0 === maskset.validPositions[pos]) {
              var tests = getTests.call(this, pos),
                  staticAlternations = [],
                  prevTest;
              if (tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0))
                  for (var i = 0; i < tests.length; i++)
                      if ("" !== tests[i].match.def && !0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (!0 === tests[i].match.static || void 0 === prevTest || !1 !== tests[i].match.fn.test(prevTest.match.def, maskset, pos, !0, opts)) && (staticAlternations.push(tests[i]), !0 === tests[i].match.static && (prevTest = tests[i]), 1 < staticAlternations.length && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length)
          }
          return test.def
      }

      function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {
          var inputmask = this,
              opts = this.opts,
              maskset = this.maskset,
              greedy = opts.greedy;
          clearOptionalTail && (opts.greedy = !1), minimalPos = minimalPos || 0;
          var maskTemplate = [],
              ndxIntlzr, pos = 0,
              test, testPos, jitRenderStatic;
          do {
              if (!0 === baseOnInput && maskset.validPositions[pos]) testPos = clearOptionalTail && !0 === maskset.validPositions[pos].match.optionality && void 0 === maskset.validPositions[pos + 1] && (!0 === maskset.validPositions[pos].generatedInput || maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && 0 < pos) ? determineTestTemplate.call(this, pos, getTests.call(this, pos, ndxIntlzr, pos - 1)) : maskset.validPositions[pos], test = testPos.match, ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder.call(this, pos, test));
              else {
                  testPos = getTestTemplate.call(this, pos, ndxIntlzr, pos - 1), test = testPos.match, ndxIntlzr = testPos.locator.slice();
                  var jitMasking = !0 !== noJit && (!1 !== opts.jitMasking ? opts.jitMasking : test.jit);
                  jitRenderStatic = jitRenderStatic && test.static && test.def !== opts.groupSeparator && null === test.fn || maskset.validPositions[pos - 1] && test.static && test.def !== opts.groupSeparator && null === test.fn, jitRenderStatic || !1 === jitMasking || void 0 === jitMasking || "number" == typeof jitMasking && isFinite(jitMasking) && pos < jitMasking ? maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder.call(this, pos, test)) : jitRenderStatic = !1
              }
              pos++
          } while ((void 0 === this.maxLength || pos < this.maxLength) && (!0 !== test.static || "" !== test.def) || pos < minimalPos);
          return "" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), !1 === includeMode && void 0 !== maskset.maskLength || (maskset.maskLength = pos - 1), opts.greedy = greedy, maskTemplate
      }

      function getTestTemplate(pos, ndxIntlzr, tstPs) {
          var inputmask = this,
              maskset = this.maskset;
          return maskset.validPositions[pos] || determineTestTemplate.call(this, pos, getTests.call(this, pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs))
      }

      function determineTestTemplate(pos, tests) {
          var inputmask = this,
              opts = this.opts;
          pos = 0 < pos ? pos - 1 : 0;
          for (var altTest = getTest.call(this, pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch, ndx = 0; ndx < tests.length; ndx++) {
              var tst = tests[ndx];
              tstLocator = getLocator(tst, targetLocator.length);
              var distance = Math.abs(tstLocator - targetLocator);
              (void 0 === closest || "" !== tstLocator && distance < closest || bestMatch && !opts.greedy && bestMatch.match.optionality && "master" === bestMatch.match.newBlockMarker && (!tst.match.optionality || !tst.match.newBlockMarker) || bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier) && (closest = distance, bestMatch = tst)
          }
          return bestMatch
      }

      function getTest(pos, tests) {
          var inputmask = this,
              maskset = this.maskset;
          return maskset.validPositions[pos] ? maskset.validPositions[pos] : (tests || getTests.call(this, pos))[0]
      }

      function getTests(pos, ndxIntlzr, tstPs) {
          var inputmask = this,
              $ = this.dependencyLib,
              maskset = this.maskset,
              opts = this.opts,
              el = this.el,
              maskTokens = maskset.maskToken,
              testPos = ndxIntlzr ? tstPs : 0,
              ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],
              matches = [],
              insertStop = !1,
              latestMatch, cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";

          function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
              function handleMatch(match, loopNdx, quantifierRecurse) {
                  function isFirstMatch(latestMatch, tokenGroup) {
                      var firstMatch = 0 === tokenGroup.matches.indexOf(latestMatch);
                      return firstMatch || tokenGroup.matches.every(function(match, ndx) {
                          return !0 === match.isQuantifier ? firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]) : Object.prototype.hasOwnProperty.call(match, "matches") && (firstMatch = isFirstMatch(latestMatch, match)), !firstMatch
                      }), firstMatch
                  }

                  function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {
                      var bestMatch, indexPos;
                      if ((maskset.tests[pos] || maskset.validPositions[pos]) && (maskset.tests[pos] || [maskset.validPositions[pos]]).every(function(lmnt, ndx) {
                              if (lmnt.mloc[alternateNdx]) return bestMatch = lmnt, !1;
                              var alternation = void 0 !== targetAlternation ? targetAlternation : lmnt.alternation,
                                  ndxPos = void 0 !== lmnt.locator[alternation] ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;
                              return (void 0 === indexPos || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt, indexPos = ndxPos), !0
                          }), bestMatch) {
                          var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation],
                              locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;
                          return locator.slice((void 0 !== targetAlternation ? targetAlternation : bestMatch.alternation) + 1)
                      }
                      return void 0 !== targetAlternation ? resolveNdxInitializer(pos, alternateNdx) : void 0
                  }

                  function isSubsetOf(source, target) {
                      function expand(pattern) {
                          for (var expanded = [], start = -1, end, i = 0, l = pattern.length; i < l; i++)
                              if ("-" === pattern.charAt(i))
                                  for (end = pattern.charCodeAt(i + 1); ++start < end;) expanded.push(String.fromCharCode(start));
                              else start = pattern.charCodeAt(i), expanded.push(pattern.charAt(i));
                          return expanded.join("")
                      }
                      return source.match.def === target.match.nativeDef || !(!(opts.regex || source.match.fn instanceof RegExp && target.match.fn instanceof RegExp) || !0 === source.match.static || !0 === target.match.static) && -1 !== expand(target.match.fn.toString().replace(/[[\]/]/g, "")).indexOf(expand(source.match.fn.toString().replace(/[[\]/]/g, "")))
                  }

                  function staticCanMatchDefinition(source, target) {
                      return !0 === source.match.static && !0 !== target.match.static && target.match.fn.test(source.match.def, maskset, pos, !1, opts, !1)
                  }

                  function setMergeLocators(targetMatch, altMatch) {
                      var alternationNdx = targetMatch.alternation,
                          shouldMerge = void 0 === altMatch || alternationNdx === altMatch.alternation && -1 === targetMatch.locator[alternationNdx].toString().indexOf(altMatch.locator[alternationNdx]);
                      if (!shouldMerge && alternationNdx > altMatch.alternation)
                          for (var i = altMatch.alternation; i < alternationNdx; i++)
                              if (targetMatch.locator[i] !== altMatch.locator[i]) {
                                  alternationNdx = i, shouldMerge = !0;
                                  break
                              } if (shouldMerge) {
                          targetMatch.mloc = targetMatch.mloc || {};
                          var locNdx = targetMatch.locator[alternationNdx];
                          if (void 0 !== locNdx) {
                              if ("string" == typeof locNdx && (locNdx = locNdx.split(",")[0]), void 0 === targetMatch.mloc[locNdx] && (targetMatch.mloc[locNdx] = targetMatch.locator.slice()), void 0 !== altMatch) {
                                  for (var ndx in altMatch.mloc) "string" == typeof ndx && (ndx = ndx.split(",")[0]), void 0 === targetMatch.mloc[ndx] && (targetMatch.mloc[ndx] = altMatch.mloc[ndx]);
                                  targetMatch.locator[alternationNdx] = Object.keys(targetMatch.mloc).join(",")
                              }
                              return !0
                          }
                          targetMatch.alternation = void 0
                      }
                      return !1
                  }

                  function isSameLevel(targetMatch, altMatch) {
                      if (targetMatch.locator.length !== altMatch.locator.length) return !1;
                      for (var locNdx = targetMatch.alternation + 1; locNdx < targetMatch.locator.length; locNdx++)
                          if (targetMatch.locator[locNdx] !== altMatch.locator[locNdx]) return !1;
                      return !0
                  }
                  if (testPos > pos + opts._maxTestPos) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + maskset.mask;
                  if (testPos === pos && void 0 === match.matches) return matches.push({
                      match: match,
                      locator: loopNdx.reverse(),
                      cd: cacheDependency,
                      mloc: {}
                  }), !0;
                  if (void 0 !== match.matches) {
                      if (match.isGroup && quantifierRecurse !== match) {
                          if (match = handleMatch(maskToken.matches[maskToken.matches.indexOf(match) + 1], loopNdx, quantifierRecurse), match) return !0
                      } else if (match.isOptional) {
                          var optionalToken = match,
                              mtchsNdx = matches.length;
                          if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse), match) {
                              if (matches.forEach(function(mtch, ndx) {
                                      mtchsNdx <= ndx && (mtch.match.optionality = !0)
                                  }), latestMatch = matches[matches.length - 1].match, void 0 !== quantifierRecurse || !isFirstMatch(latestMatch, optionalToken)) return !0;
                              insertStop = !0, testPos = pos
                          }
                      } else if (match.isAlternator) {
                          var alternateToken = match,
                              malternateMatches = [],
                              maltMatches, currentMatches = matches.slice(),
                              loopNdxCnt = loopNdx.length,
                              unMatchedAlternation = !1,
                              altIndex = 0 < ndxInitializer.length ? ndxInitializer.shift() : -1;
                          if (-1 === altIndex || "string" == typeof altIndex) {
                              var currentPos = testPos,
                                  ndxInitializerClone = ndxInitializer.slice(),
                                  altIndexArr = [],
                                  amndx;
                              if ("string" == typeof altIndex) altIndexArr = altIndex.split(",");
                              else
                                  for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx.toString());
                              if (void 0 !== maskset.excludes[pos]) {
                                  for (var altIndexArrClone = altIndexArr.slice(), i = 0, exl = maskset.excludes[pos].length; i < exl; i++) {
                                      var excludeSet = maskset.excludes[pos][i].toString().split(":");
                                      loopNdx.length == excludeSet[1] && altIndexArr.splice(altIndexArr.indexOf(excludeSet[0]), 1)
                                  }
                                  0 === altIndexArr.length && (delete maskset.excludes[pos], altIndexArr = altIndexArrClone)
                              }(!0 === opts.keepStatic || isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic) && (altIndexArr = altIndexArr.slice(0, 1));
                              for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
                                  amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = "string" == typeof altIndex && resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice();
                                  var tokenMatch = alternateToken.matches[amndx];
                                  if (tokenMatch && handleMatch(tokenMatch, [amndx].concat(loopNdx), quantifierRecurse)) match = !0;
                                  else if (0 === ndx && (unMatchedAlternation = !0), tokenMatch && tokenMatch.matches && tokenMatch.matches.length > alternateToken.matches[0].matches.length) break;
                                  maltMatches = matches.slice(), testPos = currentPos, matches = [];
                                  for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                                      var altMatch = maltMatches[ndx1],
                                          dropMatch = !1;
                                      altMatch.match.jit = altMatch.match.jit || unMatchedAlternation, altMatch.alternation = altMatch.alternation || loopNdxCnt, setMergeLocators(altMatch);
                                      for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                                          var altMatch2 = malternateMatches[ndx2];
                                          if ("string" != typeof altIndex || void 0 !== altMatch.alternation && altIndexArr.includes(altMatch.locator[altMatch.alternation].toString())) {
                                              if (altMatch.match.nativeDef === altMatch2.match.nativeDef) {
                                                  dropMatch = !0, setMergeLocators(altMatch2, altMatch);
                                                  break
                                              }
                                              if (isSubsetOf(altMatch, altMatch2)) {
                                                  setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));
                                                  break
                                              }
                                              if (isSubsetOf(altMatch2, altMatch)) {
                                                  setMergeLocators(altMatch2, altMatch);
                                                  break
                                              }
                                              if (staticCanMatchDefinition(altMatch, altMatch2)) {
                                                  isSameLevel(altMatch, altMatch2) || void 0 !== el.inputmask.userOptions.keepStatic ? setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch)) : opts.keepStatic = !0;
                                                  break
                                              }
                                          }
                                      }
                                      dropMatch || malternateMatches.push(altMatch)
                                  }
                              }
                              matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = 0 < matches.length, match = 0 < malternateMatches.length, ndxInitializer = ndxInitializerClone.slice()
                          } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
                          if (match) return !0
                      } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[maskToken.matches.indexOf(match) - 1])
                          for (var qt = match, qndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {
                              var tokenGroup = maskToken.matches[maskToken.matches.indexOf(qt) - 1];
                              if (match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup), match) {
                                  if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx >= qt.quantifier.min, latestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit, latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {
                                      insertStop = !0, testPos = pos;
                                      break
                                  }
                                  return latestMatch.jit && (maskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch)), !0
                              }
                          } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse), match) return !0
                  } else testPos++
              }
              for (var tndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++)
                  if (!0 !== maskToken.matches[tndx].isQuantifier) {
                      var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
                      if (match && testPos === pos) return match;
                      if (pos < testPos) break
                  }
          }

          function mergeLocators(pos, tests) {
              var locator = [],
                  alternation;
              return Array.isArray(tests) || (tests = [tests]), 0 < tests.length && (void 0 === tests[0].alternation || !0 === opts.keepStatic ? (locator = determineTestTemplate.call(inputmask, pos, tests.slice()).locator.slice(), 0 === locator.length && (locator = tests[0].locator.slice())) : tests.forEach(function(tst) {
                  "" !== tst.def && (0 === locator.length ? (alternation = tst.alternation, locator = tst.locator.slice()) : tst.locator[alternation] && -1 === locator[alternation].toString().indexOf(tst.locator[alternation]) && (locator[alternation] += "," + tst.locator[alternation]))
              })), locator
          }
          if (-1 < pos && (void 0 === inputmask.maxLength || pos < inputmask.maxLength)) {
              if (void 0 === ndxIntlzr) {
                  for (var previousPos = pos - 1, test; void 0 === (test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) && -1 < previousPos;) previousPos--;
                  void 0 !== test && -1 < previousPos && (ndxInitializer = mergeLocators(previousPos, test), cacheDependency = ndxInitializer.join(""), testPos = previousPos)
              }
              if (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) return maskset.tests[pos];
              for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
                  var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);
                  if (match && testPos === pos || pos < testPos) break
              }
          }
          return 0 !== matches.length && !insertStop || matches.push({
              match: {
                  fn: null,
                  static: !0,
                  optionality: !1,
                  casing: null,
                  def: "",
                  placeholder: ""
              },
              locator: [],
              mloc: {},
              cd: cacheDependency
          }), void 0 !== ndxIntlzr && maskset.tests[pos] ? $.extend(!0, [], matches) : (maskset.tests[pos] = $.extend(!0, [], matches), maskset.tests[pos])
      }
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.determineTestTemplate = determineTestTemplate, exports.getDecisionTaker = getDecisionTaker, exports.getMaskTemplate = getMaskTemplate, exports.getPlaceholder = getPlaceholder, exports.getTest = getTest, exports.getTests = getTests, exports.getTestTemplate = getTestTemplate
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.alternate = alternate, exports.checkAlternationMatch = checkAlternationMatch, exports.isComplete = isComplete, exports.isValid = isValid, exports.refreshFromBuffer = refreshFromBuffer, exports.revalidateMask = revalidateMask, exports.handleRemove = handleRemove;
      var _validationTests = __webpack_require__(3),
          _keycode = _interopRequireDefault(__webpack_require__(0)),
          _positioning = __webpack_require__(2),
          _eventhandlers = __webpack_require__(6);

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }

      function alternate(maskPos, c, strict, fromIsValid, rAltPos, selection) {
          var inputmask = this,
              $ = this.dependencyLib,
              opts = this.opts,
              maskset = this.maskset,
              validPsClone = $.extend(!0, {}, maskset.validPositions),
              tstClone = $.extend(!0, {}, maskset.tests),
              lastAlt, alternation, isValidRslt = !1,
              returnRslt = !1,
              altPos, prevAltPos, i, validPos, decisionPos, lAltPos = void 0 !== rAltPos ? rAltPos : _positioning.getLastValidPosition.call(this),
              nextPos, input, begin, end;
          if (selection && (begin = selection.begin, end = selection.end, selection.begin > selection.end && (begin = selection.end, end = selection.begin)), -1 === lAltPos && void 0 === rAltPos) lastAlt = 0, prevAltPos = _validationTests.getTest.call(this, lastAlt), alternation = prevAltPos.alternation;
          else
              for (; 0 <= lAltPos; lAltPos--)
                  if (altPos = maskset.validPositions[lAltPos], altPos && void 0 !== altPos.alternation) {
                      if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;
                      lastAlt = lAltPos, alternation = maskset.validPositions[lastAlt].alternation, prevAltPos = altPos
                  } if (void 0 !== alternation) {
              decisionPos = parseInt(lastAlt), maskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [], !0 !== maskPos && maskset.excludes[decisionPos].push((0, _validationTests.getDecisionTaker)(prevAltPos) + ":" + prevAltPos.alternation);
              var validInputs = [],
                  resultPos = -1;
              for (i = decisionPos; i < _positioning.getLastValidPosition.call(this, void 0, !0) + 1; i++) - 1 === resultPos && maskPos <= i && void 0 !== c && (validInputs.push(c), resultPos = validInputs.length - 1), validPos = maskset.validPositions[i], validPos && !0 !== validPos.generatedInput && (void 0 === selection || i < begin || end <= i) && validInputs.push(validPos.input), delete maskset.validPositions[i];
              for (-1 === resultPos && void 0 !== c && (validInputs.push(c), resultPos = validInputs.length - 1); void 0 !== maskset.excludes[decisionPos] && maskset.excludes[decisionPos].length < 10;) {
                  for (maskset.tests = {}, _positioning.resetMaskSet.call(this, !0), isValidRslt = !0, i = 0; i < validInputs.length && (nextPos = isValidRslt.caret || _positioning.getLastValidPosition.call(this, void 0, !0) + 1, input = validInputs[i], isValidRslt = isValid.call(this, nextPos, input, !1, fromIsValid, !0)); i++) i === resultPos && (returnRslt = isValidRslt), 1 == maskPos && isValidRslt && (returnRslt = {
                      caretPos: i
                  });
                  if (isValidRslt) break;
                  if (_positioning.resetMaskSet.call(this), prevAltPos = _validationTests.getTest.call(this, decisionPos), maskset.validPositions = $.extend(!0, {}, validPsClone), maskset.tests = $.extend(!0, {}, tstClone), !maskset.excludes[decisionPos]) {
                      returnRslt = alternate.call(this, maskPos, c, strict, fromIsValid, decisionPos - 1, selection);
                      break
                  }
                  var decisionTaker = (0, _validationTests.getDecisionTaker)(prevAltPos);
                  if (-1 !== maskset.excludes[decisionPos].indexOf(decisionTaker + ":" + prevAltPos.alternation)) {
                      returnRslt = alternate.call(this, maskPos, c, strict, fromIsValid, decisionPos - 1, selection);
                      break
                  }
                  for (maskset.excludes[decisionPos].push(decisionTaker + ":" + prevAltPos.alternation), i = decisionPos; i < _positioning.getLastValidPosition.call(this, void 0, !0) + 1; i++) delete maskset.validPositions[i]
              }
          }
          return returnRslt && !1 === opts.keepStatic || delete maskset.excludes[decisionPos], returnRslt
      }

      function casing(elem, test, pos) {
          var opts = this.opts,
              maskset = this.maskset;
          switch (opts.casing || test.casing) {
              case "upper":
                  elem = elem.toUpperCase();
                  break;
              case "lower":
                  elem = elem.toLowerCase();
                  break;
              case "title":
                  var posBefore = maskset.validPositions[pos - 1];
                  elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(_keycode.default.SPACE) ? elem.toUpperCase() : elem.toLowerCase();
                  break;
              default:
                  if ("function" == typeof opts.casing) {
                      var args = Array.prototype.slice.call(arguments);
                      args.push(maskset.validPositions), elem = opts.casing.apply(this, args)
                  }
          }
          return elem
      }

      function checkAlternationMatch(altArr1, altArr2, na) {
          for (var opts = this.opts, altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = void 0 !== na ? na.split(",") : [], naNdx, i = 0; i < naArr.length; i++) - 1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);
          for (var alndx = 0; alndx < altArr1.length; alndx++)
              if (altArrC.includes(altArr1[alndx])) {
                  isMatch = !0;
                  break
              } return isMatch
      }

      function handleRemove(input, k, pos, strict, fromIsValid) {
          var inputmask = this,
              maskset = this.maskset,
              opts = this.opts;
          if ((opts.numericInput || this.isRTL) && (k === _keycode.default.BACKSPACE ? k = _keycode.default.DELETE : k === _keycode.default.DELETE && (k = _keycode.default.BACKSPACE), this.isRTL)) {
              var pend = pos.end;
              pos.end = pos.begin, pos.begin = pend
          }
          var lvp = _positioning.getLastValidPosition.call(this, void 0, !0),
              offset;
          if (pos.end >= _positioning.getBuffer.call(this).length && lvp >= pos.end && (pos.end = lvp + 1), k === _keycode.default.BACKSPACE ? pos.end - pos.begin < 1 && (pos.begin = _positioning.seekPrevious.call(this, pos.begin)) : k === _keycode.default.DELETE && pos.begin === pos.end && (pos.end = _positioning.isMask.call(this, pos.end, !0, !0) ? pos.end + 1 : _positioning.seekNext.call(this, pos.end) + 1), !1 !== (offset = revalidateMask.call(this, pos))) {
              if (!0 !== strict && !1 !== opts.keepStatic || null !== opts.regex && -1 !== _validationTests.getTest.call(this, pos.begin).match.def.indexOf("|")) {
                  var result = alternate.call(this, !0);
                  if (result) {
                      var newPos = void 0 !== result.caret ? result.caret : result.pos ? _positioning.seekNext.call(this, result.pos.begin ? result.pos.begin : result.pos) : _positioning.getLastValidPosition.call(this, -1, !0);
                      (k !== _keycode.default.DELETE || pos.begin > newPos) && pos.begin
                  }
              }!0 !== strict && (maskset.p = k === _keycode.default.DELETE ? pos.begin + offset : pos.begin)
          }
      }

      function isComplete(buffer) {
          var inputmask = this,
              opts = this.opts,
              maskset = this.maskset;
          if ("function" == typeof opts.isComplete) return opts.isComplete(buffer, opts);
          if ("*" !== opts.repeat) {
              var complete = !1,
                  lrp = _positioning.determineLastRequiredPosition.call(this, !0),
                  aml = _positioning.seekPrevious.call(this, lrp.l);
              if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
                  complete = !0;
                  for (var i = 0; i <= aml; i++) {
                      var test = _validationTests.getTestTemplate.call(this, i).match;
                      if (!0 !== test.static && void 0 === maskset.validPositions[i] && !0 !== test.optionality && !0 !== test.optionalQuantifier || !0 === test.static && buffer[i] !== _validationTests.getPlaceholder.call(this, i, test)) {
                          complete = !1;
                          break
                      }
                  }
              }
              return complete
          }
      }

      function isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly, fromCheckval) {
          var inputmask = this,
              $ = this.dependencyLib,
              opts = this.opts,
              el = inputmask.el,
              maskset = inputmask.maskset;

          function isSelection(posObj) {
              return inputmask.isRTL ? 1 < posObj.begin - posObj.end || posObj.begin - posObj.end == 1 : 1 < posObj.end - posObj.begin || posObj.end - posObj.begin == 1
          }
          strict = !0 === strict;
          var maskPos = pos;

          function processCommandObject(commandObj) {
              if (void 0 !== commandObj) {
                  if (void 0 !== commandObj.remove && (Array.isArray(commandObj.remove) || (commandObj.remove = [commandObj.remove]), commandObj.remove.sort(function(a, b) {
                          return b.pos - a.pos
                      }).forEach(function(lmnt) {
                          revalidateMask.call(inputmask, {
                              begin: lmnt,
                              end: lmnt + 1
                          })
                      }), commandObj.remove = void 0), void 0 !== commandObj.insert && (Array.isArray(commandObj.insert) || (commandObj.insert = [commandObj.insert]), commandObj.insert.sort(function(a, b) {
                          return a.pos - b.pos
                      }).forEach(function(lmnt) {
                          "" !== lmnt.c && isValid.call(inputmask, lmnt.pos, lmnt.c, void 0 === lmnt.strict || lmnt.strict, void 0 !== lmnt.fromIsValid ? lmnt.fromIsValid : fromIsValid)
                      }), commandObj.insert = void 0), commandObj.refreshFromBuffer && commandObj.buffer) {
                      var refresh = commandObj.refreshFromBuffer;
                      refreshFromBuffer.call(inputmask, !0 === refresh ? refresh : refresh.start, refresh.end, commandObj.buffer), commandObj.refreshFromBuffer = void 0
                  }
                  void 0 !== commandObj.rewritePosition && (maskPos = commandObj.rewritePosition, commandObj = !0)
              }
              return commandObj
          }

          function _isValid(position, c, strict) {
              var rslt = !1;
              return _validationTests.getTests.call(inputmask, position).every(function(tst, ndx) {
                  var test = tst.match;
                  if (_positioning.getBuffer.call(inputmask, !0), rslt = null != test.fn ? test.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && "" !== test.def && {
                          c: _validationTests.getPlaceholder.call(inputmask, position, test, !0) || test.def,
                          pos: position
                      }, !1 === rslt) return !0;
                  var elem = void 0 !== rslt.c ? rslt.c : c,
                      validatedPos = position;
                  return elem = elem === opts.skipOptionalPartCharacter && !0 === test.static ? _validationTests.getPlaceholder.call(inputmask, position, test, !0) || test.def : elem, rslt = processCommandObject(rslt), !0 !== rslt && void 0 !== rslt.pos && rslt.pos !== position && (validatedPos = rslt.pos), !0 !== rslt && void 0 === rslt.pos && void 0 === rslt.c || !1 === revalidateMask.call(inputmask, pos, $.extend({}, tst, {
                      input: casing.call(inputmask, elem, test, validatedPos)
                  }), fromIsValid, validatedPos) && (rslt = !1), !1
              }), rslt
          }
          void 0 !== pos.begin && (maskPos = inputmask.isRTL ? pos.end : pos.begin);
          var result = !0,
              positionsClone = $.extend(!0, {}, maskset.validPositions);
          if (!1 === opts.keepStatic && void 0 !== maskset.excludes[maskPos] && !0 !== fromAlternate && !0 !== fromIsValid)
              for (var i = maskPos; i < (inputmask.isRTL ? pos.begin : pos.end); i++) void 0 !== maskset.excludes[i] && (maskset.excludes[i] = void 0, delete maskset.tests[i]);
          if ("function" == typeof opts.preValidation && !0 !== fromIsValid && !0 !== validateOnly && (result = opts.preValidation.call(inputmask, _positioning.getBuffer.call(inputmask), maskPos, c, isSelection(pos), opts, maskset, pos, strict || fromAlternate), result = processCommandObject(result)), !0 === result) {
              if (void 0 === inputmask.maxLength || maskPos < _positioning.translatePosition.call(inputmask, inputmask.maxLength)) {
                  if (result = _isValid(maskPos, c, strict), (!strict || !0 === fromIsValid) && !1 === result && !0 !== validateOnly) {
                      var currentPosValid = maskset.validPositions[maskPos];
                      if (!currentPosValid || !0 !== currentPosValid.match.static || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {
                          if (opts.insertMode || void 0 === maskset.validPositions[_positioning.seekNext.call(inputmask, maskPos)] || pos.end > maskPos) {
                              var skip = !1;
                              if (maskset.jitOffset[maskPos] && void 0 === maskset.validPositions[_positioning.seekNext.call(inputmask, maskPos)] && (result = isValid.call(inputmask, maskPos + maskset.jitOffset[maskPos], c, !0), !1 !== result && (!0 !== fromAlternate && (result.caret = maskPos), skip = !0)), pos.end > maskPos && (maskset.validPositions[maskPos] = void 0), !skip && !_positioning.isMask.call(inputmask, maskPos, opts.keepStatic && 0 === maskPos))
                                  for (var nPos = maskPos + 1, snPos = _positioning.seekNext.call(inputmask, maskPos, !1, 0 !== maskPos); nPos <= snPos; nPos++)
                                      if (result = _isValid(nPos, c, strict), !1 !== result) {
                                          result = trackbackPositions.call(inputmask, maskPos, void 0 !== result.pos ? result.pos : nPos) || result, maskPos = nPos;
                                          break
                                      }
                          }
                      } else result = {
                          caret: _positioning.seekNext.call(inputmask, maskPos)
                      }
                  }
              } else result = !1;
              !1 !== result || !opts.keepStatic || !isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && 0 !== maskPos || strict || !0 === fromAlternate ? isSelection(pos) && maskset.tests[maskPos] && 1 < maskset.tests[maskPos].length && opts.keepStatic && !strict && !0 !== fromAlternate && (result = alternate.call(inputmask, !0)) : result = alternate.call(inputmask, maskPos, c, strict, fromIsValid, void 0, pos), !0 === result && (result = {
                  pos: maskPos
              })
          }
          if ("function" == typeof opts.postValidation && !0 !== fromIsValid && !0 !== validateOnly) {
              var postResult = opts.postValidation.call(inputmask, _positioning.getBuffer.call(inputmask, !0), void 0 !== pos.begin ? inputmask.isRTL ? pos.end : pos.begin : pos, c, result, opts, maskset, strict, fromCheckval);
              void 0 !== postResult && (result = !0 === postResult ? result : postResult)
          }
          result && void 0 === result.pos && (result.pos = maskPos), !1 === result || !0 === validateOnly ? (_positioning.resetMaskSet.call(inputmask, !0), maskset.validPositions = $.extend(!0, {}, positionsClone)) : trackbackPositions.call(inputmask, void 0, maskPos, !0);
          var endResult = processCommandObject(result);
          return endResult
      }

      function positionCanMatchDefinition(pos, testDefinition, opts) {
          for (var inputmask = this, maskset = this.maskset, valid = !1, tests = _validationTests.getTests.call(this, pos), tndx = 0; tndx < tests.length; tndx++) {
              if (tests[tndx].match && (!(tests[tndx].match.nativeDef !== testDefinition.match[opts.shiftPositions ? "def" : "nativeDef"] || opts.shiftPositions && testDefinition.match.static) || tests[tndx].match.nativeDef === testDefinition.match.nativeDef)) {
                  valid = !0;
                  break
              }
              if (tests[tndx].match && tests[tndx].match.def === testDefinition.match.nativeDef) {
                  valid = void 0;
                  break
              }
          }
          return !1 === valid && void 0 !== maskset.jitOffset[pos] && (valid = positionCanMatchDefinition.call(this, pos + maskset.jitOffset[pos], testDefinition, opts)), valid
      }

      function refreshFromBuffer(start, end, buffer) {
          var inputmask = this,
              maskset = this.maskset,
              opts = this.opts,
              $ = this.dependencyLib,
              el = this.el,
              i, p, skipOptionalPartCharacter = opts.skipOptionalPartCharacter,
              bffr = this.isRTL ? buffer.slice().reverse() : buffer;
          if (opts.skipOptionalPartCharacter = "", !0 === start) _positioning.resetMaskSet.call(this), maskset.tests = {}, start = 0, end = buffer.length, p = _positioning.determineNewCaretPosition.call(this, {
              begin: 0,
              end: 0
          }, !1).begin;
          else {
              for (i = start; i < end; i++) delete maskset.validPositions[i];
              p = start
          }
          var keypress = new $.Event("keypress");
          for (i = start; i < end; i++) {
              keypress.which = bffr[i].toString().charCodeAt(0), this.ignorable = !1;
              var valResult = _eventhandlers.EventHandlers.keypressEvent.call(el, keypress, !0, !1, !1, p);
              !1 !== valResult && (p = valResult.forwardPosition)
          }
          opts.skipOptionalPartCharacter = skipOptionalPartCharacter
      }

      function trackbackPositions(originalPos, newPos, fillOnly) {
          var inputmask = this,
              maskset = this.maskset,
              $ = this.dependencyLib;
          if (void 0 === originalPos)
              for (originalPos = newPos - 1; 0 < originalPos && !maskset.validPositions[originalPos]; originalPos--);
          for (var ps = originalPos; ps < newPos; ps++)
              if (void 0 === maskset.validPositions[ps] && !_positioning.isMask.call(this, ps, !0)) {
                  var vp = 0 == ps ? _validationTests.getTest.call(this, ps) : maskset.validPositions[ps - 1];
                  if (vp) {
                      var tests = _validationTests.getTests.call(this, ps).slice();
                      "" === tests[tests.length - 1].match.def && tests.pop();
                      var bestMatch = _validationTests.determineTestTemplate.call(this, ps, tests),
                          np;
                      if (bestMatch && (!0 !== bestMatch.match.jit || "master" === bestMatch.match.newBlockMarker && (np = maskset.validPositions[ps + 1]) && !0 === np.match.optionalQuantifier) && (bestMatch = $.extend({}, bestMatch, {
                              input: _validationTests.getPlaceholder.call(this, ps, bestMatch.match, !0) || bestMatch.match.def
                          }), bestMatch.generatedInput = !0, revalidateMask.call(this, ps, bestMatch, !0), !0 !== fillOnly)) {
                          var cvpInput = maskset.validPositions[newPos].input;
                          return maskset.validPositions[newPos] = void 0, isValid.call(this, newPos, cvpInput, !0, !0)
                      }
                  }
              }
      }

      function revalidateMask(pos, validTest, fromIsValid, validatedPos) {
          var inputmask = this,
              maskset = this.maskset,
              opts = this.opts,
              $ = this.dependencyLib;

          function IsEnclosedStatic(pos, valids, selection) {
              var posMatch = valids[pos];
              if (void 0 === posMatch || !0 !== posMatch.match.static || !0 === posMatch.match.optionality || void 0 !== valids[0] && void 0 !== valids[0].alternation) return !1;
              var prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && !0 === valids[pos - 1].match.static && valids[pos - 1] : valids[pos - 1],
                  nextMatch = selection.end > pos + 1 ? valids[pos + 1] && !0 === valids[pos + 1].match.static && valids[pos + 1] : valids[pos + 1];
              return prevMatch && nextMatch
          }
          var offset = 0,
              begin = void 0 !== pos.begin ? pos.begin : pos,
              end = void 0 !== pos.end ? pos.end : pos;
          if (pos.begin > pos.end && (begin = pos.end, end = pos.begin), validatedPos = void 0 !== validatedPos ? validatedPos : begin, begin !== end || opts.insertMode && void 0 !== maskset.validPositions[validatedPos] && void 0 === fromIsValid || void 0 === validTest) {
              var positionsClone = $.extend(!0, {}, maskset.validPositions),
                  lvp = _positioning.getLastValidPosition.call(this, void 0, !0),
                  i;
              for (maskset.p = begin, i = lvp; begin <= i; i--) delete maskset.validPositions[i], void 0 === validTest && delete maskset.tests[i + 1];
              var valid = !0,
                  j = validatedPos,
                  posMatch = j,
                  t, canMatch;
              for (validTest && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest), posMatch++, j++), i = validTest ? end : end - 1; i <= lvp; i++) {
                  if (void 0 !== (t = positionsClone[i]) && !0 !== t.generatedInput && (end <= i || begin <= i && IsEnclosedStatic(i, positionsClone, {
                          begin: begin,
                          end: end
                      }))) {
                      for (;
                          "" !== _validationTests.getTest.call(this, posMatch).match.def;) {
                          if (!1 !== (canMatch = positionCanMatchDefinition.call(this, posMatch, t, opts)) || "+" === t.match.def) {
                              "+" === t.match.def && _positioning.getBuffer.call(this, !0);
                              var result = isValid.call(this, posMatch, t.input, "+" !== t.match.def, "+" !== t.match.def);
                              if (valid = !1 !== result, j = (result.pos || posMatch) + 1, !valid && canMatch) break
                          } else valid = !1;
                          if (valid) {
                              void 0 === validTest && t.match.static && i === pos.begin && offset++;
                              break
                          }
                          if (!valid && posMatch > maskset.maskLength) break;
                          posMatch++
                      }
                      "" == _validationTests.getTest.call(this, posMatch).match.def && (valid = !1), posMatch = j
                  }
                  if (!valid) break
              }
              if (!valid) return maskset.validPositions = $.extend(!0, {}, positionsClone), _positioning.resetMaskSet.call(this, !0), !1
          } else validTest && _validationTests.getTest.call(this, validatedPos).match.cd === validTest.match.cd && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest));
          return _positioning.resetMaskSet.call(this, !0), offset
      }
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.applyInputValue = applyInputValue, exports.clearOptionalTail = clearOptionalTail, exports.checkVal = checkVal, exports.HandleNativePlaceholder = HandleNativePlaceholder, exports.unmaskedvalue = unmaskedvalue, exports.writeBuffer = writeBuffer;
      var _keycode = _interopRequireDefault(__webpack_require__(0)),
          _validationTests = __webpack_require__(3),
          _positioning = __webpack_require__(2),
          _validation = __webpack_require__(4),
          _environment = __webpack_require__(7),
          _eventhandlers = __webpack_require__(6);

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }

      function applyInputValue(input, value) {
          var inputmask = input ? input.inputmask : this,
              opts = inputmask.opts;
          input.inputmask.refreshValue = !1, "function" == typeof opts.onBeforeMask && (value = opts.onBeforeMask.call(inputmask, value, opts) || value), value = value.toString().split(""), checkVal(input, !0, !1, value), inputmask.undoValue = _positioning.getBuffer.call(inputmask).join(""), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === _positioning.getBufferTemplate.call(inputmask).join("") && -1 === _positioning.getLastValidPosition.call(inputmask) && input.inputmask._valueSet("")
      }

      function clearOptionalTail(buffer) {
          var inputmask = this;
          buffer.length = 0;
          for (var template = _validationTests.getMaskTemplate.call(this, !0, 0, !0, void 0, !0), lmnt; void 0 !== (lmnt = template.shift());) buffer.push(lmnt);
          return buffer
      }

      function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
          var inputmask = input ? input.inputmask : this,
              maskset = inputmask.maskset,
              opts = inputmask.opts,
              $ = inputmask.dependencyLib,
              inputValue = nptvl.slice(),
              charCodes = "",
              initialNdx = -1,
              result = void 0,
              skipOptionalPartCharacter = opts.skipOptionalPartCharacter;

          function isTemplateMatch(ndx, charCodes) {
              for (var targetTemplate = _validationTests.getMaskTemplate.call(inputmask, !0, 0).slice(ndx, _positioning.seekNext.call(inputmask, ndx, !1, !1)).join("").replace(/'/g, ""), charCodeNdx = targetTemplate.indexOf(charCodes); 0 < charCodeNdx && " " === targetTemplate[charCodeNdx - 1];) charCodeNdx--;
              var match = 0 === charCodeNdx && !_positioning.isMask.call(inputmask, ndx) && (_validationTests.getTest.call(inputmask, ndx).match.nativeDef === charCodes.charAt(0) || !0 === _validationTests.getTest.call(inputmask, ndx).match.static && _validationTests.getTest.call(inputmask, ndx).match.nativeDef === "'" + charCodes.charAt(0) || " " === _validationTests.getTest.call(inputmask, ndx).match.nativeDef && (_validationTests.getTest.call(inputmask, ndx + 1).match.nativeDef === charCodes.charAt(0) || !0 === _validationTests.getTest.call(inputmask, ndx + 1).match.static && _validationTests.getTest.call(inputmask, ndx + 1).match.nativeDef === "'" + charCodes.charAt(0)));
              if (!match && 0 < charCodeNdx && !_positioning.isMask.call(inputmask, ndx, !1, !0)) {
                  var nextPos = _positioning.seekNext.call(inputmask, ndx);
                  inputmask.caretPos.begin < nextPos && (inputmask.caretPos = {
                      begin: nextPos
                  })
              }
              return match
          }
          opts.skipOptionalPartCharacter = "", _positioning.resetMaskSet.call(inputmask), maskset.tests = {}, initialNdx = opts.radixPoint ? _positioning.determineNewCaretPosition.call(inputmask, {
              begin: 0,
              end: 0
          }).begin : 0, maskset.p = initialNdx, inputmask.caretPos = {
              begin: initialNdx
          };
          var staticMatches = [],
              prevCaretPos = inputmask.caretPos;
          if (inputValue.forEach(function(charCode, ndx) {
                  if (void 0 !== charCode)
                      if (void 0 === maskset.validPositions[ndx] && inputValue[ndx] === _validationTests.getPlaceholder.call(inputmask, ndx) && _positioning.isMask.call(inputmask, ndx, !0) && !1 === _validation.isValid.call(inputmask, ndx, inputValue[ndx], !0, void 0, void 0, !0)) maskset.p++;
                      else {
                          var keypress = new $.Event("_checkval");
                          keypress.which = charCode.toString().charCodeAt(0), charCodes += charCode;
                          var lvp = _positioning.getLastValidPosition.call(inputmask, void 0, !0);
                          isTemplateMatch(initialNdx, charCodes) ? result = _eventhandlers.EventHandlers.keypressEvent.call(inputmask, keypress, !0, !1, strict, lvp + 1) : (result = _eventhandlers.EventHandlers.keypressEvent.call(inputmask, keypress, !0, !1, strict, inputmask.caretPos.begin), result && (initialNdx = inputmask.caretPos.begin + 1, charCodes = "")), result ? (void 0 !== result.pos && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match.static && void 0 === maskset.validPositions[result.pos].alternation && (staticMatches.push(result.pos), inputmask.isRTL || (result.forwardPosition = result.pos + 1)), writeBuffer.call(inputmask, void 0, _positioning.getBuffer.call(inputmask), result.forwardPosition, keypress, !1), inputmask.caretPos = {
                              begin: result.forwardPosition,
                              end: result.forwardPosition
                          }, prevCaretPos = inputmask.caretPos) : inputmask.caretPos = prevCaretPos
                      }
              }), 0 < staticMatches.length) {
              var sndx, validPos, nextValid = _positioning.seekNext.call(inputmask, -1, void 0, !1);
              if (!_validation.isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && staticMatches.length <= nextValid || _validation.isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && 0 < staticMatches.length && staticMatches.length !== nextValid && 0 === staticMatches[0])
                  for (var nextSndx = nextValid; void 0 !== (sndx = staticMatches.shift());) {
                      var keypress = new $.Event("_checkval");
                      if (validPos = maskset.validPositions[sndx], validPos.generatedInput = !0, keypress.which = validPos.input.charCodeAt(0), result = _eventhandlers.EventHandlers.keypressEvent.call(inputmask, keypress, !0, !1, strict, nextSndx), result && void 0 !== result.pos && result.pos !== sndx && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match.static) staticMatches.push(result.pos);
                      else if (!result) break;
                      nextSndx++
                  }
          }
          writeOut && writeBuffer.call(inputmask, input, _positioning.getBuffer.call(inputmask), result ? result.forwardPosition : inputmask.caretPos.begin, initiatingEvent || new $.Event("checkval"), initiatingEvent && "input" === initiatingEvent.type && inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join("")), opts.skipOptionalPartCharacter = skipOptionalPartCharacter
      }

      function HandleNativePlaceholder(npt, value) {
          var inputmask = npt ? npt.inputmask : this;
          if (_environment.ie) {
              if (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || "" === npt.placeholder)) {
                  var buffer = _positioning.getBuffer.call(inputmask).slice(),
                      nptValue = npt.inputmask._valueGet();
                  if (nptValue !== value) {
                      var lvp = _positioning.getLastValidPosition.call(inputmask); - 1 === lvp && nptValue === _positioning.getBufferTemplate.call(inputmask).join("") ? buffer = [] : -1 !== lvp && clearOptionalTail.call(inputmask, buffer), writeBuffer(npt, buffer)
                  }
              }
          } else npt.placeholder !== value && (npt.placeholder = value, "" === npt.placeholder && npt.removeAttribute("placeholder"))
      }

      function unmaskedvalue(input) {
          var inputmask = input ? input.inputmask : this,
              opts = inputmask.opts,
              maskset = inputmask.maskset;
          if (input) {
              if (void 0 === input.inputmask) return input.value;
              input.inputmask && input.inputmask.refreshValue && applyInputValue(input, input.inputmask._valueGet(!0))
          }
          var umValue = [],
              vps = maskset.validPositions;
          for (var pndx in vps) vps[pndx] && vps[pndx].match && (1 != vps[pndx].match.static || Array.isArray(maskset.metadata) && !0 !== vps[pndx].generatedInput) && umValue.push(vps[pndx].input);
          var unmaskedValue = 0 === umValue.length ? "" : (inputmask.isRTL ? umValue.reverse() : umValue).join("");
          if ("function" == typeof opts.onUnMask) {
              var bufferValue = (inputmask.isRTL ? _positioning.getBuffer.call(inputmask).slice().reverse() : _positioning.getBuffer.call(inputmask)).join("");
              unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts)
          }
          return unmaskedValue
      }

      function writeBuffer(input, buffer, caretPos, event, triggerEvents) {
          var inputmask = input ? input.inputmask : this,
              opts = inputmask.opts,
              $ = inputmask.dependencyLib;
          if (event && "function" == typeof opts.onBeforeWrite) {
              var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);
              if (result) {
                  if (result.refreshFromBuffer) {
                      var refresh = result.refreshFromBuffer;
                      _validation.refreshFromBuffer.call(inputmask, !0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer), buffer = _positioning.getBuffer.call(inputmask, !0)
                  }
                  void 0 !== caretPos && (caretPos = void 0 !== result.caret ? result.caret : caretPos)
              }
          }
          if (void 0 !== input && (input.inputmask._valueSet(buffer.join("")), void 0 === caretPos || void 0 !== event && "blur" === event.type || _positioning.caret.call(inputmask, input, caretPos, void 0, void 0, void 0 !== event && "keydown" === event.type && (event.keyCode === _keycode.default.DELETE || event.keyCode === _keycode.default.BACKSPACE)), !0 === triggerEvents)) {
              var $input = $(input),
                  nptVal = input.inputmask._valueGet();
              input.inputmask.skipInputEvent = !0, $input.trigger("input"), setTimeout(function() {
                  nptVal === _positioning.getBufferTemplate.call(inputmask).join("") ? $input.trigger("cleared") : !0 === _validation.isComplete.call(inputmask, buffer) && $input.trigger("complete")
              }, 0)
          }
      }
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.EventHandlers = void 0;
      var _positioning = __webpack_require__(2),
          _keycode = _interopRequireDefault(__webpack_require__(0)),
          _environment = __webpack_require__(7),
          _validation = __webpack_require__(4),
          _inputHandling = __webpack_require__(5),
          _validationTests = __webpack_require__(3);

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var EventHandlers = {
          keydownEvent: function keydownEvent(e) {
              var inputmask = this.inputmask,
                  opts = inputmask.opts,
                  $ = inputmask.dependencyLib,
                  maskset = inputmask.maskset,
                  input = this,
                  $input = $(input),
                  k = e.keyCode,
                  pos = _positioning.caret.call(inputmask, input),
                  kdResult = opts.onKeyDown.call(this, e, _positioning.getBuffer.call(inputmask), pos, opts);
              if (void 0 !== kdResult) return kdResult;
              if (k === _keycode.default.BACKSPACE || k === _keycode.default.DELETE || _environment.iphone && k === _keycode.default.BACKSPACE_SAFARI || e.ctrlKey && k === _keycode.default.X && !("oncut" in input)) e.preventDefault(), _validation.handleRemove.call(inputmask, input, k, pos), (0, _inputHandling.writeBuffer)(input, _positioning.getBuffer.call(inputmask, !0), maskset.p, e, input.inputmask._valueGet() !== _positioning.getBuffer.call(inputmask).join(""));
              else if (k === _keycode.default.END || k === _keycode.default.PAGE_DOWN) {
                  e.preventDefault();
                  var caretPos = _positioning.seekNext.call(inputmask, _positioning.getLastValidPosition.call(inputmask));
                  _positioning.caret.call(inputmask, input, e.shiftKey ? pos.begin : caretPos, caretPos, !0)
              } else k === _keycode.default.HOME && !e.shiftKey || k === _keycode.default.PAGE_UP ? (e.preventDefault(), _positioning.caret.call(inputmask, input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === _keycode.default.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? ((0, _inputHandling.checkVal)(input, !0, !1, inputmask.undoValue.split("")), $input.trigger("click")) : !0 === opts.tabThrough && k === _keycode.default.TAB ? !0 === e.shiftKey ? (pos.end = _positioning.seekPrevious.call(inputmask, pos.end, !0), !0 === _validationTests.getTest.call(inputmask, pos.end - 1).match.static && pos.end--, pos.begin = _positioning.seekPrevious.call(inputmask, pos.end, !0), 0 <= pos.begin && 0 < pos.end && (e.preventDefault(), _positioning.caret.call(inputmask, input, pos.begin, pos.end))) : (pos.begin = _positioning.seekNext.call(inputmask, pos.begin, !0), pos.end = _positioning.seekNext.call(inputmask, pos.begin, !0), pos.end < maskset.maskLength && pos.end--, pos.begin <= maskset.maskLength && (e.preventDefault(), _positioning.caret.call(inputmask, input, pos.begin, pos.end))) : e.shiftKey || opts.insertModeVisual && !1 === opts.insertMode && (k === _keycode.default.RIGHT ? setTimeout(function() {
                  var caretPos = _positioning.caret.call(inputmask, input);
                  _positioning.caret.call(inputmask, input, caretPos.begin)
              }, 0) : k === _keycode.default.LEFT && setTimeout(function() {
                  var caretPos_begin = _positioning.translatePosition.call(inputmask, input.inputmask.caretPos.begin),
                      caretPos_end = _positioning.translatePosition.call(inputmask, input.inputmask.caretPos.end);
                  inputmask.isRTL ? _positioning.caret.call(inputmask, input, caretPos_begin + (caretPos_begin === maskset.maskLength ? 0 : 1)) : _positioning.caret.call(inputmask, input, caretPos_begin - (0 === caretPos_begin ? 0 : 1))
              }, 0));
              inputmask.ignorable = opts.ignorables.includes(k)
          },
          keypressEvent: function keypressEvent(e, checkval, writeOut, strict, ndx) {
              var inputmask = this.inputmask || this,
                  opts = inputmask.opts,
                  $ = inputmask.dependencyLib,
                  maskset = inputmask.maskset,
                  input = inputmask.el,
                  $input = $(input),
                  k = e.which || e.charCode || e.keyCode;
              if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || inputmask.ignorable)) return k === _keycode.default.ENTER && inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join("") && (inputmask.undoValue = _positioning.getBuffer.call(inputmask).join(""), setTimeout(function() {
                  $input.trigger("change")
              }, 0)), inputmask.skipInputEvent = !0, !0;
              if (k) {
                  44 !== k && 46 !== k || 3 !== e.location || "" === opts.radixPoint || (k = opts.radixPoint.charCodeAt(0));
                  var pos = checkval ? {
                          begin: ndx,
                          end: ndx
                      } : _positioning.caret.call(inputmask, input),
                      forwardPosition, c = String.fromCharCode(k);
                  maskset.writeOutBuffer = !0;
                  var valResult = _validation.isValid.call(inputmask, pos, c, strict, void 0, void 0, void 0, checkval);
                  if (!1 !== valResult && (_positioning.resetMaskSet.call(inputmask, !0), forwardPosition = void 0 !== valResult.caret ? valResult.caret : _positioning.seekNext.call(inputmask, valResult.pos.begin ? valResult.pos.begin : valResult.pos), maskset.p = forwardPosition), forwardPosition = opts.numericInput && void 0 === valResult.caret ? _positioning.seekPrevious.call(inputmask, forwardPosition) : forwardPosition, !1 !== writeOut && (setTimeout(function() {
                          opts.onKeyValidation.call(input, k, valResult)
                      }, 0), maskset.writeOutBuffer && !1 !== valResult)) {
                      var buffer = _positioning.getBuffer.call(inputmask);
                      (0, _inputHandling.writeBuffer)(input, buffer, forwardPosition, e, !0 !== checkval)
                  }
                  if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition), valResult
              }
          },
          keyupEvent: function keyupEvent(e) {
              var inputmask = this.inputmask;
              !inputmask.isComposing || e.keyCode !== _keycode.default.KEY_229 && e.keyCode !== _keycode.default.ENTER || inputmask.$el.trigger("input")
          },
          pasteEvent: function pasteEvent(e) {
              var inputmask = this.inputmask,
                  opts = inputmask.opts,
                  input = this,
                  inputValue = inputmask._valueGet(!0),
                  caretPos = _positioning.caret.call(inputmask, this),
                  tempValue;
              inputmask.isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);
              var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
                  valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
              if (valueBeforeCaret == (inputmask.isRTL ? _positioning.getBufferTemplate.call(inputmask).slice().reverse() : _positioning.getBufferTemplate.call(inputmask)).slice(0, caretPos.begin).join("") && (valueBeforeCaret = ""), valueAfterCaret == (inputmask.isRTL ? _positioning.getBufferTemplate.call(inputmask).slice().reverse() : _positioning.getBufferTemplate.call(inputmask)).slice(caretPos.end).join("") && (valueAfterCaret = ""), window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret;
              else {
                  if (!e.clipboardData || !e.clipboardData.getData) return !0;
                  inputValue = valueBeforeCaret + e.clipboardData.getData("text/plain") + valueAfterCaret
              }
              var pasteValue = inputValue;
              if ("function" == typeof opts.onBeforePaste) {
                  if (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts), !1 === pasteValue) return e.preventDefault();
                  pasteValue = pasteValue || inputValue
              }
              return (0, _inputHandling.checkVal)(this, !0, !1, pasteValue.toString().split(""), e), e.preventDefault()
          },
          inputFallBackEvent: function inputFallBackEvent(e) {
              var inputmask = this.inputmask,
                  opts = inputmask.opts,
                  $ = inputmask.dependencyLib;

              function ieMobileHandler(input, inputValue, caretPos) {
                  if (_environment.iemobile) {
                      var inputChar = inputValue.replace(_positioning.getBuffer.call(inputmask).join(""), "");
                      if (1 === inputChar.length) {
                          var iv = inputValue.split("");
                          iv.splice(caretPos.begin, 0, inputChar), inputValue = iv.join("")
                      }
                  }
                  return inputValue
              }

              function analyseChanges(inputValue, buffer, caretPos) {
                  for (var frontPart = inputValue.substr(0, caretPos.begin).split(""), backPart = inputValue.substr(caretPos.begin).split(""), frontBufferPart = buffer.substr(0, caretPos.begin).split(""), backBufferPart = buffer.substr(caretPos.begin).split(""), fpl = frontPart.length >= frontBufferPart.length ? frontPart.length : frontBufferPart.length, bpl = backPart.length >= backBufferPart.length ? backPart.length : backBufferPart.length, bl, i, action = "", data = [], marker = "~", placeholder; frontPart.length < fpl;) frontPart.push("~");
                  for (; frontBufferPart.length < fpl;) frontBufferPart.push("~");
                  for (; backPart.length < bpl;) backPart.unshift("~");
                  for (; backBufferPart.length < bpl;) backBufferPart.unshift("~");
                  var newBuffer = frontPart.concat(backPart),
                      oldBuffer = frontBufferPart.concat(backBufferPart);
                  for (i = 0, bl = newBuffer.length; i < bl; i++) switch (placeholder = _validationTests.getPlaceholder.call(inputmask, _positioning.translatePosition.call(inputmask, i)), action) {
                      case "insertText":
                          oldBuffer[i - 1] === newBuffer[i] && caretPos.begin == newBuffer.length - 1 && data.push(newBuffer[i]), i = bl;
                          break;
                      case "insertReplacementText":
                          "~" === newBuffer[i] ? caretPos.end++ : i = bl;
                          break;
                      case "deleteContentBackward":
                          "~" === newBuffer[i] ? caretPos.end++ : i = bl;
                          break;
                      default:
                          newBuffer[i] !== oldBuffer[i] && ("~" !== newBuffer[i + 1] && newBuffer[i + 1] !== placeholder && void 0 !== newBuffer[i + 1] || (oldBuffer[i] !== placeholder || "~" !== oldBuffer[i + 1]) && "~" !== oldBuffer[i] ? "~" === oldBuffer[i + 1] && oldBuffer[i] === newBuffer[i + 1] ? (action = "insertText", data.push(newBuffer[i]), caretPos.begin--, caretPos.end--) : newBuffer[i] !== placeholder && "~" !== newBuffer[i] && ("~" === newBuffer[i + 1] || oldBuffer[i] !== newBuffer[i] && oldBuffer[i + 1] === newBuffer[i + 1]) ? (action = "insertReplacementText", data.push(newBuffer[i]), caretPos.begin--) : "~" === newBuffer[i] ? (action = "deleteContentBackward", !_positioning.isMask.call(inputmask, _positioning.translatePosition.call(inputmask, i), !0) && oldBuffer[i] !== opts.radixPoint || caretPos.end++) : i = bl : (action = "insertText", data.push(newBuffer[i]), caretPos.begin--, caretPos.end--));
                          break
                  }
                  return {
                      action: action,
                      data: data,
                      caret: caretPos
                  }
              }
              var input = this,
                  inputValue = input.inputmask._valueGet(!0),
                  buffer = (inputmask.isRTL ? _positioning.getBuffer.call(inputmask).slice().reverse() : _positioning.getBuffer.call(inputmask)).join(""),
                  caretPos = _positioning.caret.call(inputmask, input, void 0, void 0, !0);
              if (buffer !== inputValue) {
                  inputValue = ieMobileHandler(input, inputValue, caretPos);
                  var changes = analyseChanges(inputValue, buffer, caretPos);
                  switch ((input.inputmask.shadowRoot || document).activeElement !== input && input.focus(), (0, _inputHandling.writeBuffer)(input, _positioning.getBuffer.call(inputmask)), _positioning.caret.call(inputmask, input, caretPos.begin, caretPos.end, !0), changes.action) {
                      case "insertText":
                      case "insertReplacementText":
                          changes.data.forEach(function(entry, ndx) {
                              var keypress = new $.Event("keypress");
                              keypress.which = entry.charCodeAt(0), inputmask.ignorable = !1, EventHandlers.keypressEvent.call(input, keypress)
                          }), setTimeout(function() {
                              inputmask.$el.trigger("keyup")
                          }, 0);
                          break;
                      case "deleteContentBackward":
                          var keydown = new $.Event("keydown");
                          keydown.keyCode = _keycode.default.BACKSPACE, EventHandlers.keydownEvent.call(input, keydown);
                          break;
                      default:
                          (0, _inputHandling.applyInputValue)(input, inputValue);
                          break
                  }
                  e.preventDefault()
              }
          },
          compositionendEvent: function compositionendEvent(e) {
              var inputmask = this.inputmask;
              inputmask.isComposing = !1, inputmask.$el.trigger("input")
          },
          setValueEvent: function setValueEvent(e, argument_1, argument_2) {
              var inputmask = this.inputmask,
                  input = this,
                  value = e && e.detail ? e.detail[0] : argument_1;
              void 0 === value && (value = this.inputmask._valueGet(!0)), (0, _inputHandling.applyInputValue)(this, value), (e.detail && void 0 !== e.detail[1] || void 0 !== argument_2) && _positioning.caret.call(inputmask, this, e.detail ? e.detail[1] : argument_2)
          },
          focusEvent: function focusEvent(e) {
              var inputmask = this.inputmask,
                  opts = inputmask.opts,
                  input = this,
                  nptValue = this.inputmask._valueGet();
              opts.showMaskOnFocus && nptValue !== _positioning.getBuffer.call(inputmask).join("") && (0, _inputHandling.writeBuffer)(this, _positioning.getBuffer.call(inputmask), _positioning.seekNext.call(inputmask, _positioning.getLastValidPosition.call(inputmask))), !0 !== opts.positionCaretOnTab || !1 !== inputmask.mouseEnter || _validation.isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && -1 !== _positioning.getLastValidPosition.call(inputmask) || EventHandlers.clickEvent.apply(this, [e, !0]), inputmask.undoValue = _positioning.getBuffer.call(inputmask).join("")
          },
          invalidEvent: function invalidEvent(e) {
              this.inputmask.validationEvent = !0
          },
          mouseleaveEvent: function mouseleaveEvent() {
              var inputmask = this.inputmask,
                  opts = inputmask.opts,
                  input = this;
              inputmask.mouseEnter = !1, opts.clearMaskOnLostFocus && (this.inputmask.shadowRoot || document).activeElement !== this && (0, _inputHandling.HandleNativePlaceholder)(this, inputmask.originalPlaceholder)
          },
          clickEvent: function clickEvent(e, tabbed) {
              var inputmask = this.inputmask,
                  input = this;
              if ((this.inputmask.shadowRoot || document).activeElement === this) {
                  var newCaretPosition = _positioning.determineNewCaretPosition.call(inputmask, _positioning.caret.call(inputmask, this), tabbed);
                  void 0 !== newCaretPosition && _positioning.caret.call(inputmask, this, newCaretPosition)
              }
          },
          cutEvent: function cutEvent(e) {
              var inputmask = this.inputmask,
                  maskset = inputmask.maskset,
                  input = this,
                  pos = _positioning.caret.call(inputmask, this),
                  clipboardData = window.clipboardData || e.clipboardData,
                  clipData = inputmask.isRTL ? _positioning.getBuffer.call(inputmask).slice(pos.end, pos.begin) : _positioning.getBuffer.call(inputmask).slice(pos.begin, pos.end);
              clipboardData.setData("text", inputmask.isRTL ? clipData.reverse().join("") : clipData.join("")), document.execCommand && document.execCommand("copy"), _validation.handleRemove.call(inputmask, this, _keycode.default.DELETE, pos), (0, _inputHandling.writeBuffer)(this, _positioning.getBuffer.call(inputmask), maskset.p, e, inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join(""))
          },
          blurEvent: function blurEvent(e) {
              var inputmask = this.inputmask,
                  opts = inputmask.opts,
                  $ = inputmask.dependencyLib,
                  $input = $(this),
                  input = this;
              if (this.inputmask) {
                  (0, _inputHandling.HandleNativePlaceholder)(this, inputmask.originalPlaceholder);
                  var nptValue = this.inputmask._valueGet(),
                      buffer = _positioning.getBuffer.call(inputmask).slice();
                  "" !== nptValue && (opts.clearMaskOnLostFocus && (-1 === _positioning.getLastValidPosition.call(inputmask) && nptValue === _positioning.getBufferTemplate.call(inputmask).join("") ? buffer = [] : _inputHandling.clearOptionalTail.call(inputmask, buffer)), !1 === _validation.isComplete.call(inputmask, buffer) && (setTimeout(function() {
                      $input.trigger("incomplete")
                  }, 0), opts.clearIncomplete && (_positioning.resetMaskSet.call(inputmask), buffer = opts.clearMaskOnLostFocus ? [] : _positioning.getBufferTemplate.call(inputmask).slice())), (0, _inputHandling.writeBuffer)(this, buffer, void 0, e)), inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join("") && (inputmask.undoValue = _positioning.getBuffer.call(inputmask).join(""), $input.trigger("change"))
              }
          },
          mouseenterEvent: function mouseenterEvent() {
              var inputmask = this.inputmask,
                  opts = inputmask.opts,
                  input = this;
              inputmask.mouseEnter = !0, (this.inputmask.shadowRoot || document).activeElement !== this && (null == inputmask.originalPlaceholder && this.placeholder !== inputmask.originalPlaceholder && (inputmask.originalPlaceholder = this.placeholder), opts.showMaskOnHover && (0, _inputHandling.HandleNativePlaceholder)(this, (inputmask.isRTL ? _positioning.getBufferTemplate.call(inputmask).slice().reverse() : _positioning.getBufferTemplate.call(inputmask)).join("")))
          },
          submitEvent: function submitEvent() {
              var inputmask = this.inputmask,
                  opts = inputmask.opts;
              inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join("") && inputmask.$el.trigger("change"), opts.clearMaskOnLostFocus && -1 === _positioning.getLastValidPosition.call(inputmask) && inputmask._valueGet && inputmask._valueGet() === _positioning.getBufferTemplate.call(inputmask).join("") && inputmask._valueSet(""), opts.clearIncomplete && !1 === _validation.isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && inputmask._valueSet(""), opts.removeMaskOnSubmit && (inputmask._valueSet(inputmask.unmaskedvalue(), !0), setTimeout(function() {
                  (0, _inputHandling.writeBuffer)(inputmask.el, _positioning.getBuffer.call(inputmask))
              }, 0))
          },
          resetEvent: function resetEvent() {
              var inputmask = this.inputmask;
              inputmask.refreshValue = !0, setTimeout(function() {
                  (0, _inputHandling.applyInputValue)(inputmask.el, inputmask._valueGet(!0))
              }, 0)
          }
      };
      exports.EventHandlers = EventHandlers
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.iphone = exports.iemobile = exports.mobile = exports.ie = exports.ua = void 0;
      var _window = _interopRequireDefault(__webpack_require__(8));

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var ua = _window.default.navigator && _window.default.navigator.userAgent || "",
          ie = 0 < ua.indexOf("MSIE ") || 0 < ua.indexOf("Trident/"),
          mobile = "ontouchstart" in _window.default,
          iemobile = /iemobile/i.test(ua),
          iphone = /iphone/i.test(ua) && !iemobile;
      exports.iphone = iphone, exports.iemobile = iemobile, exports.mobile = mobile, exports.ie = ie, exports.ua = ua
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = void 0;
      var _canUseDOM = _interopRequireDefault(__webpack_require__(9));

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var _default = _canUseDOM.default ? window : {};
      exports.default = _default
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = void 0;
      var canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement),
          _default = canUseDOM;
      exports.default = _default
  }, function(module, exports) {
      module.exports = __WEBPACK_EXTERNAL_MODULE__10__
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.mask = mask;
      var _keycode = _interopRequireDefault(__webpack_require__(0)),
          _positioning = __webpack_require__(2),
          _inputHandling = __webpack_require__(5),
          _eventruler = __webpack_require__(12),
          _environment = __webpack_require__(7),
          _validation = __webpack_require__(4),
          _eventhandlers = __webpack_require__(6);

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }

      function mask() {
          var inputmask = this,
              opts = this.opts,
              el = this.el,
              $ = this.dependencyLib;

          function isElementTypeSupported(input, opts) {
              function patchValueProperty(npt) {
                  var valueGet, valueSet;

                  function patchValhook(type) {
                      if ($.valHooks && (void 0 === $.valHooks[type] || !0 !== $.valHooks[type].inputmaskpatch)) {
                          var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {
                                  return elem.value
                              },
                              valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {
                                  return elem.value = value, elem
                              };
                          $.valHooks[type] = {
                              get: function get(elem) {
                                  if (elem.inputmask) {
                                      if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();
                                      var result = valhookGet(elem);
                                      return -1 !== _positioning.getLastValidPosition.call(inputmask, void 0, void 0, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : ""
                                  }
                                  return valhookGet(elem)
                              },
                              set: function set(elem, value) {
                                  var result = valhookSet(elem, value);
                                  return elem.inputmask && (0, _inputHandling.applyInputValue)(elem, value), result
                              },
                              inputmaskpatch: !0
                          }
                      }
                  }

                  function getter() {
                      return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== _positioning.getLastValidPosition.call(inputmask) || !0 !== opts.nullable ? (this.inputmask.shadowRoot || document.activeElement) === this && opts.clearMaskOnLostFocus ? (inputmask.isRTL ? _inputHandling.clearOptionalTail.call(inputmask, _positioning.getBuffer.call(inputmask).slice()).reverse() : _inputHandling.clearOptionalTail.call(inputmask, _positioning.getBuffer.call(inputmask).slice())).join("") : valueGet.call(this) : "" : valueGet.call(this)
                  }

                  function setter(value) {
                      valueSet.call(this, value), this.inputmask && (0, _inputHandling.applyInputValue)(this, value)
                  }

                  function installNativeValueSetFallback(npt) {
                      _eventruler.EventRuler.on(npt, "mouseenter", function() {
                          var input = this,
                              value = this.inputmask._valueGet(!0);
                          value !== (inputmask.isRTL ? _positioning.getBuffer.call(inputmask).reverse() : _positioning.getBuffer.call(inputmask)).join("") && (0, _inputHandling.applyInputValue)(this, value)
                      })
                  }
                  if (!npt.inputmask.__valueGet) {
                      if (!0 !== opts.noValuePatching) {
                          if (Object.getOwnPropertyDescriptor) {
                              var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : void 0;
                              valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, valueSet = valueProperty.set, Object.defineProperty(npt, "value", {
                                  get: getter,
                                  set: setter,
                                  configurable: !0
                              })) : "input" !== npt.tagName.toLowerCase() && (valueGet = function valueGet() {
                                  return this.textContent
                              }, valueSet = function valueSet(value) {
                                  this.textContent = value
                              }, Object.defineProperty(npt, "value", {
                                  get: getter,
                                  set: setter,
                                  configurable: !0
                              }))
                          } else document.__lookupGetter__ && npt.__lookupGetter__("value") && (valueGet = npt.__lookupGetter__("value"), valueSet = npt.__lookupSetter__("value"), npt.__defineGetter__("value", getter), npt.__defineSetter__("value", setter));
                          npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet
                      }
                      npt.inputmask._valueGet = function(overruleRTL) {
                          return inputmask.isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el)
                      }, npt.inputmask._valueSet = function(value, overruleRTL) {
                          valueSet.call(this.el, null == value ? "" : !0 !== overruleRTL && inputmask.isRTL ? value.split("").reverse().join("") : value)
                      }, void 0 === valueGet && (valueGet = function valueGet() {
                          return this.value
                      }, valueSet = function valueSet(value) {
                          this.value = value
                      }, patchValhook(npt.type), installNativeValueSetFallback(npt))
                  }
              }
              "textarea" !== input.tagName.toLowerCase() && opts.ignorables.push(_keycode.default.ENTER);
              var elementType = input.getAttribute("type"),
                  isSupported = "input" === input.tagName.toLowerCase() && opts.supportsInputType.includes(elementType) || input.isContentEditable || "textarea" === input.tagName.toLowerCase();
              if (!isSupported)
                  if ("input" === input.tagName.toLowerCase()) {
                      var el = document.createElement("input");
                      el.setAttribute("type", elementType), isSupported = "text" === el.type, el = null
                  } else isSupported = "partial";
              return !1 !== isSupported ? patchValueProperty(input) : input.inputmask = void 0, isSupported
          }
          _eventruler.EventRuler.off(el);
          var isSupported = isElementTypeSupported(el, opts);
          if (!1 !== isSupported) {
              inputmask.originalPlaceholder = el.placeholder, inputmask.maxLength = void 0 !== el ? el.maxLength : void 0, -1 === inputmask.maxLength && (inputmask.maxLength = void 0), "inputMode" in el && null === el.getAttribute("inputmode") && (el.inputMode = opts.inputmode, el.setAttribute("inputmode", opts.inputmode)), !0 === isSupported && (opts.showMaskOnFocus = opts.showMaskOnFocus && -1 === ["cc-number", "cc-exp"].indexOf(el.autocomplete), _environment.iphone && (opts.insertModeVisual = !1), _eventruler.EventRuler.on(el, "submit", _eventhandlers.EventHandlers.submitEvent), _eventruler.EventRuler.on(el, "reset", _eventhandlers.EventHandlers.resetEvent), _eventruler.EventRuler.on(el, "blur", _eventhandlers.EventHandlers.blurEvent), _eventruler.EventRuler.on(el, "focus", _eventhandlers.EventHandlers.focusEvent), _eventruler.EventRuler.on(el, "invalid", _eventhandlers.EventHandlers.invalidEvent), _eventruler.EventRuler.on(el, "click", _eventhandlers.EventHandlers.clickEvent), _eventruler.EventRuler.on(el, "mouseleave", _eventhandlers.EventHandlers.mouseleaveEvent), _eventruler.EventRuler.on(el, "mouseenter", _eventhandlers.EventHandlers.mouseenterEvent), _eventruler.EventRuler.on(el, "paste", _eventhandlers.EventHandlers.pasteEvent), _eventruler.EventRuler.on(el, "cut", _eventhandlers.EventHandlers.cutEvent), _eventruler.EventRuler.on(el, "complete", opts.oncomplete), _eventruler.EventRuler.on(el, "incomplete", opts.onincomplete), _eventruler.EventRuler.on(el, "cleared", opts.oncleared), !0 !== opts.inputEventOnly && (_eventruler.EventRuler.on(el, "keydown", _eventhandlers.EventHandlers.keydownEvent), _eventruler.EventRuler.on(el, "keypress", _eventhandlers.EventHandlers.keypressEvent), _eventruler.EventRuler.on(el, "keyup", _eventhandlers.EventHandlers.keyupEvent)), (_environment.mobile || opts.inputEventOnly) && el.removeAttribute("maxLength"), _eventruler.EventRuler.on(el, "input", _eventhandlers.EventHandlers.inputFallBackEvent), _eventruler.EventRuler.on(el, "compositionend", _eventhandlers.EventHandlers.compositionendEvent)), _eventruler.EventRuler.on(el, "setvalue", _eventhandlers.EventHandlers.setValueEvent), inputmask.undoValue = _positioning.getBufferTemplate.call(inputmask).join("");
              var activeElement = (el.inputmask.shadowRoot || document).activeElement;
              if ("" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || activeElement === el) {
                  (0, _inputHandling.applyInputValue)(el, el.inputmask._valueGet(!0), opts);
                  var buffer = _positioning.getBuffer.call(inputmask).slice();
                  !1 === _validation.isComplete.call(inputmask, buffer) && opts.clearIncomplete && _positioning.resetMaskSet.call(inputmask), opts.clearMaskOnLostFocus && activeElement !== el && (-1 === _positioning.getLastValidPosition.call(inputmask) ? buffer = [] : _inputHandling.clearOptionalTail.call(inputmask, buffer)), (!1 === opts.clearMaskOnLostFocus || opts.showMaskOnFocus && activeElement === el || "" !== el.inputmask._valueGet(!0)) && (0, _inputHandling.writeBuffer)(el, buffer), activeElement === el && _positioning.caret.call(inputmask, el, _positioning.seekNext.call(inputmask, _positioning.getLastValidPosition.call(inputmask)))
              }
          }
      }
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.EventRuler = void 0;
      var _inputmask = _interopRequireDefault(__webpack_require__(1)),
          _keycode = _interopRequireDefault(__webpack_require__(0)),
          _positioning = __webpack_require__(2),
          _inputHandling = __webpack_require__(5);

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var EventRuler = {
          on: function on(input, eventName, eventHandler) {
              var $ = input.inputmask.dependencyLib,
                  ev = function ev(e) {
                      e.originalEvent && (e = e.originalEvent || e, arguments[0] = e);
                      var that = this,
                          args, inputmask = that.inputmask,
                          opts = inputmask ? inputmask.opts : void 0;
                      if (void 0 === inputmask && "FORM" !== this.nodeName) {
                          var imOpts = $.data(that, "_inputmask_opts");
                          $(that).off(), imOpts && new _inputmask.default(imOpts).mask(that)
                      } else {
                          if (["submit", "reset", "setvalue"].includes(e.type) || "FORM" === this.nodeName || !(that.disabled || that.readOnly && !("keydown" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === _keycode.default.TAB))) {
                              switch (e.type) {
                                  case "input":
                                      if (!0 === inputmask.skipInputEvent || e.inputType && "insertCompositionText" === e.inputType) return inputmask.skipInputEvent = !1, e.preventDefault();
                                      break;
                                  case "keydown":
                                      inputmask.skipKeyPressEvent = !1, inputmask.skipInputEvent = inputmask.isComposing = e.keyCode === _keycode.default.KEY_229;
                                      break;
                                  case "keyup":
                                  case "compositionend":
                                      inputmask.isComposing && (inputmask.skipInputEvent = !1);
                                      break;
                                  case "keypress":
                                      if (!0 === inputmask.skipKeyPressEvent) return e.preventDefault();
                                      inputmask.skipKeyPressEvent = !0;
                                      break;
                                  case "click":
                                  case "focus":
                                      return inputmask.validationEvent ? (inputmask.validationEvent = !1, input.blur(), (0, _inputHandling.HandleNativePlaceholder)(input, (inputmask.isRTL ? _positioning.getBufferTemplate.call(inputmask).slice().reverse() : _positioning.getBufferTemplate.call(inputmask)).join("")), setTimeout(function() {
                                          input.focus()
                                      }, 3e3)) : (args = arguments, setTimeout(function() {
                                          input.inputmask && eventHandler.apply(that, args)
                                      }, 0)), !1
                              }
                              var returnVal = eventHandler.apply(that, arguments);
                              return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal
                          }
                          e.preventDefault()
                      }
                  };
              ["submit", "reset"].includes(eventName) ? (ev = ev.bind(input), null !== input.form && $(input.form).on(eventName, ev)) : $(input).on(eventName, ev), input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev)
          },
          off: function off(input, event) {
              if (input.inputmask && input.inputmask.events) {
                  var $ = input.inputmask.dependencyLib,
                      events = input.inputmask.events;
                  for (var eventName in event && (events = [], events[event] = input.inputmask.events[event]), events) {
                      for (var evArr = events[eventName]; 0 < evArr.length;) {
                          var ev = evArr.pop();
                          ["submit", "reset"].includes(eventName) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev)
                      }
                      delete input.inputmask.events[eventName]
                  }
              }
          }
      };
      exports.EventRuler = EventRuler
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = void 0;
      var _jquery = _interopRequireDefault(__webpack_require__(10));

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      if (void 0 === _jquery.default) throw "jQuery not loaded!";
      var _default = _jquery.default;
      exports.default = _default
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = _default;
      var escapeRegexRegex = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim");

      function _default(str) {
          return str.replace(escapeRegexRegex, "\\$1")
      }
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = void 0, __webpack_require__(16), __webpack_require__(22), __webpack_require__(23), __webpack_require__(24);
      var _inputmask2 = _interopRequireDefault(__webpack_require__(1));

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var _default = _inputmask2.default;
      exports.default = _default
  }, function(module, exports, __webpack_require__) {
      "use strict";
      var _inputmask = _interopRequireDefault(__webpack_require__(1));

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      _inputmask.default.extendDefinitions({
          A: {
              validator: "[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
              casing: "upper"
          },
          "&": {
              validator: "[0-9A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
              casing: "upper"
          },
          "#": {
              validator: "[0-9A-Fa-f]",
              casing: "upper"
          }
      });
      var ipValidatorRegex = new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]");

      function ipValidator(chrs, maskset, pos, strict, opts) {
          return chrs = -1 < pos - 1 && "." !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, -1 < pos - 2 && "." !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : "0" + chrs) : "00" + chrs, ipValidatorRegex.test(chrs)
      }
      _inputmask.default.extendAliases({
          cssunit: {
              regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
          },
          url: {
              regex: "(https?|ftp)://.*",
              autoUnmask: !1,
              keepStatic: !1,
              tabThrough: !0
          },
          ip: {
              mask: "i[i[i]].j[j[j]].k[k[k]].l[l[l]]",
              definitions: {
                  i: {
                      validator: ipValidator
                  },
                  j: {
                      validator: ipValidator
                  },
                  k: {
                      validator: ipValidator
                  },
                  l: {
                      validator: ipValidator
                  }
              },
              onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
                  return maskedValue
              },
              inputmode: "numeric"
          },
          email: {
              mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
              greedy: !1,
              casing: "lower",
              onBeforePaste: function onBeforePaste(pastedValue, opts) {
                  return pastedValue = pastedValue.toLowerCase(), pastedValue.replace("mailto:", "")
              },
              definitions: {
                  "*": {
                      validator: "[0-9\uff11-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5!#$%&'*+/=?^_`{|}~-]"
                  },
                  "-": {
                      validator: "[0-9A-Za-z-]"
                  }
              },
              onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
                  return maskedValue
              },
              inputmode: "email"
          },
          mac: {
              mask: "##:##:##:##:##:##"
          },
          vin: {
              mask: "V{13}9{4}",
              definitions: {
                  V: {
                      validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                      casing: "upper"
                  }
              },
              clearIncomplete: !0,
              autoUnmask: !0
          },
          ssn: {
              mask: "999-99-9999",
              postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {
                  return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(buffer.join(""))
              }
          }
      })
  }, function(module, exports, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
              return typeof obj
          } : function _typeof(obj) {
              return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
          }, _typeof(obj)
      }
      "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === _typeof("test".__proto__) ? function(object) {
          return object.__proto__
      } : function(object) {
          return object.constructor.prototype
      })
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
          value: function value(searchElement, fromIndex) {
              if (null == this) throw new TypeError('"this" is null or not defined');
              var o = Object(this),
                  len = o.length >>> 0;
              if (0 == len) return !1;
              for (var n = 0 | fromIndex, k = Math.max(0 <= n ? n : len - Math.abs(n), 0); k < len;) {
                  if (o[k] === searchElement) return !0;
                  k++
              }
              return !1
          }
      })
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.generateMaskSet = generateMaskSet, exports.analyseMask = analyseMask;
      var _inputmask = _interopRequireDefault(__webpack_require__(13));

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }

      function generateMaskSet(opts, nocache) {
          var ms;

          function generateMask(mask, metadata, opts) {
              var regexMask = !1,
                  masksetDefinition, maskdefKey;
              if (null !== mask && "" !== mask || (regexMask = null !== opts.regex, mask = regexMask ? (mask = opts.regex, mask.replace(/^(\^)(.*)(\$)$/, "$2")) : (regexMask = !0, ".*")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = ""), 0 < opts.repeat || "*" === opts.repeat || "+" === opts.repeat) {
                  var repeatStart = "*" === opts.repeat ? 0 : "+" === opts.repeat ? 1 : opts.repeat;
                  mask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + "," + opts.repeat + opts.quantifiermarker[1]
              }
              return maskdefKey = regexMask ? "regex_" + opts.regex : opts.numericInput ? mask.split("").reverse().join("") : mask, !1 !== opts.keepStatic && (maskdefKey = "ks_" + maskdefKey), void 0 === Inputmask.prototype.masksCache[maskdefKey] || !0 === nocache ? (masksetDefinition = {
                  mask: mask,
                  maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),
                  validPositions: {},
                  _buffer: void 0,
                  buffer: void 0,
                  tests: {},
                  excludes: {},
                  metadata: metadata,
                  maskLength: void 0,
                  jitOffset: {}
              }, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition, masksetDefinition = _inputmask.default.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = _inputmask.default.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]), masksetDefinition
          }
          if ("function" == typeof opts.mask && (opts.mask = opts.mask(opts)), Array.isArray(opts.mask)) {
              if (1 < opts.mask.length) {
                  null === opts.keepStatic && (opts.keepStatic = !0);
                  var altMask = opts.groupmarker[0];
                  return (opts.isRTL ? opts.mask.reverse() : opts.mask).forEach(function(msk) {
                      1 < altMask.length && (altMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]), void 0 !== msk.mask && "function" != typeof msk.mask ? altMask += msk.mask : altMask += msk
                  }), altMask += opts.groupmarker[1], generateMask(altMask, opts.mask, opts)
              }
              opts.mask = opts.mask.pop()
          }
          return null === opts.keepStatic && (opts.keepStatic = !1), ms = opts.mask && void 0 !== opts.mask.mask && "function" != typeof opts.mask.mask ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts), ms
      }

      function analyseMask(mask, regexMask, opts) {
          var tokenizer = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g,
              regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
              escaped = !1,
              currentToken = new MaskToken,
              match, m, openenings = [],
              maskTokens = [],
              openingToken, currentOpeningToken, alternator, lastMatch, closeRegexGroup = !1;

          function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
              this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1, this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, this.quantifier = {
                  min: 1,
                  max: 1
              }
          }

          function insertTestDefinition(mtoken, element, position) {
              position = void 0 !== position ? position : mtoken.matches.length;
              var prevMatch = mtoken.matches[position - 1];
              if (regexMask) 0 === element.indexOf("[") || escaped && /\\d|\\s|\\w]/i.test(element) || "." === element ? mtoken.matches.splice(position++, 0, {
                  fn: new RegExp(element, opts.casing ? "i" : ""),
                  static: !1,
                  optionality: !1,
                  newBlockMarker: void 0 === prevMatch ? "master" : prevMatch.def !== element,
                  casing: null,
                  def: element,
                  placeholder: void 0,
                  nativeDef: element
              }) : (escaped && (element = element[element.length - 1]), element.split("").forEach(function(lmnt, ndx) {
                  prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {
                      fn: /[a-z]/i.test(opts.staticDefinitionSymbol || lmnt) ? new RegExp("[" + (opts.staticDefinitionSymbol || lmnt) + "]", opts.casing ? "i" : "") : null,
                      static: !0,
                      optionality: !1,
                      newBlockMarker: void 0 === prevMatch ? "master" : prevMatch.def !== lmnt && !0 !== prevMatch.static,
                      casing: null,
                      def: opts.staticDefinitionSymbol || lmnt,
                      placeholder: void 0 !== opts.staticDefinitionSymbol ? lmnt : void 0,
                      nativeDef: (escaped ? "'" : "") + lmnt
                  })
              })), escaped = !1;
              else {
                  var maskdef = opts.definitions && opts.definitions[element] || opts.usePrototypeDefinitions && Inputmask.prototype.definitions[element];
                  maskdef && !escaped ? mtoken.matches.splice(position++, 0, {
                      fn: maskdef.validator ? "string" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? "i" : "") : new function() {
                          this.test = maskdef.validator
                      } : new RegExp("."),
                      static: maskdef.static || !1,
                      optionality: !1,
                      newBlockMarker: void 0 === prevMatch ? "master" : prevMatch.def !== (maskdef.definitionSymbol || element),
                      casing: maskdef.casing,
                      def: maskdef.definitionSymbol || element,
                      placeholder: maskdef.placeholder,
                      nativeDef: element,
                      generated: maskdef.generated
                  }) : (mtoken.matches.splice(position++, 0, {
                      fn: /[a-z]/i.test(opts.staticDefinitionSymbol || element) ? new RegExp("[" + (opts.staticDefinitionSymbol || element) + "]", opts.casing ? "i" : "") : null,
                      static: !0,
                      optionality: !1,
                      newBlockMarker: void 0 === prevMatch ? "master" : prevMatch.def !== element && !0 !== prevMatch.static,
                      casing: null,
                      def: opts.staticDefinitionSymbol || element,
                      placeholder: void 0 !== opts.staticDefinitionSymbol ? element : void 0,
                      nativeDef: (escaped ? "'" : "") + element
                  }), escaped = !1)
              }
          }

          function verifyGroupMarker(maskToken) {
              maskToken && maskToken.matches && maskToken.matches.forEach(function(token, ndx) {
                  var nextToken = maskToken.matches[ndx + 1];
                  (void 0 === nextToken || void 0 === nextToken.matches || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1, regexMask || (insertTestDefinition(token, opts.groupmarker[0], 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker[1]))), verifyGroupMarker(token)
              })
          }

          function defaultCase() {
              if (0 < openenings.length) {
                  if (currentOpeningToken = openenings[openenings.length - 1], insertTestDefinition(currentOpeningToken, m), currentOpeningToken.isAlternator) {
                      alternator = openenings.pop();
                      for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup && (alternator.matches[mndx].isGroup = !1);
                      0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator)
                  }
              } else insertTestDefinition(currentToken, m)
          }

          function reverseTokens(maskToken) {
              function reverseStatic(st) {
                  return st === opts.optionalmarker[0] ? st = opts.optionalmarker[1] : st === opts.optionalmarker[1] ? st = opts.optionalmarker[0] : st === opts.groupmarker[0] ? st = opts.groupmarker[1] : st === opts.groupmarker[1] && (st = opts.groupmarker[0]), st
              }
              for (var match in maskToken.matches = maskToken.matches.reverse(), maskToken.matches)
                  if (Object.prototype.hasOwnProperty.call(maskToken.matches, match)) {
                      var intMatch = parseInt(match);
                      if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {
                          var qt = maskToken.matches[match];
                          maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt)
                      }
                      void 0 !== maskToken.matches[match].matches ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = reverseStatic(maskToken.matches[match])
                  } return maskToken
          }

          function groupify(matches) {
              var groupToken = new MaskToken(!0);
              return groupToken.openGroup = !1, groupToken.matches = matches, groupToken
          }

          function closeGroup() {
              if (openingToken = openenings.pop(), openingToken.openGroup = !1, void 0 !== openingToken)
                  if (0 < openenings.length) {
                      if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(openingToken), currentOpeningToken.isAlternator) {
                          alternator = openenings.pop();
                          for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1, alternator.matches[mndx].alternatorGroup = !1;
                          0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator)
                      }
                  } else currentToken.matches.push(openingToken);
              else defaultCase()
          }

          function groupQuantifier(matches) {
              var lastMatch = matches.pop();
              return lastMatch.isQuantifier && (lastMatch = groupify([matches.pop(), lastMatch])), lastMatch
          }
          for (regexMask && (opts.optionalmarker[0] = void 0, opts.optionalmarker[1] = void 0); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask);) {
              if (m = match[0], regexMask) switch (m.charAt(0)) {
                  case "?":
                      m = "{0,1}";
                      break;
                  case "+":
                  case "*":
                      m = "{" + m + "}";
                      break;
                  case "|":
                      if (0 === openenings.length) {
                          var altRegexGroup = groupify(currentToken.matches);
                          altRegexGroup.openGroup = !0, openenings.push(altRegexGroup), currentToken.matches = [], closeRegexGroup = !0
                      }
                      break
              }
              if (escaped) defaultCase();
              else switch (m.charAt(0)) {
                  case "$":
                  case "^":
                      regexMask || defaultCase();
                      break;
                  case "(?=":
                      break;
                  case "(?!":
                      break;
                  case "(?<=":
                      break;
                  case "(?<!":
                      break;
                  case opts.escapeChar:
                      escaped = !0, regexMask && defaultCase();
                      break;
                  case opts.optionalmarker[1]:
                  case opts.groupmarker[1]:
                      closeGroup();
                      break;
                  case opts.optionalmarker[0]:
                      openenings.push(new MaskToken(!1, !0));
                      break;
                  case opts.groupmarker[0]:
                      openenings.push(new MaskToken(!0));
                      break;
                  case opts.quantifiermarker[0]:
                      var quantifier = new MaskToken(!1, !1, !0);
                      m = m.replace(/[{}]/g, "");
                      var mqj = m.split("|"),
                          mq = mqj[0].split(","),
                          mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                          mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                      "*" !== mq0 && "+" !== mq0 || (mq0 = "*" === mq1 ? 0 : 1), quantifier.quantifier = {
                          min: mq0,
                          max: mq1,
                          jit: mqj[1]
                      };
                      var matches = 0 < openenings.length ? openenings[openenings.length - 1].matches : currentToken.matches;
                      if (match = matches.pop(), match.isAlternator) {
                          matches.push(match), matches = match.matches;
                          var groupToken = new MaskToken(!0),
                              tmpMatch = matches.pop();
                          matches.push(groupToken), matches = groupToken.matches, match = tmpMatch
                      }
                      match.isGroup || (match = groupify([match])), matches.push(match), matches.push(quantifier);
                      break;
                  case opts.alternatormarker:
                      if (0 < openenings.length) {
                          currentOpeningToken = openenings[openenings.length - 1];
                          var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];
                          lastMatch = currentOpeningToken.openGroup && (void 0 === subToken.matches || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : groupQuantifier(currentOpeningToken.matches)
                      } else lastMatch = groupQuantifier(currentToken.matches);
                      if (lastMatch.isAlternator) openenings.push(lastMatch);
                      else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(), lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch), openenings.push(alternator), lastMatch.openGroup) {
                          lastMatch.openGroup = !1;
                          var alternatorGroup = new MaskToken(!0);
                          alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup)
                      }
                      break;
                  default:
                      defaultCase()
              }
          }
          for (closeRegexGroup && closeGroup(); 0 < openenings.length;) openingToken = openenings.pop(), currentToken.matches.push(openingToken);
          return 0 < currentToken.matches.length && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)), (opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]), maskTokens
      }
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = void 0;
      var _default = {
          9: {
              validator: "[0-9\uff10-\uff19]",
              definitionSymbol: "*"
          },
          a: {
              validator: "[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]",
              definitionSymbol: "*"
          },
          "*": {
              validator: "[0-9\uff10-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]"
          }
      };
      exports.default = _default
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = void 0;
      var _default = {
          _maxTestPos: 500,
          placeholder: "_",
          optionalmarker: ["[", "]"],
          quantifiermarker: ["{", "}"],
          groupmarker: ["(", ")"],
          alternatormarker: "|",
          escapeChar: "\\",
          mask: null,
          regex: null,
          oncomplete: function oncomplete() {},
          onincomplete: function onincomplete() {},
          oncleared: function oncleared() {},
          repeat: 0,
          greedy: !1,
          autoUnmask: !1,
          removeMaskOnSubmit: !1,
          clearMaskOnLostFocus: !0,
          insertMode: !0,
          insertModeVisual: !0,
          clearIncomplete: !1,
          alias: null,
          onKeyDown: function onKeyDown() {},
          onBeforeMask: null,
          onBeforePaste: function onBeforePaste(pastedValue, opts) {
              return "function" == typeof opts.onBeforeMask ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue
          },
          onBeforeWrite: null,
          onUnMask: null,
          showMaskOnFocus: !0,
          showMaskOnHover: !0,
          onKeyValidation: function onKeyValidation() {},
          skipOptionalPartCharacter: " ",
          numericInput: !1,
          rightAlign: !1,
          undoOnEscape: !0,
          radixPoint: "",
          _radixDance: !1,
          groupSeparator: "",
          keepStatic: null,
          positionCaretOnTab: !0,
          tabThrough: !1,
          supportsInputType: ["text", "tel", "url", "password", "search"],
          ignorables: [8, 9, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
          isComplete: null,
          preValidation: null,
          postValidation: null,
          staticDefinitionSymbol: void 0,
          jitMasking: !1,
          nullable: !0,
          inputEventOnly: !1,
          noValuePatching: !1,
          positionCaretOnClick: "lvp",
          casing: null,
          inputmode: "text",
          importDataAttributes: !0,
          shiftPositions: !0,
          usePrototypeDefinitions: !0
      };
      exports.default = _default
  }, function(module, exports, __webpack_require__) {
      "use strict";
      var _inputmask = _interopRequireDefault(__webpack_require__(1)),
          _keycode = _interopRequireDefault(__webpack_require__(0)),
          _escapeRegex = _interopRequireDefault(__webpack_require__(14)),
          _positioning = __webpack_require__(2);

      function _typeof(obj) {
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
              return typeof obj
          } : function _typeof(obj) {
              return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
          }, _typeof(obj)
      }

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var $ = _inputmask.default.dependencyLib,
          currentYear = (new Date).getFullYear(),
          formatCode = {
              d: ["[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate],
              dd: ["0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                  return pad(Date.prototype.getDate.call(this), 2)
              }],
              ddd: [""],
              dddd: [""],
              m: ["[1-9]|1[012]", Date.prototype.setMonth, "month", function() {
                  return Date.prototype.getMonth.call(this) + 1
              }],
              mm: ["0[1-9]|1[012]", Date.prototype.setMonth, "month", function() {
                  return pad(Date.prototype.getMonth.call(this) + 1, 2)
              }],
              mmm: [""],
              mmmm: [""],
              yy: ["[0-9]{2}", Date.prototype.setFullYear, "year", function() {
                  return pad(Date.prototype.getFullYear.call(this), 2)
              }],
              yyyy: ["[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                  return pad(Date.prototype.getFullYear.call(this), 4)
              }],
              h: ["[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours],
              hh: ["0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                  return pad(Date.prototype.getHours.call(this), 2)
              }],
              hx: [function(x) {
                  return "[0-9]{".concat(x, "}")
              }, Date.prototype.setHours, "hours", function(x) {
                  return Date.prototype.getHours
              }],
              H: ["1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours],
              HH: ["0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                  return pad(Date.prototype.getHours.call(this), 2)
              }],
              Hx: [function(x) {
                  return "[0-9]{".concat(x, "}")
              }, Date.prototype.setHours, "hours", function(x) {
                  return function() {
                      return pad(Date.prototype.getHours.call(this), x)
                  }
              }],
              M: ["[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes],
              MM: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                  return pad(Date.prototype.getMinutes.call(this), 2)
              }],
              s: ["[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds],
              ss: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
                  return pad(Date.prototype.getSeconds.call(this), 2)
              }],
              l: ["[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                  return pad(Date.prototype.getMilliseconds.call(this), 3)
              }],
              L: ["[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                  return pad(Date.prototype.getMilliseconds.call(this), 2)
              }],
              t: ["[ap]"],
              tt: ["[ap]m"],
              T: ["[AP]"],
              TT: ["[AP]M"],
              Z: [""],
              o: [""],
              S: [""]
          },
          formatAlias = {
              isoDate: "yyyy-mm-dd",
              isoTime: "HH:MM:ss",
              isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
              isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
          };

      function formatcode(match) {
          var dynMatches = new RegExp("\\d+$").exec(match[0]);
          if (dynMatches && void 0 !== dynMatches[0]) {
              var fcode = formatCode[match[0][0] + "x"].slice("");
              return fcode[0] = fcode[0](dynMatches[0]), fcode[3] = fcode[3](dynMatches[0]), fcode
          }
          if (formatCode[match[0]]) return formatCode[match[0]]
      }

      function getTokenizer(opts) {
          if (!opts.tokenizer) {
              var tokens = [],
                  dyntokens = [];
              for (var ndx in formatCode)
                  if (/\.*x$/.test(ndx)) {
                      var dynToken = ndx[0] + "\\d+"; - 1 === dyntokens.indexOf(dynToken) && dyntokens.push(dynToken)
                  } else - 1 === tokens.indexOf(ndx[0]) && tokens.push(ndx[0]);
              opts.tokenizer = "(" + (0 < dyntokens.length ? dyntokens.join("|") + "|" : "") + tokens.join("+|") + ")+?|.", opts.tokenizer = new RegExp(opts.tokenizer, "g")
          }
          return opts.tokenizer
      }

      function prefillYear(dateParts, currentResult, opts) {
          if (dateParts.year !== dateParts.rawyear) {
              var crrntyear = currentYear.toString(),
                  enteredPart = dateParts.rawyear.replace(/[^0-9]/g, ""),
                  currentYearPart = crrntyear.slice(0, enteredPart.length),
                  currentYearNextPart = crrntyear.slice(enteredPart.length);
              if (2 === enteredPart.length && enteredPart === currentYearPart) {
                  var entryCurrentYear = new Date(currentYear, dateParts.month - 1, dateParts.day);
                  dateParts.day == entryCurrentYear.getDate() && (!opts.max || opts.max.date.getTime() >= entryCurrentYear.getTime()) && (dateParts.date.setFullYear(currentYear), dateParts.year = crrntyear, currentResult.insert = [{
                      pos: currentResult.pos + 1,
                      c: currentYearNextPart[0]
                  }, {
                      pos: currentResult.pos + 2,
                      c: currentYearNextPart[1]
                  }])
              }
          }
          return currentResult
      }

      function isValidDate(dateParts, currentResult, opts) {
          if (void 0 === dateParts.rawday || !isFinite(dateParts.rawday) && new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day || "29" == dateParts.day && !isFinite(dateParts.rawyear) || new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day) return currentResult;
          if ("29" == dateParts.day) {
              var tokenMatch = getTokenMatch(currentResult.pos, opts);
              if ("yyyy" === tokenMatch.targetMatch[0] && currentResult.pos - tokenMatch.targetMatchIndex == 2) return currentResult.remove = currentResult.pos + 1, currentResult
          } else if ("02" == dateParts.month && "30" == dateParts.day) return dateParts.day = "03", dateParts.date.setDate(3), dateParts.date.setMonth(1), currentResult.insert = [{
              pos: currentResult.pos,
              c: "0"
          }, {
              pos: currentResult.pos + 1,
              c: currentResult.c
          }], currentResult.caret = _positioning.seekNext.call(this, currentResult.pos + 1), currentResult;
          return !1
      }

      function isDateInRange(dateParts, result, opts, maskset, fromCheckval) {
          if (!result) return result;
          if (opts.min) {
              if (dateParts.rawyear) {
                  var rawYear = dateParts.rawyear.replace(/[^0-9]/g, ""),
                      minYear = opts.min.year.substr(0, rawYear.length),
                      maxYear;
                  if (rawYear < minYear) {
                      var tokenMatch = getTokenMatch(result.pos, opts);
                      if (rawYear = dateParts.rawyear.substr(0, result.pos - tokenMatch.targetMatchIndex + 1).replace(/[^0-9]/g, "0"), minYear = opts.min.year.substr(0, rawYear.length), minYear <= rawYear) return result.remove = tokenMatch.targetMatchIndex + rawYear.length, result;
                      if (rawYear = "yyyy" === tokenMatch.targetMatch[0] ? dateParts.rawyear.substr(1, 1) : dateParts.rawyear.substr(0, 1), minYear = opts.min.year.substr(2, 1), maxYear = opts.max ? opts.max.year.substr(2, 1) : rawYear, 1 === rawYear.length && minYear <= rawYear && rawYear <= maxYear && !0 !== fromCheckval) return "yyyy" === tokenMatch.targetMatch[0] ? (result.insert = [{
                          pos: result.pos + 1,
                          c: rawYear,
                          strict: !0
                      }], result.caret = result.pos + 2, maskset.validPositions[result.pos].input = opts.min.year[1]) : (result.insert = [{
                          pos: result.pos + 1,
                          c: opts.min.year[1],
                          strict: !0
                      }, {
                          pos: result.pos + 2,
                          c: rawYear,
                          strict: !0
                      }], result.caret = result.pos + 3, maskset.validPositions[result.pos].input = opts.min.year[0]), result;
                      result = !1
                  }
              }
              result && dateParts.year && dateParts.year === dateParts.rawyear && opts.min.date.getTime() == opts.min.date.getTime() && (result = opts.min.date.getTime() <= dateParts.date.getTime())
          }
          return result && opts.max && opts.max.date.getTime() == opts.max.date.getTime() && (result = opts.max.date.getTime() >= dateParts.date.getTime()), result
      }

      function parse(format, dateObjValue, opts, raw) {
          var mask = "",
              match, fcode;
          for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(format);)
              if (void 0 === dateObjValue)
                  if (fcode = formatcode(match)) mask += "(" + fcode[0] + ")";
                  else switch (match[0]) {
                      case "[":
                          mask += "(";
                          break;
                      case "]":
                          mask += ")?";
                          break;
                      default:
                          mask += (0, _escapeRegex.default)(match[0])
                  } else if (fcode = formatcode(match))
                      if (!0 !== raw && fcode[3]) {
                          var getFn = fcode[3];
                          mask += getFn.call(dateObjValue.date)
                      } else fcode[2] ? mask += dateObjValue["raw" + fcode[2]] : mask += match[0];
          else mask += match[0];
          return mask
      }

      function pad(val, len) {
          for (val = String(val), len = len || 2; val.length < len;) val = "0" + val;
          return val
      }

      function analyseMask(maskString, format, opts) {
          var dateObj = {
                  date: new Date(1, 0, 1)
              },
              targetProp, mask = maskString,
              match, dateOperation;

          function setValue(dateObj, value, opts) {
              if (dateObj[targetProp] = value.replace(/[^0-9]/g, "0"), dateObj["raw" + targetProp] = value, void 0 !== dateOperation) {
                  var datavalue = dateObj[targetProp];
                  "day" === targetProp && 0 === parseInt(datavalue) && (datavalue = 1), "month" === targetProp && (datavalue = parseInt(datavalue), 0 < datavalue) && (datavalue -= 1), dateOperation.call(dateObj.date, datavalue)
              }
          }
          if ("string" == typeof mask) {
              for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(format);) {
                  var dynMatches = new RegExp("\\d+$").exec(match[0]),
                      fcode = dynMatches ? match[0][0] + "x" : match[0],
                      value = void 0;
                  if (dynMatches) {
                      var lastIndex = getTokenizer(opts).lastIndex,
                          tokanMatch = getTokenMatch(match.index, opts);
                      getTokenizer(opts).lastIndex = lastIndex, value = mask.slice(0, mask.indexOf(tokanMatch.nextMatch[0]))
                  } else value = mask.slice(0, fcode.length);
                  Object.prototype.hasOwnProperty.call(formatCode, fcode) && (targetProp = formatCode[fcode][2], dateOperation = formatCode[fcode][1], setValue(dateObj, value, opts)), mask = mask.slice(value.length)
              }
              return dateObj
          }
          if (mask && "object" === _typeof(mask) && Object.prototype.hasOwnProperty.call(mask, "date")) return mask
      }

      function importDate(dateObj, opts) {
          return parse(opts.inputFormat, {
              date: dateObj
          }, opts)
      }

      function getTokenMatch(pos, opts) {
          var calcPos = 0,
              targetMatch, match, matchLength = 0;
          for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(opts.inputFormat);) {
              var dynMatches = new RegExp("\\d+$").exec(match[0]);
              if (matchLength = dynMatches ? parseInt(dynMatches[0]) : match[0].length, calcPos += matchLength, pos <= calcPos) {
                  targetMatch = match, match = getTokenizer(opts).exec(opts.inputFormat);
                  break
              }
          }
          return {
              targetMatchIndex: calcPos - matchLength,
              nextMatch: match,
              targetMatch: targetMatch
          }
      }
      _inputmask.default.extendAliases({
          datetime: {
              mask: function mask(opts) {
                  return opts.numericInput = !1, formatCode.S = opts.i18n.ordinalSuffix.join("|"), opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat, opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat, opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat, opts.placeholder = "" !== opts.placeholder ? opts.placeholder : opts.inputFormat.replace(/[[\]]/, ""), opts.regex = parse(opts.inputFormat, void 0, opts), opts.min = analyseMask(opts.min, opts.inputFormat, opts), opts.max = analyseMask(opts.max, opts.inputFormat, opts), null
              },
              placeholder: "",
              inputFormat: "isoDateTime",
              displayFormat: void 0,
              outputFormat: void 0,
              min: null,
              max: null,
              skipOptionalPartCharacter: "",
              i18n: {
                  dayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
                  monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                  ordinalSuffix: ["st", "nd", "rd", "th"]
              },
              preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) {
                  if (strict) return !0;
                  if (isNaN(c) && buffer[pos] !== c) {
                      var tokenMatch = getTokenMatch(pos, opts);
                      if (tokenMatch.nextMatch && tokenMatch.nextMatch[0] === c && 1 < tokenMatch.targetMatch[0].length) {
                          var validator = formatCode[tokenMatch.targetMatch[0]][0];
                          if (new RegExp(validator).test("0" + buffer[pos - 1])) return buffer[pos] = buffer[pos - 1], buffer[pos - 1] = "0", {
                              fuzzy: !0,
                              buffer: buffer,
                              refreshFromBuffer: {
                                  start: pos - 1,
                                  end: pos + 1
                              },
                              pos: pos + 1
                          }
                      }
                  }
                  return !0
              },
              postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict, fromCheckval) {
                  var inputmask = this,
                      tokenMatch, validator;
                  if (strict) return !0;
                  if (!1 === currentResult) return tokenMatch = getTokenMatch(pos + 1, opts), tokenMatch.targetMatch && tokenMatch.targetMatchIndex === pos && 1 < tokenMatch.targetMatch[0].length && void 0 !== formatCode[tokenMatch.targetMatch[0]] && (validator = formatCode[tokenMatch.targetMatch[0]][0], new RegExp(validator).test("0" + c)) ? {
                      insert: [{
                          pos: pos,
                          c: "0"
                      }, {
                          pos: pos + 1,
                          c: c
                      }],
                      pos: pos + 1
                  } : currentResult;
                  if (currentResult.fuzzy && (buffer = currentResult.buffer, pos = currentResult.pos), tokenMatch = getTokenMatch(pos, opts), tokenMatch.targetMatch && tokenMatch.targetMatch[0] && void 0 !== formatCode[tokenMatch.targetMatch[0]]) {
                      validator = formatCode[tokenMatch.targetMatch[0]][0];
                      var part = buffer.slice(tokenMatch.targetMatchIndex, tokenMatch.targetMatchIndex + tokenMatch.targetMatch[0].length);
                      !1 === new RegExp(validator).test(part.join("")) && 2 === tokenMatch.targetMatch[0].length && maskset.validPositions[tokenMatch.targetMatchIndex] && maskset.validPositions[tokenMatch.targetMatchIndex + 1] && (maskset.validPositions[tokenMatch.targetMatchIndex + 1].input = "0")
                  }
                  var result = currentResult,
                      dateParts = analyseMask(buffer.join(""), opts.inputFormat, opts);
                  return result && dateParts.date.getTime() == dateParts.date.getTime() && (result = prefillYear(dateParts, result, opts), result = isValidDate.call(this, dateParts, result, opts), result = isDateInRange(dateParts, result, opts, maskset, fromCheckval)), pos && result && currentResult.pos !== pos ? {
                      buffer: parse(opts.inputFormat, dateParts, opts).split(""),
                      refreshFromBuffer: {
                          start: pos,
                          end: currentResult.pos
                      }
                  } : result
              },
              onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {
                  var input = this;
                  e.ctrlKey && e.keyCode === _keycode.default.RIGHT && (this.inputmask._valueSet(importDate(new Date, opts)), $(this).trigger("setvalue"))
              },
              onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
                  return unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, !0) : unmaskedValue
              },
              casing: function casing(elem, test, pos, validPositions) {
                  return 0 == test.nativeDef.indexOf("[ap]") ? elem.toLowerCase() : 0 == test.nativeDef.indexOf("[AP]") ? elem.toUpperCase() : elem
              },
              onBeforeMask: function onBeforeMask(initialValue, opts) {
                  return "[object Date]" === Object.prototype.toString.call(initialValue) && (initialValue = importDate(initialValue, opts)), initialValue
              },
              insertMode: !1,
              shiftPositions: !1,
              keepStatic: !1,
              inputmode: "numeric"
          }
      })
  }, function(module, exports, __webpack_require__) {
      "use strict";
      var _inputmask = _interopRequireDefault(__webpack_require__(1)),
          _keycode = _interopRequireDefault(__webpack_require__(0)),
          _escapeRegex = _interopRequireDefault(__webpack_require__(14));

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var $ = _inputmask.default.dependencyLib;

      function autoEscape(txt, opts) {
          for (var escapedTxt = "", i = 0; i < txt.length; i++) _inputmask.default.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker[0] === txt.charAt(i) || opts.optionalmarker[1] === txt.charAt(i) || opts.quantifiermarker[0] === txt.charAt(i) || opts.quantifiermarker[1] === txt.charAt(i) || opts.groupmarker[0] === txt.charAt(i) || opts.groupmarker[1] === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += "\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);
          return escapedTxt
      }

      function alignDigits(buffer, digits, opts, force) {
          if (0 < buffer.length && 0 < digits && (!opts.digitsOptional || force)) {
              var radixPosition = buffer.indexOf(opts.radixPoint),
                  negationBack = !1;
              opts.negationSymbol.back === buffer[buffer.length - 1] && (negationBack = !0, buffer.length--), -1 === radixPosition && (buffer.push(opts.radixPoint), radixPosition = buffer.length - 1);
              for (var i = 1; i <= digits; i++) isFinite(buffer[radixPosition + i]) || (buffer[radixPosition + i] = "0")
          }
          return negationBack && buffer.push(opts.negationSymbol.back), buffer
      }

      function findValidator(symbol, maskset) {
          var posNdx = 0;
          if ("+" === symbol) {
              for (posNdx in maskset.validPositions);
              posNdx = parseInt(posNdx)
          }
          for (var tstNdx in maskset.tests)
              if (tstNdx = parseInt(tstNdx), posNdx <= tstNdx)
                  for (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++)
                      if ((void 0 === maskset.validPositions[tstNdx] || "-" === symbol) && maskset.tests[tstNdx][ndx].match.def === symbol) return tstNdx + (void 0 !== maskset.validPositions[tstNdx] && "-" !== symbol ? 1 : 0);
          return posNdx
      }

      function findValid(symbol, maskset) {
          var ret = -1;
          for (var ndx in maskset.validPositions) {
              var tst = maskset.validPositions[ndx];
              if (tst && tst.match.def === symbol) {
                  ret = parseInt(ndx);
                  break
              }
          }
          return ret
      }

      function parseMinMaxOptions(opts) {
          void 0 === opts.parseMinMaxOptions && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp((0, _escapeRegex.default)(opts.groupSeparator), "g"), ""), "," === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, ".")), opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)), null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp((0, _escapeRegex.default)(opts.groupSeparator), "g"), ""), "," === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, ".")), opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)), opts.parseMinMaxOptions = "done")
      }

      function genMask(opts) {
          opts.repeat = 0, opts.groupSeparator === opts.radixPoint && opts.digits && "0" !== opts.digits && ("." === opts.radixPoint ? opts.groupSeparator = "," : "," === opts.radixPoint ? opts.groupSeparator = "." : opts.groupSeparator = ""), " " === opts.groupSeparator && (opts.skipOptionalPartCharacter = void 0), 1 < opts.placeholder.length && (opts.placeholder = opts.placeholder.charAt(0)), "radixFocus" === opts.positionCaretOnClick && "" === opts.placeholder && (opts.positionCaretOnClick = "lvp");
          var decimalDef = "0",
              radixPointDef = opts.radixPoint;
          !0 === opts.numericInput && void 0 === opts.__financeInput ? (decimalDef = "1", opts.positionCaretOnClick = "radixFocus" === opts.positionCaretOnClick ? "lvp" : opts.positionCaretOnClick, opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts._radixDance = !1, radixPointDef = "," === opts.radixPoint ? "?" : "!", "" !== opts.radixPoint && void 0 === opts.definitions[radixPointDef] && (opts.definitions[radixPointDef] = {}, opts.definitions[radixPointDef].validator = "[" + opts.radixPoint + "]", opts.definitions[radixPointDef].placeholder = opts.radixPoint, opts.definitions[radixPointDef].static = !0, opts.definitions[radixPointDef].generated = !0)) : (opts.__financeInput = !1, opts.numericInput = !0);
          var mask = "[+]",
              altMask;
          if (mask += autoEscape(opts.prefix, opts), "" !== opts.groupSeparator ? (void 0 === opts.definitions[opts.groupSeparator] && (opts.definitions[opts.groupSeparator] = {}, opts.definitions[opts.groupSeparator].validator = "[" + opts.groupSeparator + "]", opts.definitions[opts.groupSeparator].placeholder = opts.groupSeparator, opts.definitions[opts.groupSeparator].static = !0, opts.definitions[opts.groupSeparator].generated = !0), mask += opts._mask(opts)) : mask += "9{+}", void 0 !== opts.digits && 0 !== opts.digits) {
              var dq = opts.digits.toString().split(",");
              isFinite(dq[0]) && dq[1] && isFinite(dq[1]) ? mask += radixPointDef + decimalDef + "{" + opts.digits + "}" : (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && (opts.digitsOptional ? (altMask = mask + radixPointDef + decimalDef + "{0," + opts.digits + "}", opts.keepStatic = !0) : mask += radixPointDef + decimalDef + "{" + opts.digits + "}")
          }
          return mask += autoEscape(opts.suffix, opts), mask += "[-]", altMask && (mask = [altMask + autoEscape(opts.suffix, opts) + "[-]", mask]), opts.greedy = !1, parseMinMaxOptions(opts), mask
      }

      function hanndleRadixDance(pos, c, radixPos, maskset, opts) {
          return opts._radixDance && opts.numericInput && c !== opts.negationSymbol.back && pos <= radixPos && (0 < radixPos || c == opts.radixPoint) && (void 0 === maskset.validPositions[pos - 1] || maskset.validPositions[pos - 1].input !== opts.negationSymbol.back) && (pos -= 1), pos
      }

      function decimalValidator(chrs, maskset, pos, strict, opts) {
          var radixPos = maskset.buffer ? maskset.buffer.indexOf(opts.radixPoint) : -1,
              result = -1 !== radixPos && new RegExp("[0-9\uff11-\uff19]").test(chrs);
          return opts._radixDance && result && null == maskset.validPositions[radixPos] ? {
              insert: {
                  pos: radixPos === pos ? radixPos + 1 : radixPos,
                  c: opts.radixPoint
              },
              pos: pos
          } : result
      }

      function checkForLeadingZeroes(buffer, opts) {
          var numberMatches = new RegExp("(^" + ("" !== opts.negationSymbol.front ? (0, _escapeRegex.default)(opts.negationSymbol.front) + "?" : "") + (0, _escapeRegex.default)(opts.prefix) + ")(.*)(" + (0, _escapeRegex.default)(opts.suffix) + ("" != opts.negationSymbol.back ? (0, _escapeRegex.default)(opts.negationSymbol.back) + "?" : "") + "$)").exec(buffer.slice().reverse().join("")),
              number = numberMatches ? numberMatches[2] : "",
              leadingzeroes = !1;
          return number && (number = number.split(opts.radixPoint.charAt(0))[0], leadingzeroes = new RegExp("^[0" + opts.groupSeparator + "]*").exec(number)), !(!leadingzeroes || !(1 < leadingzeroes[0].length || 0 < leadingzeroes[0].length && leadingzeroes[0].length < number.length)) && leadingzeroes
      }
      _inputmask.default.extendAliases({
          numeric: {
              mask: genMask,
              _mask: function _mask(opts) {
                  return "(" + opts.groupSeparator + "999){+|1}"
              },
              digits: "*",
              digitsOptional: !0,
              enforceDigitsOnBlur: !1,
              radixPoint: ".",
              positionCaretOnClick: "radixFocus",
              _radixDance: !0,
              groupSeparator: "",
              allowMinus: !0,
              negationSymbol: {
                  front: "-",
                  back: ""
              },
              prefix: "",
              suffix: "",
              min: null,
              max: null,
              SetMaxOnOverflow: !1,
              step: 1,
              inputType: "text",
              unmaskAsNumber: !1,
              roundingFN: Math.round,
              inputmode: "numeric",
              shortcuts: {
                  k: "000",
                  m: "000000"
              },
              placeholder: "0",
              greedy: !1,
              rightAlign: !0,
              insertMode: !0,
              autoUnmask: !1,
              skipOptionalPartCharacter: "",
              definitions: {
                  0: {
                      validator: decimalValidator
                  },
                  1: {
                      validator: decimalValidator,
                      definitionSymbol: "9"
                  },
                  "+": {
                      validator: function validator(chrs, maskset, pos, strict, opts) {
                          return opts.allowMinus && ("-" === chrs || chrs === opts.negationSymbol.front)
                      }
                  },
                  "-": {
                      validator: function validator(chrs, maskset, pos, strict, opts) {
                          return opts.allowMinus && chrs === opts.negationSymbol.back
                      }
                  }
              },
              preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) {
                  if (!1 !== opts.__financeInput && c === opts.radixPoint) return !1;
                  var pattern;
                  if (pattern = opts.shortcuts && opts.shortcuts[c]) {
                      if (1 < pattern.length)
                          for (var inserts = [], i = 0; i < pattern.length; i++) inserts.push({
                              pos: pos + i,
                              c: pattern[i],
                              strict: !1
                          });
                      return {
                          insert: inserts
                      }
                  }
                  var radixPos = buffer.indexOf(opts.radixPoint),
                      initPos = pos;
                  if (pos = hanndleRadixDance(pos, c, radixPos, maskset, opts), "-" === c || c === opts.negationSymbol.front) {
                      if (!0 !== opts.allowMinus) return !1;
                      var isNegative = !1,
                          front = findValid("+", maskset),
                          back = findValid("-", maskset);
                      return -1 !== front && (isNegative = [front, back]), !1 !== isNegative ? {
                          remove: isNegative,
                          caret: initPos - opts.negationSymbol.front.length
                      } : {
                          insert: [{
                              pos: findValidator("+", maskset),
                              c: opts.negationSymbol.front,
                              fromIsValid: !0
                          }, {
                              pos: findValidator("-", maskset),
                              c: opts.negationSymbol.back,
                              fromIsValid: void 0
                          }],
                          caret: initPos + opts.negationSymbol.back.length
                      }
                  }
                  if (c === opts.groupSeparator) return {
                      caret: initPos
                  };
                  if (strict) return !0;
                  if (-1 !== radixPos && !0 === opts._radixDance && !1 === isSelection && c === opts.radixPoint && void 0 !== opts.digits && (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && radixPos !== pos) return {
                      caret: opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos
                  };
                  if (!1 === opts.__financeInput)
                      if (isSelection) {
                          if (opts.digitsOptional) return {
                              rewritePosition: caretPos.end
                          };
                          if (!opts.digitsOptional) {
                              if (caretPos.begin > radixPos && caretPos.end <= radixPos) return c === opts.radixPoint ? {
                                  insert: {
                                      pos: radixPos + 1,
                                      c: "0",
                                      fromIsValid: !0
                                  },
                                  rewritePosition: radixPos
                              } : {
                                  rewritePosition: radixPos + 1
                              };
                              if (caretPos.begin < radixPos) return {
                                  rewritePosition: caretPos.begin - 1
                              }
                          }
                      } else if (!opts.showMaskOnHover && !opts.showMaskOnFocus && !opts.digitsOptional && 0 < opts.digits && "" === this.__valueGet.call(this)) return {
                      rewritePosition: radixPos
                  };
                  return {
                      rewritePosition: pos
                  }
              },
              postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {
                  if (!1 === currentResult) return currentResult;
                  if (strict) return !0;
                  if (null !== opts.min || null !== opts.max) {
                      var unmasked = opts.onUnMask(buffer.slice().reverse().join(""), void 0, $.extend({}, opts, {
                          unmaskAsNumber: !0
                      }));
                      if (null !== opts.min && unmasked < opts.min && (unmasked.toString().length > opts.min.toString().length || unmasked < 0)) return !1;
                      if (null !== opts.max && unmasked > opts.max) return !!opts.SetMaxOnOverflow && {
                          refreshFromBuffer: !0,
                          buffer: alignDigits(opts.max.toString().replace(".", opts.radixPoint).split(""), opts.digits, opts).reverse()
                      }
                  }
                  return currentResult
              },
              onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
                  if ("" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;
                  var processValue = maskedValue.replace(opts.prefix, "");
                  return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp((0, _escapeRegex.default)(opts.groupSeparator), "g"), ""), "" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), "g"), "0")), opts.unmaskAsNumber ? ("" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(_escapeRegex.default.call(this, opts.radixPoint), ".")), processValue = processValue.replace(new RegExp("^" + (0, _escapeRegex.default)(opts.negationSymbol.front)), "-"), processValue = processValue.replace(new RegExp((0, _escapeRegex.default)(opts.negationSymbol.back) + "$"), ""), Number(processValue)) : processValue
              },
              isComplete: function isComplete(buffer, opts) {
                  var maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join("");
                  return maskedValue = maskedValue.replace(new RegExp("^" + (0, _escapeRegex.default)(opts.negationSymbol.front)), "-"), maskedValue = maskedValue.replace(new RegExp((0, _escapeRegex.default)(opts.negationSymbol.back) + "$"), ""), maskedValue = maskedValue.replace(opts.prefix, ""), maskedValue = maskedValue.replace(opts.suffix, ""), maskedValue = maskedValue.replace(new RegExp((0, _escapeRegex.default)(opts.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === opts.radixPoint && (maskedValue = maskedValue.replace((0, _escapeRegex.default)(opts.radixPoint), ".")), isFinite(maskedValue)
              },
              onBeforeMask: function onBeforeMask(initialValue, opts) {
                  var radixPoint = opts.radixPoint || ",";
                  isFinite(opts.digits) && (opts.digits = parseInt(opts.digits)), "number" != typeof initialValue && "number" !== opts.inputType || "" === radixPoint || (initialValue = initialValue.toString().replace(".", radixPoint));
                  var isNagtive = "-" === initialValue.charAt(0) || initialValue.charAt(0) === opts.negationSymbol.front,
                      valueParts = initialValue.split(radixPoint),
                      integerPart = valueParts[0].replace(/[^\-0-9]/g, ""),
                      decimalPart = 1 < valueParts.length ? valueParts[1].replace(/[^0-9]/g, "") : "",
                      forceDigits = 1 < valueParts.length;
                  initialValue = integerPart + ("" !== decimalPart ? radixPoint + decimalPart : decimalPart);
                  var digits = 0;
                  if ("" !== radixPoint && (digits = opts.digitsOptional ? opts.digits < decimalPart.length ? opts.digits : decimalPart.length : opts.digits, "" !== decimalPart || !opts.digitsOptional)) {
                      var digitsFactor = Math.pow(10, digits || 1);
                      initialValue = initialValue.replace((0, _escapeRegex.default)(radixPoint), "."), isNaN(parseFloat(initialValue)) || (initialValue = (opts.roundingFN(parseFloat(initialValue) * digitsFactor) / digitsFactor).toFixed(digits)), initialValue = initialValue.toString().replace(".", radixPoint)
                  }
                  if (0 === opts.digits && -1 !== initialValue.indexOf(radixPoint) && (initialValue = initialValue.substring(0, initialValue.indexOf(radixPoint))), null !== opts.min || null !== opts.max) {
                      var numberValue = initialValue.toString().replace(radixPoint, ".");
                      null !== opts.min && numberValue < opts.min ? initialValue = opts.min.toString().replace(".", radixPoint) : null !== opts.max && numberValue > opts.max && (initialValue = opts.max.toString().replace(".", radixPoint))
                  }
                  return isNagtive && "-" !== initialValue.charAt(0) && (initialValue = "-" + initialValue), alignDigits(initialValue.toString().split(""), digits, opts, forceDigits).join("")
              },
              onBeforeWrite: function onBeforeWrite(e, buffer, caretPos, opts) {
                  function stripBuffer(buffer, stripRadix) {
                      if (!1 !== opts.__financeInput || stripRadix) {
                          var position = buffer.indexOf(opts.radixPoint); - 1 !== position && buffer.splice(position, 1)
                      }
                      if ("" !== opts.groupSeparator)
                          for (; - 1 !== (position = buffer.indexOf(opts.groupSeparator));) buffer.splice(position, 1);
                      return buffer
                  }
                  var result, leadingzeroes = checkForLeadingZeroes(buffer, opts);
                  if (leadingzeroes)
                      for (var caretNdx = buffer.join("").lastIndexOf(leadingzeroes[0].split("").reverse().join("")) - (leadingzeroes[0] == leadingzeroes.input ? 0 : 1), offset = leadingzeroes[0] == leadingzeroes.input ? 1 : 0, i = leadingzeroes[0].length - offset; 0 < i; i--) delete this.maskset.validPositions[caretNdx + i], delete buffer[caretNdx + i];
                  if (e) switch (e.type) {
                      case "blur":
                      case "checkval":
                          if (null !== opts.min) {
                              var unmasked = opts.onUnMask(buffer.slice().reverse().join(""), void 0, $.extend({}, opts, {
                                  unmaskAsNumber: !0
                              }));
                              if (null !== opts.min && unmasked < opts.min) return {
                                  refreshFromBuffer: !0,
                                  buffer: alignDigits(opts.min.toString().replace(".", opts.radixPoint).split(""), opts.digits, opts).reverse()
                              }
                          }
                          if (buffer[buffer.length - 1] === opts.negationSymbol.front) {
                              var nmbrMtchs = new RegExp("(^" + ("" != opts.negationSymbol.front ? (0, _escapeRegex.default)(opts.negationSymbol.front) + "?" : "") + (0, _escapeRegex.default)(opts.prefix) + ")(.*)(" + (0, _escapeRegex.default)(opts.suffix) + ("" != opts.negationSymbol.back ? (0, _escapeRegex.default)(opts.negationSymbol.back) + "?" : "") + "$)").exec(stripBuffer(buffer.slice(), !0).reverse().join("")),
                                  number = nmbrMtchs ? nmbrMtchs[2] : "";
                              0 == number && (result = {
                                  refreshFromBuffer: !0,
                                  buffer: [0]
                              })
                          } else "" !== opts.radixPoint && buffer[0] === opts.radixPoint && (result && result.buffer ? result.buffer.shift() : (buffer.shift(), result = {
                              refreshFromBuffer: !0,
                              buffer: stripBuffer(buffer)
                          }));
                          if (opts.enforceDigitsOnBlur) {
                              result = result || {};
                              var bffr = result && result.buffer || buffer.slice().reverse();
                              result.refreshFromBuffer = !0, result.buffer = alignDigits(bffr, opts.digits, opts, !0).reverse()
                          }
                  }
                  return result
              },
              onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {
                  var $input = $(this),
                      bffr;
                  if (e.ctrlKey) switch (e.keyCode) {
                      case _keycode.default.UP:
                          return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger("setvalue"), !1;
                      case _keycode.default.DOWN:
                          return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger("setvalue"), !1
                  }
                  if (!e.shiftKey && (e.keyCode === _keycode.default.DELETE || e.keyCode === _keycode.default.BACKSPACE || e.keyCode === _keycode.default.BACKSPACE_SAFARI) && caretPos.begin !== buffer.length) {
                      if (buffer[e.keyCode === _keycode.default.DELETE ? caretPos.begin - 1 : caretPos.end] === opts.negationSymbol.front) return bffr = buffer.slice().reverse(), "" !== opts.negationSymbol.front && bffr.shift(), "" !== opts.negationSymbol.back && bffr.pop(), $input.trigger("setvalue", [bffr.join(""), caretPos.begin]), !1;
                      if (!0 === opts._radixDance) {
                          var radixPos = buffer.indexOf(opts.radixPoint);
                          if (opts.digitsOptional) {
                              if (0 === radixPos) return bffr = buffer.slice().reverse(), bffr.pop(), $input.trigger("setvalue", [bffr.join(""), caretPos.begin >= bffr.length ? bffr.length : caretPos.begin]), !1
                          } else if (-1 !== radixPos && (caretPos.begin < radixPos || caretPos.end < radixPos || e.keyCode === _keycode.default.DELETE && caretPos.begin === radixPos)) return caretPos.begin !== caretPos.end || e.keyCode !== _keycode.default.BACKSPACE && e.keyCode !== _keycode.default.BACKSPACE_SAFARI || caretPos.begin++, bffr = buffer.slice().reverse(), bffr.splice(bffr.length - caretPos.begin, caretPos.begin - caretPos.end + 1), bffr = alignDigits(bffr, opts.digits, opts).join(""), $input.trigger("setvalue", [bffr, caretPos.begin >= bffr.length ? radixPos + 1 : caretPos.begin]), !1
                      }
                  }
              }
          },
          currency: {
              prefix: "",
              groupSeparator: ",",
              alias: "numeric",
              digits: 2,
              digitsOptional: !1
          },
          decimal: {
              alias: "numeric"
          },
          integer: {
              alias: "numeric",
              digits: 0
          },
          percentage: {
              alias: "numeric",
              min: 0,
              max: 100,
              suffix: " %",
              digits: 0,
              allowMinus: !1
          },
          indianns: {
              alias: "numeric",
              _mask: function _mask(opts) {
                  return "(" + opts.groupSeparator + "99){*|1}(" + opts.groupSeparator + "999){1|1}"
              },
              groupSeparator: ",",
              radixPoint: ".",
              placeholder: "0",
              digits: 2,
              digitsOptional: !1
          }
      })
  }, function(module, exports, __webpack_require__) {
      "use strict";
      var _window = _interopRequireDefault(__webpack_require__(8)),
          _inputmask = _interopRequireDefault(__webpack_require__(1)),
          _canUseDOM = _interopRequireDefault(__webpack_require__(9));

      function _typeof(obj) {
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
              return typeof obj
          } : function _typeof(obj) {
              return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
          }, _typeof(obj)
      }

      function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
      }

      function _inherits(subClass, superClass) {
          if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
          subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                  value: subClass,
                  writable: !0,
                  configurable: !0
              }
          }), superClass && _setPrototypeOf(subClass, superClass)
      }

      function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived),
                  result;
              if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget)
              } else result = Super.apply(this, arguments);
              return _possibleConstructorReturn(this, result)
          }
      }

      function _possibleConstructorReturn(self, call) {
          return !call || "object" !== _typeof(call) && "function" != typeof call ? _assertThisInitialized(self) : call
      }

      function _assertThisInitialized(self) {
          if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return self
      }

      function _wrapNativeSuper(Class) {
          var _cache = "function" == typeof Map ? new Map : void 0;
          return _wrapNativeSuper = function _wrapNativeSuper(Class) {
              if (null === Class || !_isNativeFunction(Class)) return Class;
              if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
              if ("undefined" != typeof _cache) {
                  if (_cache.has(Class)) return _cache.get(Class);
                  _cache.set(Class, Wrapper)
              }

              function Wrapper() {
                  return _construct(Class, arguments, _getPrototypeOf(this).constructor)
              }
              return Wrapper.prototype = Object.create(Class.prototype, {
                  constructor: {
                      value: Wrapper,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                  }
              }), _setPrototypeOf(Wrapper, Class)
          }, _wrapNativeSuper(Class)
      }

      function _construct(Parent, args, Class) {
          return _construct = _isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
              var a = [null];
              a.push.apply(a, args);
              var Constructor = Function.bind.apply(Parent, a),
                  instance = new Constructor;
              return Class && _setPrototypeOf(instance, Class.prototype), instance
          }, _construct.apply(null, arguments)
      }

      function _isNativeReflectConstruct() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
          } catch (e) {
              return !1
          }
      }

      function _isNativeFunction(fn) {
          return -1 !== Function.toString.call(fn).indexOf("[native code]")
      }

      function _setPrototypeOf(o, p) {
          return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              return o.__proto__ = p, o
          }, _setPrototypeOf(o, p)
      }

      function _getPrototypeOf(o) {
          return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o)
          }, _getPrototypeOf(o)
      }

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      var document = _window.default.document;
      if (_canUseDOM.default && document && document.head && document.head.attachShadow && _window.default.customElements && void 0 === _window.default.customElements.get("input-mask")) {
          var InputmaskElement = function(_HTMLElement) {
              _inherits(InputmaskElement, _HTMLElement);
              var _super = _createSuper(InputmaskElement);

              function InputmaskElement() {
                  var _this;
                  _classCallCheck(this, InputmaskElement), _this = _super.call(this);
                  var attributeNames = _this.getAttributeNames(),
                      shadow = _this.attachShadow({
                          mode: "closed"
                      }),
                      input = document.createElement("input");
                  for (var attr in input.type = "text", shadow.appendChild(input), attributeNames) Object.prototype.hasOwnProperty.call(attributeNames, attr) && input.setAttribute(attributeNames[attr], _this.getAttribute(attributeNames[attr]));
                  var im = new _inputmask.default;
                  return im.dataAttribute = "", im.mask(input), input.inputmask.shadowRoot = shadow, _this
              }
              return InputmaskElement
          }(_wrapNativeSuper(HTMLElement));
          _window.default.customElements.define("input-mask", InputmaskElement)
      }
  }, function(module, exports, __webpack_require__) {
      "use strict";
      var _jquery = _interopRequireDefault(__webpack_require__(10)),
          _inputmask = _interopRequireDefault(__webpack_require__(1));

      function _typeof(obj) {
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof(obj) {
              return typeof obj
          } : function _typeof(obj) {
              return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
          }, _typeof(obj)
      }

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      void 0 === _jquery.default.fn.inputmask && (_jquery.default.fn.inputmask = function(fn, options) {
          var nptmask, input = this[0];
          if (void 0 === options && (options = {}), "string" == typeof fn) switch (fn) {
              case "unmaskedvalue":
                  return input && input.inputmask ? input.inputmask.unmaskedvalue() : (0, _jquery.default)(input).val();
              case "remove":
                  return this.each(function() {
                      this.inputmask && this.inputmask.remove()
                  });
              case "getemptymask":
                  return input && input.inputmask ? input.inputmask.getemptymask() : "";
              case "hasMaskedValue":
                  return !(!input || !input.inputmask) && input.inputmask.hasMaskedValue();
              case "isComplete":
                  return !input || !input.inputmask || input.inputmask.isComplete();
              case "getmetadata":
                  return input && input.inputmask ? input.inputmask.getmetadata() : void 0;
              case "setvalue":
                  _inputmask.default.setValue(input, options);
                  break;
              case "option":
                  if ("string" != typeof options) return this.each(function() {
                      if (void 0 !== this.inputmask) return this.inputmask.option(options)
                  });
                  if (input && void 0 !== input.inputmask) return input.inputmask.option(options);
                  break;
              default:
                  return options.alias = fn, nptmask = new _inputmask.default(options), this.each(function() {
                      nptmask.mask(this)
                  })
          } else {
              if (Array.isArray(fn)) return options.alias = fn, nptmask = new _inputmask.default(options), this.each(function() {
                  nptmask.mask(this)
              });
              if ("object" == _typeof(fn)) return nptmask = new _inputmask.default(fn), void 0 === fn.mask && void 0 === fn.alias ? this.each(function() {
                  if (void 0 !== this.inputmask) return this.inputmask.option(fn);
                  nptmask.mask(this)
              }) : this.each(function() {
                  nptmask.mask(this)
              });
              if (void 0 === fn) return this.each(function() {
                  nptmask = new _inputmask.default(options), nptmask.mask(this)
              })
          }
      })
  }, function(module, exports, __webpack_require__) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
          value: !0
      }), exports.default = void 0;
      var _bundle = _interopRequireDefault(__webpack_require__(15));

      function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
              default: obj
          }
      }
      __webpack_require__(25);
      var _default = _bundle.default;
      exports.default = _default
  }], installedModules = {}, __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function(exports, name, getter) {
      __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
          enumerable: !0,
          get: getter
      })
  }, __webpack_require__.r = function(exports) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module"
      }), Object.defineProperty(exports, "__esModule", {
          value: !0
      })
  }, __webpack_require__.t = function(value, mode) {
      if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
      if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
      var ns = Object.create(null);
      if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
              enumerable: !0,
              value: value
          }), 2 & mode && "string" != typeof value)
          for (var key in value) __webpack_require__.d(ns, key, function(key) {
              return value[key]
          }.bind(null, key));
      return ns
  }, __webpack_require__.n = function(module) {
      var getter = module && module.__esModule ? function getDefault() {
          return module.default
      } : function getModuleExports() {
          return module
      };
      return __webpack_require__.d(getter, "a", getter), getter
  }, __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property)
  }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 26);

  function __webpack_require__(moduleId) {
      if (installedModules[moduleId]) return installedModules[moduleId].exports;
      var module = installedModules[moduleId] = {
          i: moduleId,
          l: !1,
          exports: {}
      };
      return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports
  }
  var modules, installedModules
});